{"diff": "diff --git a/CHANGELOG.md b/CHANGELOG.md\nindex 3b59835..6ed4140 100644\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -1,277 +1,283 @@\n # Changelog\n [unreleased]\n+- Added `el_key` method for adding keys to `El`s (#354).\n - Enabled all additional markdown [extensions](https://docs.rs/pulldown-cmark/latest/pulldown_cmark/struct.Options.html).\n - Removed `'static` bound from `El` and `Node`.\n - [BREAKING] Changed `perform_cmd` and `seed::browser::service::fetch` return type to `T` instead of `Result<T, T>`.\n - Added Aria attributes.\n - [BREAKING] `UpdateEl<T>` changed to `UpdateEl<Ms>` and `fn update(self, el: &mut T);` to `fn update_el(self, el: &mut El<Ms>);` (#370).\n - Added trait `UpdateElForIterator<Ms>`.\n - Added support for all `Iterator`s, `Option`, `u32`, `i32`, `usize`, `f64` and references in element creation macros (#365, #128).\n - [BREAKING] `String` implements `UpdateEl<T>`. (References are now required for `String` properties, e.g. `div![&model.title]`.)\n - Fixed `href` detection to ignore `use` elements (#384).\n - Added methods `subscribe`, `subscribe_with_handle`, `perform_cmd_with_handle`, `stream`, `stream_with_handle` and `notify` into `Orders` (#130).\n - Added `cmds::timeout`, `stream::interval`, `stream::window_event`, `stream::document_event`, `subs::UrlChanged` and `subs::UrlRequested` (#131).\n - [BREAKING] Futures in `perform_cmd` and `perform_g_cmd` are executed immediately.\n - Added `App` methods `notify` and `notify_with_notification`.\n - [BREAKING] `App` method `process_cmd_and_msg_queue` renamed to `process_effect_queue`.\n - [BREAKING] Url change listeners are always active (even if `routes` is not defined).\n - Added `cmds`, `streams`, `subs`, `CmdHandle`, `SubHandle` and `StreamHandle` into the Seed's prelude.\n - [BREAKING] Removed module `next_tick`.\n - Added method `App::start` (alternative to `AppBuilder`) (#376, #382).\n - Added trait `GetElement` + included in the `prelude` (alternative to `MountPoint`, used in `AppStart`).\n - Derive `Debug` for `ElRef`.\n - Added macros `C!` and `IF!` and helper `not` (#375).\n - Added trait `ToClasses` + included in the `prelude`.\n - `ev` accepts handlers that return `Msg`, `Option<Msg>` or `()` (#394).\n - [BREAKING] `EventHandler::new` accepts only handlers that return `Option<Msg>`.\n - [BREAKING] `ev`-like functions and some `Orders` method require `'static` bound for generic types (temporary).\n - `Orders::after_next_render` now accepts callbacks that return `Msg`, `Option<Msg>` or `()`.\n - [deprecated] `View` is deprecated in favor of `IntoNodes`.\n - [BREAKING] `View` isn't implemented for `El` and `Vec<El>`.\n - [BREAKING] `Node::add_listener` renamed to `add_event_handler`.\n - Rewritten `README.md`.\n - Added new Fetch API module. See [`seed::browser::fetch`](https://docs.rs/seed/0.7.0/seed/browser/fetch/index.html) (#353)\n - [deprecated] - `seed::browser::service::fetch` module is deprecated in favor of `seed::browser::fetch`.\n - Implemented `IntoNodes` for `Option<Node<Msg>>` and `Option<Vec<Node<Msg>>>`.\n - Implemented `UpdateEl` for `i64` and `u64`.\n - Reset properties `checked` and `value` on attribute remove (#405). \n-- Added examples `markdown`, `tea_component`, `subscribe`, `custom_elements`, `fetch`, `url`, `pages`, `pages_hash_routing`, `pages_keep_state`, `auth` and `graphql` (#400).\n+- Added examples `markdown`, `tea_component`, `subscribe`, `custom_elements`, `fetch`, `url`, `pages`, `pages_hash_routing`, `pages_keep_state`, `auth`, `bunnies` and `graphql` (#400).\n - Updated examples and extended examples.\n - Removed example `app_builder`.\n - Added base url handling + method `Orders::clone_base+path` (#369).\n - [BREAKING] Updated `Url` and `routing.rs`.\n - [deprecated] `seed::browser::service::storage`.\n - Added `LocalStorage`, `SessionStorage` and `WebStorage` (trait).\n+- Added `TouchEvent` and `touch_ev` definitions.\n+- Added `DragEvent` and `drag_ev` definitions.\n+- [BREAKING] Renamed `to_kbevent` to `to_keyboard_event`.\n+- [BREAKING] `after_next_render` returns `RenderInfo`.\n+- `web_sys` and `wasm_bindgen` available in `seed::web_sys` and `seed::wasm_bindgen`.\n \n ## v0.6.0\n - Implemented `UpdateEl` for `Filter` and `FilterMap`.\n - Added method `El::is_custom(&self)`.\n - Fixed custom elements patching (#325).\n - Removed unnecessary error message for comment nodes.\n - [BREAKING] Removed deprecated `update` and `trigger_update_ev`.\n - [BREAKING] Removed the remains of lifecycle hooks.\n - Fixed `value` and `checked` setting for input elements (a bug in VirtualDOM patch algorithm).\n - [BREAKING] Removed unpredictable internal input listeners - Seed will not longer react to external input value changes.\n - [BREAKING] Use `EventHandler` instead of `Listener`. (`Listener` is now used as the internal DOM EventListener representation.)\n - [deprecated] `raw_ev` is deprecated in favor of `ev`. Functionality is the same.\n - Improved performance - rewritten event-handling and other refactors in VirtualDOM.\n - Fixed processing of multiple event-handlers (#138).\n - Added DOM Element references - see `ElRef` and examples (`canvas`, `user_media` or `todomvc`) (#115).\n - Removed `Ms: Clone` restriction as much as possible.\n - [BREAKING] Added or changed `Custom` variant from `Custom(String)` to `Custom(Cow<'static, str>)`\n   in `Ev`, `Tag`, `At` and `St`. Use function `from` to create custom entities (e.g. `At::from(\"my-attribute\")`) (#208).\n - Added macro `nodes!`. It accepts `Node<Msg>` and `Vec<Node<Msg`, returns flattened `Vec<Node<Msg>`.\n - Refactored all examples.\n - Fixed and rewritten example `todomvc`.\n - Renamed `counter` example to `counter_advanced`.\n - Renamed `drop` example to `drop_zone`.\n - Removed `server_interaction_detailed` example.\n - Added a new simpler `counter` example.\n - Changed example in the main `README.md`.\n - Added flag `#![forbid(unsafe_code)]` so the Seed will be marked as a safe library by the Rust community tools.\n - Removed `clone` restriction from the method `Effect::map_msg`.\n - Implemented `UpdateEl` for `FlatMap`.\n - Adapted to Rust 1.41.0.\n \n ## v0.5.1\n - [BREAKING] `MessageMapper::map_message` changed to `MessageMapper::map_msg`.\n - [BREAKING] `fetch` and `storage` moved to `seed::browser::service::{fetch, storage}`,\n but reimported at the lib level. Ie: `seed::fetch`, and `seed::storage`.\n - Added support for `Vec<Attr>` and `Vec<Style>` in view macros.\n - `App` included in `prelude`.\n - [BREAKING] Seed refactored to use `async/.await`. `fetch.rs` docs updated.\n - Export `Attrs`, `Style`, `Listener`. ie, can import with `seed::Style` etc.\n - Fixed a bug causing the docs not to build.\n \n ## v0.5.0\n - Added helper `seed::canvas()`, and `seed::canvas_context()` helper functions.\n - Fixed `Url` parsing (resolves issue with hash routing).\n - [BREAKING] `From<String> for Url` changed to `TryFrom<String> for Url`.\n - Fixed jumping cursor in inputs (#158) .\n - Added method `orders.after_next_render(Option<RenderTimestampDelta>)` (#207).\n - Fixed a bug with back/forward routing to the landing page (#296).\n - Deprecated `Init` struct, replacing it with `BeforeMount` and `AfterMount` structs to\n better denote state before and after mounting the `App` occurs.\n - Added a new function `builder` which replaces `build` as part of deprecating `Init`.\n - Added a new function `build_and_start` which replaces `finish` as part of deprecating `Init`.\n - Added `IntoInit`and `IntoAfterMount` traits. It is possible to use these\n in place of a closure or function to produce the corresponding `Init` and `AfterMount` structs.\n - Messages sent from `IntoAfterMount` will now be run after the routing message.\n - Added example `app_builder`.\n - `events::Listener` is included in `prelude`.\n - `()`s  have been replaced with structs - e.g. `GMs = ()` => `GMs = UndefinedGMs`.\n - `WindowEvents` alias changed to `WindowEventsFn` for consistency with other `*Fn`.\n - Commented builder and helper methods.\n \n ## v0.4.2\n - Added an `Init` struct, which can help with initial routing (Breaking)\n - The `routes` function now returns an `Option<Msg>` (Breaking)\n - Updated `Tag::from()` to accept more input types\n - `style!` now accepts also `Option<impl ToString>`\n - Fixed a bug affecting element render order\n - Added a `hashchange` listener\n - Improved error-handling\n - Tweaked bootstrap order so that `main_el_vdom` is initialized first (internal)\n - Macro `custom!` checks if you set tag, and panics when you forget\n - Fixed a bug with children being absent from cloned elements\n - Improved debugging\n - Fixed a namespace bug with adding children to `Svg` elements\n - Fixed a bug affecting Safari\n - Added `seed::html_document()` and `seed::cookies` convenience functions\n \n ## v0.4.1\n - Added more SVG `At` variants\n - Added the `St` enum, for style keys; similar to `At`\n - Improved ergonomics of `add_child`, `add_attr`, `add_class`,\n `add_style`, `replace_text`, and `add_text`, `Node` methods\n \n ## v0.4.0\n - `ElContainer`, imported in prelude, renamed to `View`. (Breaking)\n - Internal refactor of `El`: Now wrapped in `Node`, along with\n `Empty` and `Text`. Creation macros return `Node(Element)`. (Breaking)\n - Changed the way special attributes like `disabled`, `autofocus`, and\n `checked` are handled (Breaking)\n - `MessageMapper` now accepts closures\n - `Orders` is a trait now instead of a struct. (Breaking)\n - Significant changes to MessageMapper\n - Orders has new methods, `clone_app` and `msg_mapper` which can allow access to app instance.\n - Added more SVG element macros\n - Several minor bux fixes\n - Examples updated to reflect these changes\n - Improvements to Fetch API, especially regarding error handling\n and deserialization\n \n ## v0.3.7\n - `routes` now accepts `Url` instead of `&Url` (Breaking)\n - Improvements to fetch API\n - Added `raw!`, `md!`, and `plain!` macros that alias `El::from_html`, `El::from_markdown`,\n and `El::new_text` respectively\n - `Attrs!` and `Style!` macros can now use commas and whitespace as separators,\n in addition to semicolons\n - Fixed typos in a few attributes (Breaking)\n - Fixed a bug where an HTML namespace was applied to raw html/markdown elements\n - New conditional syntax added in `class!` macro, similar to `Elm`'s `classList`\n - `Listener` now implements `MessageMapper`\n - `El methods` `add_child`, `add_style`, `add_attr`, and `set_text` now return the elements,\n allowing chaining\n - Fixed a bug with `set_text`. Renamed to `replace_text`. Added `add_text`, which adds\n a text node, but doesn't remove existing ones. Added `add_class`. (Breaking)\n \n \n ## v0.3.6\n - Fetch module and API heavily changed (breaking)\n - Added support for `request\u200bAnimation\u200bFrame`, which improves render performance,\n especially for animations\n - Styles no longer implicitly add `px`. Added `unit!` macro in its place\n - `Map` can now be used directly in elements, without needing to annotate type and collect\n (ie for child `Elements`, and `Listener`s)\n - Significant changes to MessageMapper\n - Orders hs new methods, `clone_app` and `msg_mapper` that allow access to app instance.\n - Fixed a bug where `empty` elements at the top-level were rendering in the wrong order\n - Added an `empty!` macro, which is similar to `seed::empty`\n - Attributes and style now retain order\n \n ## v0.3.5\n - Fixed a bug where view functions returning `Vec<El>` weren't rendering properly\n - Fixed a typo with the `viewBox` attribute\n \n ## v0.3.4\n - The `update` fn now accepts a (new) `Orders` struct, and returns nothing. Renders occur implicitly,\n with the option to skip rendering, update with an additional message, or perform an asynchronous\n action. (Breaking)\n - `.mount()` now accepts elements. Deprecated `.mount_el()`\n - The `log` function and macro now support items which implement `Debug`\n - Removed deprecated `routing::push_path` function (breaking)\n \n ## v0.3.3\n - Added `seed::update` function, which allows custom events, and updates from JS\n \n ## v0.3.2\n - Top level view functions can now return `Vec<El<Ms>>`, `El<Ms>`, or something else implementing\n the new ElContainer trait\n \n ## v0.3.1\n - Top level view functions now return `Vec<El<Ms>>` instead of `El<Ms>`, mounted directly to\n  the mount point. (Breaking)\n - `push_route()` can now accept a `Vec<&str>`, depreciating `push_path()`\n - Fixed a bug where window events couldn't be enabled on initialization\n \n ## v0.3.0\n - `update` function now takes a mutable ref of the model. (Breaking)\n - `Update` (update's return type) is now a struct. (Breaking)\n - Async, etc events are now handled through messages, instead of passing `App`\n through the view func. (Breaking)\n - Fixed some bugs with empty elements\n - Internal code cleanup\n - Added commented-out release command to example build files\n - Added more tests\n \n ## v0.2.10\n - Routing can be triggered by clicking any element containing a `Href` attribute\n with value as a relative link\n - Internal links no longer trigger a page refresh\n - Models no longer need to implement `Clone`\n - Fixed a bug introduced in 0.2.9 for `select` elements\n \n ## v0.2.9\n - Added a `RenderThen` option to `Update`, which allows chaining update messages\n - Added a `.model` method to `Update`, allowing for cleaner recursion in updates\n - Improved controlled-component (sync fields with model) logic\n \n ## v0.2.8\n - Reflowed `El::from_html` and `El::from_markdown` to return `Vec`s of `El`s, instead of wrapping\n them in a single span.\n - Improved support for SVG and namespaces\n - Added `set_timeout` wrapper\n \n ## v0.2.7\n - Fixed a bug where `line!` macro interfered with builtin\n - Fixed a bug with routing search (ie `?`)\n \n ## v0.2.6\n - Fixed a bug where children would render out-of-order\n - Improved vdom diffing logic\n \n ## v0.2.5\n - Attributes and Events now can use `At` and `Ev` enums\n - Routing overhauled; modelled after react-reason. Cleaner syntax, and more flexible\n - Input, Textarea, and Select elements are now \"controlled\" - they always\n stay in sync with the model\n - index.html file updated in examples and quickstart to use relative paths,\n which fixes landing-page routing\n \n ## v0.2.4\n - Changed render func to use a new pattern (Breaking)\n - Default mount point added: \\\"app\\\" for element id\n - View func now takes a ref to the model instead of the model itself\n - Routing refactored; now works dynamically\n - Update function now returns an enum that returns Render or Skip,\n to allow conditional rendering (Breaking)\n - Elements can now store more than 1 text node\n \n ## V0.2.3\n - Fixed a bug where initially-empty text won't update\n - Added more tests\n - Exposed web_sys Document and Window in top level of Seed create, with .expect\n - Modified build scripts to keep the wasm output name fixed at 'package', simplifying example/quickstart renames\n - Tests now work in Windows due to update in wasm-pack\n \n ## V0.2.2\n - Overhaul of fetch module\n - Added server-integration example\n \n ## V0.2.1\n - Added support for custom tags\n - Added `class!` and `id!` convenience macros for setting style\n \n ## v0.2.0\n \n - Added high-level fetch api\n - Added routing\n - Added element lifecycles (did_mount, did_update, will_unmount)\n - Added support for updating state outside events\n - Added server_interaction, and homepage (this site) examples\n \n ## v0.1.0\n \n - Initial release\ndiff --git a/Cargo.toml b/Cargo.toml\nindex bbaebdc..25ccd2f 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,131 +1,138 @@\n [package]\n name = \"seed\"\n version = \"0.6.0\"\n description = \"A Rust framework for creating web apps, using WebAssembly\"\n authors = [\"DavidOConnor <david.alan.oconnor@gmail.com>\", \"Martin Kav\u00edk <martin@kavik.cz>\"]\n license = \"MIT\"\n repository = \"https://github.com/seed-rs/seed\"\n homepage = \"https://seed-rs.org\"\n documentation = \"https://docs.rs/seed\"\n readme = \"README.md\"\n keywords = [\"wasm\", \"webassembly\", \"frontend\", \"framework\", \"web\"]\n categories = [\"wasm\", \"web-programming\"]\n edition = \"2018\"\n \n build = \"build.rs\"\n \n [build-dependencies]\n version_check = \"0.9.1\"\n \n [dev-dependencies]\n wasm-bindgen-test = \"0.3.10\"\n \n [dependencies]\n console_error_panic_hook = \"0.1.6\"\n cookie = { version = \"0.13.3\", features = [\"percent-encode\"] }\n enclose = \"1.1.8\"\n gloo-timers = { version = \"0.2.1\", features = [\"futures\"] }\n indexmap = \"1.3.2\"\n js-sys = \"0.3.37\"\n pulldown-cmark = \"0.7.0\"\n serde = { version = \"1.0.106\", features = ['derive'] }\n serde_json = \"1.0.51\"\n wasm-bindgen = {version = \"0.2.60\", features = [\"serde-serialize\"]}\n wasm-bindgen-futures = \"0.4.10\"\n # @TODO: remove once we can use entities without `Debug` in `log!` and `error!` on `stable` Rust.\n # https://github.com/Centril/rfcs/blob/rfc/quick-debug-macro/text/0000-quick-debug-macro.md#types-which-are-not-debug\n dbg = \"1.0.4\"\n futures = \"0.3.4\"\n uuid = { version = \"0.8.1\", features = [\"v4\", \"wasm-bindgen\"] }\n \n [dependencies.web-sys]\n version = \"0.3.37\"\n features = [\n     \"AbortController\",\n     \"AbortSignal\",\n     \"CanvasRenderingContext2d\",\n     \"CustomEvent\",\n     \"CustomEventInit\",\n+    \"DataTransfer\",\n     \"Document\",\n     \"DomException\",\n+    \"DragEvent\",\n     \"Element\",\n     \"Event\",\n     \"EventTarget\",\n     \"HashChangeEvent\",\n     \"Headers\",\n     \"History\",\n     \"HtmlElement\",\n     \"HtmlCanvasElement\",\n     \"HtmlCollection\",\n     \"HtmlDocument\",\n     \"HtmlInputElement\",\n     \"HtmlMenuItemElement\",\n     \"HtmlProgressElement\",\n     \"HtmlOptionElement\",\n     \"HtmlDataElement\",\n     \"HtmlMeterElement\",\n     \"HtmlLiElement\",\n     \"HtmlOutputElement\",\n     \"HtmlParamElement\",\n     \"HtmlTextAreaElement\",\n     \"HtmlSelectElement\",\n     \"HtmlButtonElement\",\n     \"Location\",\n     \"MouseEvent\",\n     \"Node\",\n     \"NodeList\",\n     \"Performance\",\n     \"PointerEvent\",\n     \"PopStateEvent\",\n     \"ReferrerPolicy\",\n     \"Request\",\n     \"RequestCache\",\n     \"RequestCredentials\",\n     \"RequestInit\",\n     \"RequestMode\",\n     \"RequestRedirect\",\n     \"Response\",\n     \"Selection\",\n     \"Storage\",\n     \"Text\",\n+    \"Touch\",\n+    \"TouchEvent\",\n+    \"TouchList\",\n     \"console\",\n     \"Window\",\n     \"KeyboardEvent\",\n     \"InputEvent\",\n     \"Url\",\n+    \"UrlSearchParams\",\n ]\n \n [workspace]\n members = [\n     \"examples/animation_frame\",\n-    \"examples/app_builder\",\n     \"examples/auth\",\n+    \"examples/bunnies\",\n     \"examples/counter\",\n     \"examples/counter_advanced\",\n     \"examples/canvas\",\n     \"examples/custom_elements\",\n     \"examples/drop_zone\",\n+    \"examples/el_key\",\n     \"examples/graphql\",\n     \"examples/markdown\",\n     \"examples/fetch\",\n     \"examples/mathjax\",\n     \"examples/orders\",\n     \"examples/pages\",\n     \"examples/pages_hash_routing\",\n     \"examples/pages_keep_state\",\n     # \"examples/server_integration\",   # has own workspace\n     \"examples/server_interaction\",\n     \"examples/subscribe\",\n     \"examples/tea_component\",\n     \"examples/todomvc\",\n     \"examples/update_from_js\",\n     \"examples/url\",\n     \"examples/user_media\",\n     \"examples/websocket\",\n     \"examples/window_events\",\n ]\n \n exclude = [\n     # it has own workspace\n     \"examples/server_integration\",\n ]\ndiff --git a/Makefile.toml b/Makefile.toml\nindex 3ac3bdf..09b55d7 100644\n--- a/Makefile.toml\n+++ b/Makefile.toml\n@@ -1,308 +1,313 @@\n [env]\n # Reset rustup recursion limit because otherwise `cargo make clippy_all` fails.\n # https://github.com/rust-lang/rustup.rs/blob/d35f94183601a81489bce025c2abc35cd395c909/src/toolchain.rs#L296\n RUST_RECURSION_COUNT = \"0\"\n \n # ---- SCRIPTS ----\n \n [tasks.populate_all]\n description = \"Populate styles, tags, attributes, etc.\"\n workspace = false\n dependencies = [\"populate_styles\"]\n \n [tasks.populate_styles]\n description = \"Populate styles\"\n workspace = false\n command = \"cargo\"\n args = [\"script\", \"./scripts/populate_styles.rs\"]\n \n # ---- GENERAL ----\n \n [tasks.verify]\n description = \"Format, lint with Clippy, build, run tests, simulate publish\"\n workspace = false\n dependencies = [\"fmt_all\", \"clippy_all\", \"all\", \"test_h_firefox\", \"publish_dry_run\"]\n \n [tasks.verify_for_ci]\n description = \"Like `verify`, but fails if the code isn't formatted and you should run tests with other commands.\"\n workspace = false\n dependencies = [\"fmt_all_check\", \"clippy_all\", \"all\", \"publish_dry_run\"]\n \n # ---- BUILD ----\n \n [tasks.build]\n description = \"Build only Seed\"\n clear = true\n workspace = false\n command = \"cargo\"\n args = [\"build\"]\n \n [tasks.build_release]\n extend = \"build\"\n description = \"Build only Seed in relase mode\"\n args = [\"build\", \"--release\"]\n \n [tasks.all]\n description = \"Build Seed and examples\"\n workspace = false\n dependencies = [\"build\", \"build_examples\"]\n \n [tasks.all_release]\n extend = \"all\"\n description = \"Build Seed and examples in release mode\"\n dependencies = [\"build_release\", \"build_examples_release\"]\n \n [tasks.one]\n description = \"Build Seed and chosen example. Ex: 'cargo make one counter'\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"--cwd\", \"./examples/${@}\", \"build\"]\n dependencies = [\"build\"]\n \n [tasks.one_release]\n extend = \"one\"\n description = \"Build Seed and chosen example in release mode. Ex: 'cargo make one counter'\"\n args = [\"make\", \"--cwd\", \"./examples/${@}\", \"build_release\"]\n dependencies = [\"build_release\"]\n \n # ---- LINT ----\n \n [tasks.fmt_all]\n description = \"Format Seed and all examples with rustfmt\"\n workspace = false\n dependencies = [\"fmt\", \"fmt_examples\"]\n \n [tasks.fmt_all_check]\n description = \"Check format of Seed and all examples with rustfmt\"\n workspace = false\n dependencies = [\"fmt_check\", \"fmt_examples_check\"]\n \n [tasks.clippy]\n description = \"Lint only Seed with Clippy\"\n clear = true\n workspace = false\n install_crate = { rustup_component_name = \"clippy\", binary = \"cargo-clippy\", test_arg = \"--help\" }\n command = \"cargo\"\n args = [\"clippy\", \"--all-features\", \"--\", \"--deny\", \"warnings\", \"--deny\", \"clippy::pedantic\", \"--deny\", \"clippy::nursery\"]\n \n [tasks.clippy_one]\n description = \"Lint Seed and chosen example with Clippy. Ex: 'cargo make clippy_one counter'\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"--cwd\", \"./examples/${@}\", \"clippy\"]\n dependencies = [\"clippy\"]\n \n [tasks.clippy_all]\n description = \"Lint Seed and all examples with Clippy\"\n workspace = false\n dependencies = [\"clippy\", \"clippy_examples\"]\n \n [tasks.publish_dry_run]\n description = \"Check the crate can be published\"\n workspace = false\n command = \"cargo\"\n args = [\"publish\", \"--dry-run\", \"--allow-dirty\"]\n \n # ---- TEST ----\n \n # wasm-pack test docs:\n # https://rustwasm.github.io/wasm-pack/book/commands/test.html\n \n [tasks.test]\n description = \"Run Seed's tests. Ex: 'cargo make test firefox'. Test envs: [chrome, firefox, safari]\"\n clear = true\n workspace = false\n install_crate = { crate_name = \"wasm-pack\", binary = \"wasm-pack\", test_arg = \"-V\" }\n command = \"wasm-pack\"\n args = [\"test\", \"--${@}\"]\n \n [tasks.test_release]\n extend = \"test\"\n description = \"Run Seed's tests in release mode. Ex: 'cargo make test firefox'. Test envs: [chrome, firefox, safari]\"\n args = [\"test\", \"--${@}\", \"--release\"]\n \n [tasks.test_h]\n description = \"Run headless Seed's tests. Ex: 'cargo make test_h firefox'. Test envs: [chrome, firefox, safari]\"\n extend = \"test\"\n args = [\"test\", \"--headless\", \"--${@}\"]\n \n [tasks.test_h_firefox]\n description = \"Run headless Seed's tests with Firefox.\"\n extend = \"test\"\n args = [\"test\", \"--headless\", \"--firefox\"]\n \n [tasks.test_h_release]\n extend = \"test_h\"\n description = \"Run headless Seed's tests in release mode. Ex: 'cargo make test_h firefox'. Test envs: [chrome, firefox, safari]\"\n args = [\"test\", \"--headless\", \"--${@}\", \"--release\"]\n \n [tasks.test_one]\n description = \"Run a single test in Firefox. Ex 'cargo make test_one my_test'\"\n clear = true\n workspace = false\n install_crate = { crate_name = \"wasm-pack\", binary = \"wasm-pack\", test_arg = \"-V\" }\n command = \"wasm-pack\"\n args = [\"test\", \"--firefox\", \"--\", \"--lib\", \"${@}\"]\n \n [tasks.test_one_h]\n description = \"Run a single test in headless Firefox. Ex 'cargo make test_one_h my_test'\"\n clear = true\n workspace = false\n install_crate = { crate_name = \"wasm-pack\", binary = \"wasm-pack\", test_arg = \"-V\" }\n command = \"wasm-pack\"\n args = [\"test\", \"--firefox\", \"--headless\", \"--\", \"--lib\", \"${@}\"]\n \n # ---- START ----\n \n [tasks.start]\n description = \"Start chosen example. Ex: 'cargo make start counter'\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"--cwd\", \"./examples/${@}\", \"start\"]\n \n [tasks.start_release]\n extend = \"start\"\n description = \"Start chosen example in release mode. Ex: 'cargo make start counter'\"\n args = [\"make\", \"--cwd\", \"./examples/${@}\", \"start_release\"]\n \n [tasks.start_server]\n description = \"Start server of chosen example (only a few have one). Ex: 'cargo make start_server websocket'\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"--cwd\", \"./examples/${@}\", \"start_server\"]\n \n [tasks.start_server_release]\n extend = \"start_server\"\n description = \"Start server of chosen example (only a few have one) in release mode. Ex: 'cargo make start_server websocket'\"\n args = [\"make\", \"--cwd\", \"./examples/${@}\", \"start_server_release\"]\n \n # ---- DEFAULT TASKS FOR EXAMPLES ----\n # These tasks should be run only from the example root\n # and example's Makefile.toml should override all tasks in dependencies.\n \n [tasks.default_build]\n description = \"Build with wasm-pack\"\n workspace = false\n install_crate = { crate_name = \"wasm-pack\", binary = \"wasm-pack\", test_arg = \"-V\" }\n command = \"wasm-pack\"\n args = [\"build\", \"--target\", \"web\", \"--out-name\", \"package\", \"--dev\"]\n \n [tasks.default_build_release]\n extend = \"default_build\"\n description = \"Build with wasm-pack in release mode\"\n args = [\"build\", \"--target\", \"web\", \"--out-name\", \"package\", \"--release\"]\n \n [tasks.default_start]\n description = \"Build and start microserver\"\n workspace = false\n install_crate = { crate_name = \"microserver\", binary = \"microserver\", test_arg = \"-h\" }\n command = \"microserver\"\n args = [\"--port\", \"8000\"]\n dependencies = [\"build\"]\n \n [tasks.default_start_release]\n extend = \"default_start\"\n description = \"Build and start microserver in release mode\"\n dependencies = [\"build_release\"]\n \n [tasks.default_clippy]\n description = \"Lint with Clippy\"\n workspace = false\n install_crate = { rustup_component_name = \"clippy\", binary = \"cargo-clippy\", test_arg = \"--help\" }\n command = \"cargo\"\n-args = [\"clippy\", \"--all-features\", \"--\", \"--deny\", \"warnings\", \"--deny\", \"clippy::pedantic\", \"--deny\", \"clippy::nursery\"]\n+args = [\"clippy\", \"--all-features\", \"--\",\n+    \"--deny\", \"warnings\",\n+    \"--deny\", \"clippy::pedantic\",\n+    \"--deny\", \"clippy::nursery\",\n+    \"--allow\", \"clippy::wildcard_imports\" # for `use seed::{prelude::*, *};`\n+]\n \n # ---- HELPERS -----\n \n [tasks.build_examples]\n description = \"Build examples\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"for_each\", \"build\"]\n \n [tasks.build_examples_release]\n extend = \"build_examples\"\n description = \"Build examples in release mode\"\n args = [\"make\", \"for_each\", \"build_release\"]\n \n [tasks.fmt]\n description = \"Format with rustfmt\"\n workspace = false\n install_crate = { crate_name = \"rustfmt-nightly\", rustup_component_name = \"rustfmt\", binary = \"rustfmt\", test_arg = \"--help\" }\n command = \"cargo\"\n args = [\"fmt\", \"--all\"]\n \n [tasks.fmt_check]\n extend = \"fmt\"\n description = \"Check format with rustfmt\"\n args = [\"fmt\", \"--all\", \"--\", \"--check\"]\n \n [tasks.fmt_examples]\n description = \"Format all examples with rustfmt\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"for_each\", \"fmt\"]\n \n [tasks.fmt_examples_check]\n description = \"Check format of all examples with rustfmt\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"for_each\", \"fmt_check\"]\n \n [tasks.clippy_examples]\n description = \"Lint examples with Clippy\"\n workspace = false\n command = \"cargo\"\n args = [\"make\", \"for_each\", \"clippy\"]\n \n [tasks.for_each]\n description = \"Run chosen task for each example in its root. Ex: 'cargo make for_each build'\"\n workspace = false\n script_runner = \"@rust\"\n script = [\n     '''\n     //! ```cargo\n     //! [dependencies]\n     //! glob = \"*\"\n     //! ```\n     extern crate glob;\n \n     use std::process::{Command, exit, Stdio};\n     use std::env;\n     use glob::glob;\n \n     fn main() {\n         let args: Vec<String> = env::args().collect();\n         // args[0] is a script name, args[1] is the given task\n         if args.len() != 2 {\n             eprintln!(\"Wrong number of arguments! Correct example: 'cargo make for_each build'\");\n             exit(1);\n         }\n \n         let task = &args[1];\n         let mut exit_code = 0;\n \n         for entry in glob(\"examples/*/Makefile.toml\").unwrap() {\n             if let Ok(path) = entry {\n                 let example_root = path.parent().unwrap().to_str().unwrap();\n                 if !run_task_in_example_root(example_root, task) {\n                     exit_code = 1;\n                 }\n             }\n         }\n         exit(exit_code);\n     }\n \n     fn run_task_in_example_root(example_root: &str, task: &str) -> bool {\n         println!(\"Example root: '{}'\", example_root);\n         Command::new(\"cargo\")\n             .stdout(Stdio::inherit())\n             .stderr(Stdio::inherit())\n             .args(&[\"make\", \"--cwd\", example_root, task])\n             .output()\n             .unwrap()\n             .status\n             .success()\n     }\n     '''\n ]\ndiff --git a/README.md b/README.md\nindex 23c8bcf..e830d19 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,140 +1,129 @@\n [![crates.io version](https://meritbadge.herokuapp.com/seed)](https://crates.io/crates/seed)\n [![crates.io downloads](https://img.shields.io/crates/d/seed.svg)](https://crates.io/crates/seed)\n [![docs.rs](https://docs.rs/seed/badge.svg)](https://docs.rs/seed)\n [![Built with cargo-make](https://sagiegurari.github.io/cargo-make/assets/badges/cargo-make.svg)](https://sagiegurari.github.io/cargo-make)\n \n <p align=\"center\">\n   <img src=\"/seed_branding/seed_logo.svg\" width=\"256\" title=\"Seed logo\">\n </p>\n \n ### [Website](https://seed-rs.org) | [Forum](https://seed.discourse.group) | [Chat](https://discord.gg/JHHcHp5)\n ---\n Seed is a front-end Rust framework for creating fast and reliable web apps with an elm-like architecture.\n \n - All the benefits of Rust and macro based syntax.\n - Minimal overhead, configuration, and boilerplate.\n - Clear documentation made to be accessible regardless of your familiarity with Rust.\n - Written without any [unsafe](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) code and works with `stable` Rust, no `nightly` required!\n \n ---\n \n # Examples\n The examples provided in this repository are a good place to get started. They also act as an integration testing suite we run before every commit to ensure there are no unintended breaking changes to the user space. Because of Rust's compile-time checking, testing is that much more robust and changes can be pushed confidently.\n \n Run [examples](examples/) with `cargo make start example_name` from the Seed repository root. Here's our counter example:\n \n ```rust\n use seed::{prelude::*, *};\n \n // `init` describes what should happen when your app started.\n fn init(_: Url, _: &mut impl Orders<Msg>) -> Model {\n     Model::default()\n }\n \n // `Model` describes our app state.\n type Model = i32;\n \n // `Msg` describes the different events you can modify state with.\n enum Msg {\n     Increment,\n }\n \n // `update` describes how to handle each `Msg`.\n fn update(msg: Msg, model: &mut Model, _: &mut impl Orders<Msg>) {\n     match msg {\n         Msg::Increment => *model += 1,\n     }\n }\n \n // `view` describes what to display.\n fn view(model: &Model) -> Node<Msg> {\n     div![\n         \"This is a counter: \",\n         C![\"counter\"],\n         button![\n             model,\n             ev(Ev::Click, |_| Msg::Increment),\n         ],\n     ]\n }\n \n #[wasm_bindgen(start)]\n pub fn start() {\n     // Mount the `app` to the element with the `id` \"app\".\n     App::start(\"app\", init, update, view);\n }\n ```\n \n # Quickstart\n If you are proficient in a front-end framework, creating a standalone web app is painless. You'll notice minimal configuration:\n \n ```\n \u251c\u2500\u2500 Cargo.toml\n \u251c\u2500\u2500 Makefile.toml\n \u251c\u2500\u2500 index.html\n \u2514\u2500\u2500 src\n     \u2514\u2500\u2500 lib.rs\n ```\n \n We currently have two template repositories:\n - [Quickstart](https://github.com/seed-rs/seed-quickstart)\n - [Webpack quickstart](https://github.com/seed-rs/seed-quickstart-webpack)\n \n # Why Use Seed\n \n ### Rust\n You may prefer writing in Rust and appreciate its benefits, including:\n - Rust **safety**.\n - Rust **compile-time error, type, and immutability checking**.\n - Rust built-in testing.\n - Rust speed.\n - Cleaner code and less runtime errors.\n - Cargo packages.\n - Potential pipeline/stack language consistency.\n \n ### Developer Experience\n Our main focus is on developer experience, the benefits of which are currently:\n - Seed has a *batteries-included* approach, meaning less boilerplate and dependencies.\n - Macro syntax removes the need for transpiling and integrates naturally and flexibly with the language. This also means all the pains of embedded HTML are avoided; linting, commenting, etc. all work out of the box.\n - Built in elm-like architecture, no need for another state manager.\n - Perhaps you find JS frameworks and tools difficult to set up.\n - Very active development.\n \n See more on our [about](https://seed-rs.org/guide/about) page.\n \n # Why Not Use Seed\n - Seed is under rapid development, so there may be breaking changes at times. However, Seed is more than stable enough for personal projects, and production apps are in development.\n - Finding Rust/WASM/Seed help outside of [Discord](https://discord.gg/JHHcHp5) or [Discourse](https://seed.discourse.group) may be difficult, as tutorials and guides outside the official ones aren't yet prevalent.\n - Seed doesn't have as many existing reusable components that more mature frameworks have (date-pickers, etc.), so you may need to implement them yourself, or adapt them from existing solutions.\n \n # Documentation\n-- [Quickstart](https://seed-rs.org/guide/quickstart)\n-- [About](https://seed-rs.org/guide/about)\n-- [Code Comparison](https://seed-rs.org/guide/code-comparison)\n-- [Structure](https://seed-rs.org/guide/structure)\n-- [View Macros](https://seed-rs.org/guide/view)\n-- [Events](https://seed-rs.org/guide/events)\n-- [HTTP Requests](https://seed-rs.org/guide/http-requests-and-state)\n-- [Routing](https://seed-rs.org/guide/routing)\n-- [JavaScript Interaction](https://seed-rs.org/guide/javascript-interaction)\n-- [Release and Debugging](https://seed-rs.org/guide/release-and-debugging)\n-- [Server Integration](https://seed-rs.org/guide/server-integration)\n-- [Support](https://seed-rs.org/guide/support)\n-- [Troubleshooting] //TBA\n+- Guides on [seed-rs.org](https://seed-rs.org)\n+- API documentation on [docs.rs/seed](https://docs.rs/seed)\n \n # Resources\n ### Seed\n - [Awesome-seed-rs](https://github.com/seed-rs/awesome-seed-rs): A curated list of resources\n - [Seed Realworld](https://github.com/seed-rs/seed-rs-realworld): A detailed realworld example site\n - [Engineering Rust Web Applications](https://erwabook.com/intro/): A book describing full-stack Rust web-development, using Seed for the front-end\n \n ### Rust\n - [Rust Discord](https://discordapp.com/invite/rust-lang)\n - [Rust IRC](https://www.irccloud.com/invite?channel=%23%23rust&hostname=chat.freenode.net&port=6697&ssl=1)\n \n # Future\n - [Roadmap](https://github.com/seed-rs/seed/milestones)\n - New [Rust-only quickstart](https://github.com/MartinKavik/seeder)\n \n # Contributing\n See [CONTRIBUTING.md](CONTRIBUTING.md).\ndiff --git a/examples/README.md b/examples/README.md\nindex 704c3c7..8eca5da 100644\n--- a/examples/README.md\n+++ b/examples/README.md\n@@ -1,100 +1,106 @@\n ## Examples\n For specific details see corresponding READMEs.\n \n Consider first looking at [Counter](./counter).\n \n Most of the examples can be run by simply:\n ```sh\n cd examples/$EXAMPLE_DIR\n cargo make start\n ```\n \n ### [Homepage repo](https://github.com/seed-rs/seed-rs.org)\n The Seed homepage, also serving as an example. Includes simple\n interactions, markdown elements, routing, and view markup.\n \n ### [Animation Frame](animation_frame)\n How to make a basic animation with random generators.\n \n ### [AppBuilder](app_builder)\n Demonstrates all `AppBuilder`'s methods.\n \n+### [Bunnies](bunnies)\n+Intended as a demo of [Shipyard](https://github.com/leudz/shipyard) (Entity Component System) integration.\n+\n ### [Canvas](canvas)\n How to make a canvas element and use `ElRef`s.\n \n ### [Counter](counter)\n Intended as a demo of basic functionality.\n \n ### [Counter Advanced](counter_advanced)\n Intended as a more sophisticated demo of basic functionality.\n \n ### [Custom Elements](custom_elements)\n How to create and use custom elements.\n \n ### [Drop Zone](drop_zone)\n How to create a drop-zone.\n \n+### [Element Key](el_key)\n+How to control a DOM update using element keys and empty nodes.\n+\n ### [Markdown](markdown)\n How to render markdown.\n \n ### [Mathjax](mathjax)\n An example using Mathjax, for LaTeX-like math notation.\n \n ### [Orders](orders)\n How to perform commands and send messages from `update` function.\n And how to use [gloo](https://github.com/rustwasm/gloo) timers.\n \n ### [Pages](pages)\n How to create and browse multiple pages in your app.\n \n ### [Pages with hash routing](pages_hash_routing)\n How to create and browse multiple pages in your app.\n This example uses hash routing.\n \n ### [Pages that keep their state](pages_keep_state)\n How to create and browse multiple pages in your app.\n Pages keep their state.\n \n ### [Subscribe](subscribe)\n How to create and use subscriptions, streams, notifications and commands.\n \n ### [TEA component](tea_component)\n How to write a component in The Elm architecture.\n You'll also learn how to pass messages to the parent component.\n \n ### [Fetch](fetch)\n How to make HTTP request using Fetch API.\n \n ### [Todo MVC](todomvc)\n Classic TodoMVC example with Local Storage.\n \n ### [Update from JS](update_from_js)\n How to trigger `update` function from Javascript world.\n You'll also see how to call JS functions from Rust.\n \n ### [Url](url)\n Intended as a demo of Url functions and browser navigation.\n \n ### [UserMedia](user_media)\n How to show your webcam output in `video` element.\n \n ### [Window Events](window_events)\n A demonstration of event-handlers attached to the `window`.\n \n ## Server\n Backend server integration & interaction examples.\n \n ### [Auth](auth)\n How to implement login / logout.\n \n ### [GraphQL](graphql)\n How to communicate with a GraphQL backend.\n \n ### [Integration](server_integration)\n Example of a workspace with [Actix](https://actix.rs/) server.\n \n ### [Interaction](server_interaction)\n Example of communicating with a server using HTTP requests.\n \n ### [Websocket Chat](websocket)\n Example of communicating with a server using Websockets.\ndiff --git a/examples/animation_frame/src/lib.rs b/examples/animation_frame/src/lib.rs\nindex b2bfc41..2d68002 100644\n--- a/examples/animation_frame/src/lib.rs\n+++ b/examples/animation_frame/src/lib.rs\n@@ -1,180 +1,180 @@\n use rand::prelude::*;\n use seed::{prelude::*, *};\n \n // ------ ------\n //     Model\n // ------ ------\n \n type CarColor = String;\n \n #[derive(Debug)]\n struct Car {\n     x: f64,\n     y: f64,\n     speed: f64,\n     color: CarColor,\n     width: f64,\n     height: f64,\n }\n \n impl Car {\n     /// Pixels per second.\n     /// _Note_:\n     /// Optional feature \"wasm-bindgen\" has to be enabled for crate `rand` (otherwise it panics).\n     fn generate_speed() -> f64 {\n         thread_rng().gen_range(400., 800.)\n     }\n \n     fn generate_color() -> CarColor {\n         let hue = thread_rng().gen_range(0, 360);\n         format!(\"hsl({}, 80%, 50%)\", hue)\n     }\n }\n \n impl Default for Car {\n     fn default() -> Self {\n         let car_width = 120.;\n         Self {\n             x: -car_width,\n             y: 100.,\n             speed: Self::generate_speed(),\n             color: Self::generate_color(),\n             width: car_width,\n             height: 60.,\n         }\n     }\n }\n \n #[derive(Default)]\n struct Model {\n     viewport_width: f64,\n     car: Car,\n }\n \n // ------ ------\n //  After Mount\n // ------ ------\n \n fn after_mount(_: Url, orders: &mut impl Orders<Msg>) -> AfterMount<Model> {\n     orders\n         .send_msg(Msg::SetViewportWidth)\n         .after_next_render(Msg::Rendered);\n     AfterMount::default()\n }\n \n // ------ ------\n //    Update\n // ------ ------\n \n #[derive(Clone, Copy)]\n enum Msg {\n-    Rendered(Option<RenderTimestampDelta>),\n+    Rendered(RenderInfo),\n     SetViewportWidth,\n }\n \n fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n     match msg {\n-        Msg::Rendered(delta) => {\n-            let delta = f64::from(delta.unwrap_or_default());\n+        Msg::Rendered(render_info) => {\n+            let delta = render_info.timestamp_delta.unwrap_or_default();\n             if delta > 0. {\n                 // move car at least 1px to the right\n                 model.car.x += f64::max(1., delta / 1000. * model.car.speed);\n \n                 // we don't see car anymore => back to start + generate new color and speed\n                 if model.car.x > model.viewport_width {\n                     model.car = Car::default();\n                 }\n             }\n             orders.after_next_render(Msg::Rendered);\n         }\n         Msg::SetViewportWidth => {\n             model.viewport_width = f64::from(body().client_width());\n             orders.skip();\n         }\n     }\n }\n \n // ------ ------\n //     View\n // ------ ------\n \n fn view(model: &Model) -> Node<Msg> {\n     // scene container, also represents sky\n     div![\n         id!(\"animation\"),\n         style! {\n             St::Overflow => \"hidden\";\n             St::Width => unit!(100, %);\n             St::Position => \"relative\";\n             St::Height => unit!(170, px);\n             St::BackgroundColor => \"deepskyblue\";\n         },\n         // road\n         div![style! {\n             St::Width => unit!(100, %);\n             St::Height => unit!(20, px);\n             St::Bottom => 0;\n             St::BackgroundColor => \"darkgray\";\n             St::Position => \"absolute\";\n         }],\n         view_car(&model.car)\n     ]\n }\n \n fn view_car(car: &Car) -> Node<Msg> {\n     div![\n         // car container\n         style! {\n             St::Width => unit!(car.width, px);\n             St::Height => unit!(car.height, px);\n             St::Top => unit!(car.y, px);\n             St::Left => unit!(car.x, px);\n             St::Position => \"absolute\";\n         },\n         // windows\n         div![style! {\n             St::BackgroundColor => \"rgb(255, 255, 255, 0.5)\";\n             St::Left => unit!(car.width * 0.25, px);\n             St::Width => unit!(car.width * 0.5, px);\n             St::Height => unit!(car.height * 0.6, px);\n             St::BorderRadius => unit!(9999, px);\n             St::Position => \"absolute\";\n         }],\n         // body\n         div![style! {\n             St::Top => unit!(car.height * 0.35, px);\n             St::BackgroundColor => car.color;\n             St::Width => unit!(car.width, px);\n             St::Height => unit!(car.height * 0.5, px);\n             St::BorderRadius => unit!(9999, px);\n             St::Position => \"absolute\";\n         }],\n         view_wheel(car.width * 0.15, car),\n         view_wheel(car.width * 0.6, car)\n     ]\n }\n \n fn view_wheel(wheel_x: f64, car: &Car) -> Node<Msg> {\n     let wheel_radius = car.height * 0.4;\n     div![style! {\n         St::Top => unit!(car.height * 0.55, px);\n         St::Left => unit!(wheel_x, px);\n         St::BackgroundColor => \"black\";\n         St::Width => unit!(wheel_radius, px);\n         St::Height => unit!(wheel_radius, px);\n         St::BorderRadius => unit!(9999, px);\n         St::Position => \"absolute\";\n     }]\n }\n \n // ------ ------\n //     Start\n // ------ ------\n \n #[wasm_bindgen(start)]\n pub fn render() {\n     App::builder(update, view)\n         .after_mount(after_mount)\n         .window_events(|_| vec![ev(Ev::Resize, |_| Msg::SetViewportWidth)])\n         .build_and_start();\n }\ndiff --git a/examples/app_builder/Cargo.toml b/examples/app_builder/Cargo.toml\ndeleted file mode 100644\nindex 957a8b9..0000000\n--- a/examples/app_builder/Cargo.toml\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-[package]\n-name = \"app_builder\"\n-version = \"0.1.0\"\n-authors = [\"David O'Connor <david.alan.oconnor@gmail.com>\"]\n-edition = \"2018\"\n-\n-[lib]\n-crate-type = [\"cdylib\"]\n-\n-[dependencies]\n-seed = {path = \"../../\"}\n-wasm-bindgen = \"0.2.55\"\n-web-sys = { version = \"^0.3.32\", features = [ \"KeyboardEvent\" ]}\ndiff --git a/examples/app_builder/README.md b/examples/app_builder/README.md\ndeleted file mode 100644\nindex 80ff1d4..0000000\n--- a/examples/app_builder/README.md\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-## AppBuilder example\n-\n-Demonstrates all `AppBuilder`'s methods.\n-\n----\n-\n-```bash\n-cargo make start\n-```\n-\n-Open [127.0.0.1:8000](http://127.0.0.1:8000) in your browser.\ndiff --git a/examples/app_builder/src/lib.rs b/examples/app_builder/src/lib.rs\ndeleted file mode 100644\nindex 6854976..0000000\n--- a/examples/app_builder/src/lib.rs\n+++ /dev/null\n@@ -1,117 +0,0 @@\n-use seed::{prelude::*, *};\n-use web_sys;\n-\n-// ------ ------\n-// Before Mount\n-// ------ ------\n-\n-fn before_mount(_: Url) -> BeforeMount {\n-    BeforeMount::new()\n-        .mount_point(\"main\")\n-        .mount_type(MountType::Takeover)\n-}\n-\n-// ------ ------\n-//     Model\n-// ------ ------\n-\n-struct Model {\n-    clicks: u32,\n-}\n-\n-// ------ ------\n-//  After Mount\n-// ------ ------\n-\n-fn after_mount(_: Url, _: &mut impl Orders<Msg, GMsg>) -> AfterMount<Model> {\n-    let model = Model { clicks: 0 };\n-    AfterMount::new(model).url_handling(UrlHandling::None)\n-}\n-\n-// ------ ------\n-//    Routes\n-// ------ ------\n-\n-fn routes(url: Url) -> Option<Msg> {\n-    Some(Msg::UrlChanged(url))\n-}\n-\n-// ------ ------\n-// Window Events\n-// ------ ------\n-\n-fn window_events(_: &Model) -> Vec<EventHandler<Msg>> {\n-    vec![keyboard_ev(Ev::KeyDown, Msg::KeyPressed)]\n-}\n-\n-// ------ ------\n-//     Sink\n-// ------ ------\n-\n-#[derive(Clone, Copy)]\n-enum GMsg {\n-    SayHello,\n-}\n-\n-fn sink(g_msg: GMsg, _: &mut Model, _: &mut impl Orders<Msg, GMsg>) {\n-    match g_msg {\n-        GMsg::SayHello => log!(\"Hello!\"),\n-    }\n-}\n-\n-// ------ ------\n-//    Update\n-// ------ ------\n-\n-enum Msg {\n-    Clicked,\n-    UrlChanged(Url),\n-    KeyPressed(web_sys::KeyboardEvent),\n-    SayHello,\n-}\n-\n-fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg, GMsg>) {\n-    match msg {\n-        Msg::Clicked => model.clicks += 1,\n-        Msg::UrlChanged(url) => {\n-            log!(url);\n-            orders.skip();\n-        }\n-        Msg::KeyPressed(event) => {\n-            log!(event.key());\n-            orders.skip();\n-        }\n-        Msg::SayHello => {\n-            orders.send_g_msg(GMsg::SayHello);\n-        }\n-    }\n-}\n-\n-// ------ ------\n-//     View\n-// ------ ------\n-\n-fn view(model: &Model) -> impl IntoNodes<Msg> {\n-    vec![\n-        button![\n-            format!(\"Clicked: {}\", model.clicks),\n-            ev(Ev::Click, |_| Msg::Clicked),\n-        ],\n-        button![\"Say hello\", ev(Ev::Click, |_| Msg::SayHello),],\n-    ]\n-}\n-\n-// ------ ------\n-//     Start\n-// ------ ------\n-\n-#[wasm_bindgen(start)]\n-pub fn render() {\n-    App::builder(update, view)\n-        .before_mount(before_mount)\n-        .after_mount(after_mount)\n-        .routes(routes)\n-        .window_events(window_events)\n-        .sink(sink)\n-        .build_and_start();\n-}\ndiff --git a/examples/auth/src/lib.rs b/examples/auth/src/lib.rs\nindex d09b0fb..1b94f03 100644\n--- a/examples/auth/src/lib.rs\n+++ b/examples/auth/src/lib.rs\n@@ -1,236 +1,244 @@\n #![allow(clippy::must_use_candidate)]\n \n use seed::{prelude::*, *};\n use serde::{Deserialize, Serialize};\n \n const LOGIN: &str = \"login\";\n const API_URL: &str = \"https://martinkavik-seed-auth-example.builtwithdark.com/api\";\n+const STORAGE_KEY: &str = \"seed_auth_example\";\n \n // ------ ------\n //     Init\n // ------ ------\n \n fn init(url: Url, orders: &mut impl Orders<Msg>) -> Model {\n     orders.subscribe(Msg::UrlChanged);\n+\n+    let user = LocalStorage::get(STORAGE_KEY).ok();\n     Model {\n-        user: None,\n         email: \"john@example.com\".to_owned(),\n         password: \"1234\".to_owned(),\n         base_url: url.to_base_url(),\n-        page: Page::init(url, None, orders),\n+        page: Page::init(url, user.as_ref(), orders),\n         secret_message: None,\n+        user,\n     }\n }\n \n // ------ ------\n //     Model\n // ------ ------\n \n struct Model {\n-    user: Option<LoggedUser>,\n     email: String,\n     password: String,\n     base_url: Url,\n     page: Page,\n     secret_message: Option<String>,\n+    user: Option<LoggedUser>,\n }\n \n // ------ LoggedUser ------\n \n-#[derive(Deserialize)]\n+#[derive(Serialize, Deserialize)]\n #[allow(dead_code)]\n pub struct LoggedUser {\n     id: usize,\n     email: String,\n     username: String,\n     token: String,\n }\n \n // ------ Page ------\n \n enum Page {\n     Home,\n     Login,\n     NotFound,\n }\n \n impl Page {\n     fn init(mut url: Url, user: Option<&LoggedUser>, orders: &mut impl Orders<Msg>) -> Self {\n         match url.next_path_part() {\n             None => {\n                 if let Some(user) = user {\n-                    let token = user.token.clone();\n-                    orders.perform_cmd(async {\n-                        Msg::TopSecretFetched(\n-                            async {\n-                                Request::new(format!(\"{}/top_secret\", API_URL))\n-                                    .header(Header::bearer(token))\n-                                    .fetch()\n-                                    .await?\n-                                    .check_status()?\n-                                    .text()\n-                                    .await\n-                            }\n-                            .await,\n-                        )\n-                    });\n+                    send_request_to_top_secret(user.token.clone(), orders)\n                 };\n                 Self::Home\n             }\n             Some(LOGIN) => Self::Login,\n             _ => Self::NotFound,\n         }\n     }\n }\n \n+fn send_request_to_top_secret(token: String, orders: &mut impl Orders<Msg>) {\n+    orders.perform_cmd(async {\n+        Msg::TopSecretFetched(\n+            async {\n+                Request::new(format!(\"{}/top_secret\", API_URL))\n+                    .header(Header::bearer(token))\n+                    .fetch()\n+                    .await?\n+                    .check_status()?\n+                    .text()\n+                    .await\n+            }\n+            .await,\n+        )\n+    });\n+}\n+\n // ------ ------\n //     Urls\n // ------ ------\n \n struct_urls!();\n impl<'a> Urls<'a> {\n     pub fn home(self) -> Url {\n         self.base_url()\n     }\n     pub fn login(self) -> Url {\n         self.base_url().add_path_part(LOGIN)\n     }\n }\n \n // ------ ------\n //    Update\n // ------ ------\n \n enum Msg {\n     UrlChanged(subs::UrlChanged),\n     EmailChanged(String),\n     PasswordChanged(String),\n     LoginClicked,\n     LoginFetched(fetch::Result<LoggedUser>),\n     TopSecretFetched(fetch::Result<String>),\n     LogoutClicked,\n }\n \n fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n     match msg {\n         Msg::UrlChanged(subs::UrlChanged(url)) => {\n             model.page = Page::init(url, model.user.as_ref(), orders);\n         }\n         Msg::EmailChanged(email) => model.email = email,\n         Msg::PasswordChanged(password) => model.password = password,\n         Msg::LoginClicked => {\n             let request = Request::new(format!(\"{}/users/login\", API_URL))\n                 .method(Method::Post)\n                 .json(&LoginRequestBody {\n                     email: &model.email,\n                     password: &model.password,\n                 });\n             orders.perform_cmd(async {\n                 Msg::LoginFetched(\n                     async { request?.fetch().await?.check_status()?.json().await }.await,\n                 )\n             });\n         }\n         Msg::LoginFetched(Ok(logged_user)) => {\n+            LocalStorage::insert(STORAGE_KEY, &logged_user).expect(\"save user\");\n             model.user = Some(logged_user);\n             orders.notify(subs::UrlRequested::new(Urls::new(&model.base_url).home()));\n         }\n         Msg::TopSecretFetched(Ok(secret_message)) => {\n             model.secret_message = Some(secret_message);\n         }\n         Msg::LoginFetched(Err(error)) | Msg::TopSecretFetched(Err(error)) => log!(error),\n         Msg::LogoutClicked => {\n+            LocalStorage::remove(STORAGE_KEY).expect(\"remove saved user\");\n             model.user = None;\n             model.secret_message = None;\n         }\n     }\n }\n \n #[derive(Serialize)]\n struct LoginRequestBody<'a> {\n     email: &'a str,\n     password: &'a str,\n }\n \n // ------ ------\n //     View\n // ------ ------\n \n fn view(model: &Model) -> impl IntoNodes<Msg> {\n     vec![\n         header(&model.base_url, model.user.as_ref()),\n         match &model.page {\n             Page::Home => div![\n                 format!(\n                     \"Welcome home {}!\",\n                     model\n                         .user\n                         .as_ref()\n                         .map(|user| user.username.to_owned())\n                         .unwrap_or_default()\n                 ),\n                 div![&model.secret_message],\n             ],\n             Page::Login => form![\n                 style! {\n                     St::Display => \"flex\",\n                     St::FlexDirection => \"column\",\n                 },\n                 label![\"Email\"],\n                 input![\n                     attrs! {\n                         At::Value => model.email\n                     },\n                     input_ev(Ev::Input, Msg::EmailChanged)\n                 ],\n                 label![\"Password\"],\n                 input![\n                     attrs! {\n                         At::Value => model.password,\n                         At::Type => \"password\",\n                     },\n                     input_ev(Ev::Input, Msg::PasswordChanged)\n                 ],\n                 button![\n                     \"Login\",\n                     ev(Ev::Click, |event| {\n                         event.prevent_default();\n                         Msg::LoginClicked\n                     })\n                 ],\n                 \"Note: Errors are logged into the console log.\",\n             ],\n             Page::NotFound => div![\"404\"],\n         },\n     ]\n }\n \n fn header(base_url: &Url, user: Option<&LoggedUser>) -> Node<Msg> {\n     ul![\n         li![a![\n             attrs! { At::Href => Urls::new(base_url).home() },\n             \"Home\",\n         ]],\n         if user.is_none() {\n             li![a![\n                 attrs! { At::Href => Urls::new(base_url).login() },\n                 \"Login\",\n             ]]\n         } else {\n             li![a![\n                 attrs! { At::Href => \"\" },\n                 \"Logout\",\n                 ev(Ev::Click, |_| Msg::LogoutClicked),\n             ]]\n         }\n     ]\n }\n \n // ------ ------\n //     Start\n // ------ ------\n \n #[wasm_bindgen(start)]\n pub fn start() {\n     App::start(\"app\", init, update, view);\n }\ndiff --git a/examples/bunnies/Cargo.toml b/examples/bunnies/Cargo.toml\nnew file mode 100644\nindex 0000000..df198be\n--- /dev/null\n+++ b/examples/bunnies/Cargo.toml\n@@ -0,0 +1,15 @@\n+[package]\n+name = \"bunnies\"\n+version = \"0.1.0\"\n+authors = [\"Martin Kav\u00edk <martin@kavik.cz>\"]\n+edition = \"2018\"\n+\n+[lib]\n+crate-type = [\"cdylib\"]\n+\n+[dependencies]\n+seed = {path = \"../../\"}\n+rand = { version = \"0.7.3\", features = [\"wasm-bindgen\", \"small_rng\"] }\n+nalgebra = \"0.21.0\"\n+awsm_web = { version = \"0.1.9\", features = [\"tick\", \"webgl\", \"loaders\", \"audio\"], default-features = false }\n+shipyard = { version = \"0.4.0\", features = [\"non_send\", \"non_sync\"], default-features = false }\ndiff --git a/examples/app_builder/Makefile.toml b/examples/bunnies/Makefile.toml\nsimilarity index 100%\nrename from examples/app_builder/Makefile.toml\nrename to examples/bunnies/Makefile.toml\ndiff --git a/examples/bunnies/README.md b/examples/bunnies/README.md\nnew file mode 100644\nindex 0000000..7dac09e\n--- /dev/null\n+++ b/examples/bunnies/README.md\n@@ -0,0 +1,13 @@\n+## Bunnies example\n+\n+Intended as a demo of [Shipyard](https://github.com/leudz/shipyard) (Entity Component System) integration.\n+\n+_Note:_: Ported from [Shipyard demo](https://github.com/leudz/shipyard/tree/23f2998296f690aee78972f9cfe06dfd73b7971c/demo).\n+\n+---\n+\n+```bash\n+cargo make start\n+```\n+\n+Open [127.0.0.1:8000](http://127.0.0.1:8000) in your browser.\ndiff --git a/examples/app_builder/index.html b/examples/bunnies/index.html\nsimilarity index 83%\nrename from examples/app_builder/index.html\nrename to examples/bunnies/index.html\nindex afe474c..fd7356d 100644\n--- a/examples/app_builder/index.html\n+++ b/examples/bunnies/index.html\n@@ -1,29 +1,29 @@\n <!DOCTYPE html>\n <html lang=\"en\">\n   <head>\n     <meta charset=\"utf-8\" />\n     <meta\n       name=\"viewport\"\n       content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n     />\n \n     <meta name=\"description\" content=\"\" />\n \n     <link rel=\"icon\" type=\"image/png\" href=\"/public/favicon.png\" />\n \n-    <!--<link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">-->\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"/public/style.css\">\n \n-    <title>AppBuilder example</title>\n+    <title>Bunnies example</title>\n \n     <!-- Because of Edge, see https://github.com/samthor/fast-text-encoding -->\n     <script type=\"text/javascript\" src=\"/public/text-polyfill.min.js\"></script>\n   </head>\n   <body>\n-    <section id=\"main\"></section>\n+    <section id=\"app\"></section>\n     <script type=\"module\">\n       // https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html\n       import init from '/pkg/package.js';\n       init('/pkg/package_bg.wasm');\n     </script>\n   </body>\n </html>\ndiff --git a/examples/bunnies/public/media/bunny.png b/examples/bunnies/public/media/bunny.png\nnew file mode 100644\nindex 0000000..087972b\nBinary files /dev/null and b/examples/bunnies/public/media/bunny.png differ\ndiff --git a/examples/bunnies/public/media/fragment.glsl b/examples/bunnies/public/media/fragment.glsl\nnew file mode 100644\nindex 0000000..9ee21ad\n--- /dev/null\n+++ b/examples/bunnies/public/media/fragment.glsl\n@@ -0,0 +1,8 @@\n+precision mediump float;\n+\n+uniform sampler2D u_sampler;\n+varying vec2 v_uv;\n+\n+void main() {\n+    gl_FragColor = texture2D(u_sampler, v_uv); \n+}\ndiff --git a/examples/bunnies/public/media/vertex.glsl b/examples/bunnies/public/media/vertex.glsl\nnew file mode 100644\nindex 0000000..adf6445\n--- /dev/null\n+++ b/examples/bunnies/public/media/vertex.glsl\n@@ -0,0 +1,21 @@\n+precision mediump float;\n+\n+attribute vec2 a_vertex;\n+attribute vec2 a_position;\n+\n+varying vec2 v_uv;\n+\n+uniform mat4 u_size;\n+uniform mat4 u_camera;\n+\n+void main() {\n+    mat4 transform = mat4(1.0);\n+\n+    //https://www.geeks3d.com/20141114/glsl-4x4-matrix-mat4-fields/\n+    transform[3] = vec4(a_position, 0.0, 1.0);\n+\n+    mat4 modelViewProjection = u_camera * transform; \n+\n+    gl_Position = modelViewProjection * (u_size * vec4(a_vertex,0,1));\n+    v_uv = a_vertex;\n+}\ndiff --git a/examples/bunnies/public/style.css b/examples/bunnies/public/style.css\nnew file mode 100644\nindex 0000000..cd0ef2a\n--- /dev/null\n+++ b/examples/bunnies/public/style.css\n@@ -0,0 +1,45 @@\n+/* Global */\n+html {\n+  box-sizing: border-box;\n+}\n+*, *:before, *:after {\n+  box-sizing: inherit;\n+}\n+\n+html,body {\n+\tpadding: 0;\n+\tmargin: 0;\n+\tfont-family: Arial, Helvetica, sans-serif;\n+}\n+\n+canvas {\n+    position: absolute;\n+    top: 0;\n+    left: 0;\n+    padding: 0;\n+    margin: 0;\n+}\n+\n+/* loading */\n+.loading {\n+    font-size: xx-large;\n+    width: 100%;\n+    text-align: center;\n+    position: absolute;\n+    top: 30vh;\n+    left: 0;\n+}\n+/* info */\n+.info {\n+    position: absolute;\n+    top: 0;\n+    left: 0;\n+    display: inline-block;\n+\n+    background-color: rgb(42, 22, 191);\n+    color: white;\n+}\n+\n+.info > * {\n+    margin: 10px;\n+}\n\\ No newline at end of file\ndiff --git a/examples/app_builder/public/text-polyfill.min.js b/examples/bunnies/public/text-polyfill.min.js\nsimilarity index 100%\nrename from examples/app_builder/public/text-polyfill.min.js\nrename to examples/bunnies/public/text-polyfill.min.js\ndiff --git a/examples/bunnies/src/components.rs b/examples/bunnies/src/components.rs\nnew file mode 100644\nindex 0000000..f31980f\n--- /dev/null\n+++ b/examples/bunnies/src/components.rs\n@@ -0,0 +1,21 @@\n+use crate::geometry::*;\n+//re-exported so its easier to just use components::*\n+pub use crate::fps_counter::FpsCounter;\n+pub use crate::hud::Hud;\n+pub use crate::scene_renderer::SceneRenderer;\n+\n+pub struct ImageArea(pub Area);\n+pub struct StageArea(pub Area);\n+pub struct InstancePositions(pub Vec<f32>);\n+pub struct Fps(pub u32);\n+pub struct Timestamp(pub f64);\n+#[derive(PartialEq)]\n+pub enum Controller {\n+    Adding,\n+    Waiting,\n+}\n+\n+//the bunnies\n+pub struct Position(pub Point);\n+pub struct Speed(pub Point);\n+pub struct Gravity(pub f64);\ndiff --git a/examples/bunnies/src/config.rs b/examples/bunnies/src/config.rs\nnew file mode 100644\nindex 0000000..0821aec\n--- /dev/null\n+++ b/examples/bunnies/src/config.rs\n@@ -0,0 +1,6 @@\n+pub const N_BUNNIES_PER_TICK: usize = 100;\n+pub const START_GRAVITY: f64 = 0.75;\n+\n+pub fn get_media_href(path: &str) -> String {\n+    format!(\"/public/media/{}\", path)\n+}\ndiff --git a/examples/bunnies/src/fps_counter.rs b/examples/bunnies/src/fps_counter.rs\nnew file mode 100644\nindex 0000000..a8487c6\n--- /dev/null\n+++ b/examples/bunnies/src/fps_counter.rs\n@@ -0,0 +1,39 @@\n+use seed::window;\n+\n+pub struct FpsCounter {\n+    begin_time: f64,\n+    prev_time: f64,\n+    frames: usize,\n+    pub current: f64,\n+}\n+\n+impl FpsCounter {\n+    pub fn new() -> Self {\n+        let begin_time = Self::now();\n+        Self {\n+            begin_time,\n+            prev_time: begin_time,\n+            frames: 0,\n+            current: 0.0,\n+        }\n+    }\n+\n+    pub fn now() -> f64 {\n+        window().performance().unwrap().now()\n+    }\n+\n+    pub fn begin(&mut self) {\n+        self.begin_time = Self::now();\n+    }\n+\n+    pub fn end(&mut self) {\n+        self.frames += 1;\n+        let time = Self::now();\n+\n+        if time >= (self.prev_time + 1000.0) {\n+            self.current = ((self.frames * 1000) as f64) / (time - self.prev_time);\n+            self.prev_time = time;\n+            self.frames = 0;\n+        }\n+    }\n+}\ndiff --git a/examples/bunnies/src/geometry.rs b/examples/bunnies/src/geometry.rs\nnew file mode 100644\nindex 0000000..d3ff56f\n--- /dev/null\n+++ b/examples/bunnies/src/geometry.rs\n@@ -0,0 +1,30 @@\n+use rand::{rngs::SmallRng, Rng, SeedableRng};\n+\n+#[derive(Debug, Clone)]\n+pub struct Point {\n+    pub x: f64,\n+    pub y: f64,\n+}\n+\n+impl Point {\n+    pub fn new_random() -> Self {\n+        let mut rng = SmallRng::from_entropy();\n+        let x: f64 = rng.gen(); // random number in range [0, 1)\n+        let y: f64 = rng.gen(); // random number in range [0, 1)\n+\n+        Self { x, y }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Area {\n+    pub width: u32,\n+    pub height: u32,\n+}\n+\n+pub const QUAD_GEOM_UNIT: [f32; 8] = [\n+    0.0, 1.0, // top-left\n+    0.0, 0.0, //bottom-left\n+    1.0, 1.0, // top-right\n+    1.0, 0.0, // bottom-right\n+];\ndiff --git a/examples/bunnies/src/hud.rs b/examples/bunnies/src/hud.rs\nnew file mode 100644\nindex 0000000..ef0c84e\n--- /dev/null\n+++ b/examples/bunnies/src/hud.rs\n@@ -0,0 +1,20 @@\n+#[derive(Default, Debug)]\n+pub struct Hud {\n+    num_bunnies: usize,\n+    fps: u32,\n+}\n+\n+impl Hud {\n+    pub fn update(&mut self, len: usize, fps: u32) {\n+        self.num_bunnies = len;\n+        self.fps = fps;\n+    }\n+\n+    pub fn num_bunnies(&self) -> usize {\n+        self.num_bunnies\n+    }\n+\n+    pub fn fps(&self) -> u32 {\n+        self.fps\n+    }\n+}\ndiff --git a/examples/bunnies/src/init_world.rs b/examples/bunnies/src/init_world.rs\nnew file mode 100644\nindex 0000000..41315c1\n--- /dev/null\n+++ b/examples/bunnies/src/init_world.rs\n@@ -0,0 +1,25 @@\n+use crate::components::*;\n+use crate::geometry::*;\n+use crate::hud::Hud;\n+use crate::scene_renderer::SceneRenderer;\n+use shipyard::*;\n+\n+pub fn init_world(img_area: Area, stage_area: Area, hud: Hud, renderer: SceneRenderer) -> World {\n+    let world = World::default();\n+\n+    world.add_unique(ImageArea(img_area));\n+    world.add_unique(StageArea(stage_area));\n+    world.add_unique(InstancePositions(Vec::new()));\n+    world.add_unique(Fps(0));\n+    world.add_unique(Controller::Waiting);\n+    world.add_unique(FpsCounter::new());\n+    world.add_unique(Timestamp(0.0));\n+    world.add_unique_non_send_sync(renderer);\n+    world.add_unique_non_send_sync(hud);\n+\n+    world\n+        .borrow::<(ViewMut<Position>, ViewMut<Speed>, ViewMut<Gravity>)>()\n+        .tight_pack();\n+\n+    world\n+}\ndiff --git a/examples/bunnies/src/lib.rs b/examples/bunnies/src/lib.rs\nnew file mode 100644\nindex 0000000..cdce682\n--- /dev/null\n+++ b/examples/bunnies/src/lib.rs\n@@ -0,0 +1,255 @@\n+// [Original code](https://github.com/leudz/shipyard/tree/23f2998296f690aee78972f9cfe06dfd73b7971c/demo)\n+// triggers many Clippy lints:\n+#![allow(\n+    clippy::cast_precision_loss,\n+    clippy::default_trait_access,\n+    clippy::cast_sign_loss,\n+    clippy::cast_possible_truncation,\n+    clippy::needless_pass_by_value,\n+    clippy::cast_lossless,\n+    clippy::too_many_arguments,\n+    clippy::needless_borrow,\n+    clippy::missing_const_for_fn\n+)]\n+\n+use awsm_web::errors::Error;\n+use awsm_web::loaders;\n+use awsm_web::webgl::{\n+    get_texture_size, get_webgl_context_1, ResizeStrategy, WebGl1Renderer, WebGlContextOptions,\n+    WebGlTextureSource,\n+};\n+use awsm_web::window::get_window_size;\n+use seed::web_sys::{HtmlCanvasElement, HtmlImageElement};\n+use seed::{prelude::*, *};\n+use shipyard::{NonSendSync, UniqueView, UniqueViewMut, World};\n+\n+mod components;\n+mod config;\n+mod fps_counter;\n+mod geometry;\n+mod hud;\n+mod init_world;\n+mod scene_renderer;\n+mod systems;\n+\n+use components::{Controller, StageArea, Timestamp};\n+use config::get_media_href;\n+use geometry::Area;\n+use hud::Hud;\n+use init_world::init_world;\n+use scene_renderer::SceneRenderer;\n+use systems::TICK;\n+\n+// ------ ------\n+//     Init\n+// ------ ------\n+\n+fn init(_: Url, orders: &mut impl Orders<Msg>) -> Model {\n+    orders\n+        .stream(streams::window_event(Ev::Resize, |_| Msg::OnResize))\n+        .perform_cmd(async {\n+            Msg::ResourcesLoaded(\n+                async {\n+                    Ok(Resources {\n+                        img: loaders::fetch::image(&get_media_href(\"bunny.png\")).await?,\n+                        vertex: loaders::fetch::text(&get_media_href(\"vertex.glsl\")).await?,\n+                        fragment: loaders::fetch::text(&get_media_href(\"fragment.glsl\")).await?,\n+                    })\n+                }\n+                .await,\n+            )\n+        });\n+\n+    let (stage_width, stage_height) = get_window_size(&window()).unwrap();\n+\n+    Model {\n+        resources: None,\n+        canvas: ElRef::default(),\n+        stage_width,\n+        stage_height,\n+        world: None,\n+        num_bunnies: 0,\n+        fps: 0,\n+    }\n+}\n+\n+// ------ ------\n+//     Model\n+// ------ ------\n+\n+struct Model {\n+    resources: Option<Resources>,\n+    canvas: ElRef<HtmlCanvasElement>,\n+    stage_width: u32,\n+    stage_height: u32,\n+    world: Option<World>,\n+    num_bunnies: usize,\n+    fps: u32,\n+}\n+\n+struct Resources {\n+    img: HtmlImageElement,\n+    vertex: String,\n+    fragment: String,\n+}\n+\n+// ------ ------\n+//    Update\n+// ------ ------\n+\n+enum Msg {\n+    ResourcesLoaded(Result<Resources, Error>),\n+    CanvasReady,\n+    OnResize,\n+    OnTick(RenderInfo),\n+    PointerDown,\n+    PointerUp,\n+}\n+\n+fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n+    match msg {\n+        Msg::ResourcesLoaded(Ok(resources)) => {\n+            log!(\"resources loaded\");\n+            model.resources = Some(resources);\n+            orders.after_next_render(|_| Msg::CanvasReady);\n+        }\n+        Msg::ResourcesLoaded(Err(error)) => {\n+            log!(\"resources loading failed:\", error);\n+        }\n+        Msg::CanvasReady => {\n+            log!(\"canvas ready\");\n+            model.world = Some(create_world(model));\n+            log!(\"world created\");\n+            log!(\"starting game loop...\");\n+            orders.after_next_render(Msg::OnTick);\n+        }\n+        Msg::OnResize => {\n+            let (stage_width, stage_height) = get_window_size(&window()).unwrap();\n+            model.stage_width = stage_width;\n+            model.stage_height = stage_height;\n+\n+            if let Some(world) = &model.world {\n+                world\n+                    .borrow::<NonSendSync<UniqueViewMut<SceneRenderer>>>()\n+                    .renderer\n+                    .resize(ResizeStrategy::All(stage_width, stage_height));\n+                let mut stage_area = world.borrow::<UniqueViewMut<StageArea>>();\n+                stage_area.0.width = stage_width;\n+                stage_area.0.height = stage_height;\n+            }\n+        }\n+        Msg::OnTick(render_info) => {\n+            if let Some(world) = &model.world {\n+                world.borrow::<UniqueViewMut<Timestamp>>().0 = render_info.timestamp;\n+                world.run_workload(TICK);\n+                let hud = world.borrow::<UniqueView<Hud>>();\n+                model.fps = hud.fps();\n+                model.num_bunnies = hud.num_bunnies();\n+            }\n+            orders.after_next_render(Msg::OnTick);\n+        }\n+        Msg::PointerDown => {\n+            if let Some(world) = &model.world {\n+                *world.borrow::<UniqueViewMut<Controller>>() = Controller::Adding;\n+            }\n+        }\n+        Msg::PointerUp => {\n+            if let Some(world) = &model.world {\n+                *world.borrow::<UniqueViewMut<Controller>>() = Controller::Waiting;\n+            }\n+        }\n+    }\n+}\n+\n+fn create_world(model: &mut Model) -> World {\n+    let res = model\n+        .resources\n+        .as_ref()\n+        .expect(\"get resources to start world\");\n+    let canvas = model.canvas.get().expect(\"get canvas element\");\n+\n+    let (img_width, img_height, _) = get_texture_size(&WebGlTextureSource::ImageElement(&res.img));\n+\n+    let gl = get_webgl_context_1(\n+        &canvas,\n+        Some(&WebGlContextOptions {\n+            alpha: false,\n+            ..Default::default()\n+        }),\n+    )\n+    .expect(\"get_webgl_context_1\");\n+\n+    let renderer = WebGl1Renderer::new(gl).expect(\"create renderer\");\n+\n+    let scene_renderer = SceneRenderer::new(renderer, &res.vertex, &res.fragment, &res.img)\n+        .expect(\"create scene renderer\");\n+\n+    let world = init_world(\n+        Area {\n+            width: img_width,\n+            height: img_height,\n+        },\n+        Area {\n+            width: model.stage_width,\n+            height: model.stage_height,\n+        },\n+        Hud::default(),\n+        scene_renderer,\n+    );\n+\n+    systems::register_workloads(&world);\n+\n+    world\n+}\n+\n+// ------ ------\n+//     View\n+// ------ ------\n+\n+fn view(model: &Model) -> Vec<Node<Msg>> {\n+    if model.resources.is_none() {\n+        vec![view_loading()]\n+    } else {\n+        vec![\n+            view_canvas(&model.canvas, model.stage_width, model.stage_height),\n+            view_hud(model.num_bunnies, model.fps),\n+        ]\n+    }\n+}\n+\n+fn view_loading() -> Node<Msg> {\n+    div![C![\"loading\"], \"Loading...\"]\n+}\n+\n+fn view_canvas(\n+    canvas: &ElRef<HtmlCanvasElement>,\n+    stage_width: u32,\n+    stage_height: u32,\n+) -> Node<Msg> {\n+    canvas![\n+        el_ref(canvas),\n+        attrs! {\n+            At::Width => stage_width,\n+            At::Height => stage_height,\n+        },\n+        ev(Ev::PointerDown, |_| Msg::PointerDown),\n+        ev(Ev::PointerUp, |_| Msg::PointerUp),\n+    ]\n+}\n+\n+fn view_hud(num_bunnies: usize, fps: u32) -> Node<Msg> {\n+    div![\n+        C![\"info\"],\n+        div![C![\"info-num__bunnies\"], \"bunnies: \", num_bunnies,],\n+        div![C![\"info-fps\"], \"fps: \", fps,],\n+    ]\n+}\n+\n+// ------ ------\n+//     Start\n+// ------ ------\n+\n+#[wasm_bindgen(start)]\n+pub fn start() {\n+    App::start(\"app\", init, update, view);\n+}\ndiff --git a/examples/bunnies/src/scene_renderer.rs b/examples/bunnies/src/scene_renderer.rs\nnew file mode 100644\nindex 0000000..69ff4d3\n--- /dev/null\n+++ b/examples/bunnies/src/scene_renderer.rs\n@@ -0,0 +1,152 @@\n+use crate::geometry::*;\n+use nalgebra::{Matrix4, Vector3};\n+use seed::web_sys::HtmlImageElement;\n+\n+use awsm_web::webgl::{\n+    AttributeOptions, BeginMode, BlendFactor, BufferData, BufferMask, BufferTarget, BufferUsage,\n+    DataType, GlToggle, Id, PixelFormat, SimpleTextureOptions, TextureTarget, WebGl1Renderer,\n+    WebGlTextureSource,\n+};\n+\n+struct SceneIds {\n+    program_id: Id,\n+    texture_id: Id,\n+    instance_id: Id,\n+}\n+\n+pub struct SceneRenderer {\n+    pub renderer: WebGl1Renderer,\n+    ids: SceneIds,\n+}\n+\n+impl SceneRenderer {\n+    pub fn new(\n+        mut renderer: WebGl1Renderer,\n+        vertex: &str,\n+        fragment: &str,\n+        img: &HtmlImageElement,\n+    ) -> Result<Self, awsm_web::errors::Error> {\n+        let ids = {\n+            //This demo is specifically using webgl1, which needs to register the extension\n+            //Everything else is the same API as webgl2 :)\n+            renderer.register_extension_instanced_arrays()?;\n+\n+            //compile the shaders and get a program id\n+            let program_id = renderer.compile_program(vertex, fragment)?;\n+\n+            //create quad data and get a buffer id\n+            let geom_id = renderer.create_buffer()?;\n+\n+            renderer.upload_buffer_to_attribute(\n+                geom_id,\n+                BufferData::new(\n+                    &QUAD_GEOM_UNIT,\n+                    BufferTarget::ArrayBuffer,\n+                    BufferUsage::StaticDraw,\n+                ),\n+                \"a_vertex\",\n+                &AttributeOptions::new(2, DataType::Float),\n+            )?;\n+\n+            //create texture data and get a texture id\n+            let texture_id = renderer.create_texture()?;\n+            renderer.assign_simple_texture(\n+                texture_id,\n+                TextureTarget::Texture2d,\n+                &SimpleTextureOptions {\n+                    pixel_format: PixelFormat::Rgba,\n+                    ..SimpleTextureOptions::default()\n+                },\n+                &WebGlTextureSource::ImageElement(&img),\n+            )?;\n+\n+            //create an instance buffer and get the id\n+            let instance_id = renderer.create_buffer()?;\n+\n+            SceneIds {\n+                program_id,\n+                texture_id,\n+                instance_id,\n+            }\n+        };\n+\n+        renderer.gl.clear_color(0.3, 0.3, 0.3, 1.0);\n+\n+        Ok(Self { renderer, ids })\n+    }\n+\n+    pub fn clear(&mut self) {\n+        self.renderer\n+            .clear(&[BufferMask::ColorBufferBit, BufferMask::DepthBufferBit]);\n+    }\n+    pub fn render(\n+        &mut self,\n+        len: usize,\n+        img_area: &Area,\n+        stage_area: &Area,\n+        instance_positions: &[f32],\n+    ) -> Result<(), awsm_web::errors::Error> {\n+        self.clear();\n+\n+        if len == 0 {\n+            return Ok(());\n+        }\n+\n+        let renderer = &mut self.renderer;\n+        let SceneIds {\n+            program_id,\n+            texture_id,\n+            instance_id,\n+            ..\n+        } = self.ids;\n+\n+        //set blend mode. this will be a noop internally if already set\n+        renderer.toggle(GlToggle::Blend, true);\n+        renderer.toggle(GlToggle::DepthTest, false);\n+        renderer.set_blend_func(BlendFactor::SrcAlpha, BlendFactor::OneMinusSrcAlpha);\n+\n+        //will already be activated but internally that's a noop if true\n+        renderer.activate_program(program_id)?;\n+\n+        //enable texture\n+        renderer.activate_texture_for_sampler(texture_id, \"u_sampler\")?;\n+\n+        //Build our matrices (must cast to f32)\n+        let scaling_mat = Matrix4::new_nonuniform_scaling(&Vector3::new(\n+            img_area.width as f32,\n+            img_area.height as f32,\n+            0.0,\n+        ));\n+        let camera_mat = Matrix4::new_orthographic(\n+            0.0,\n+            stage_area.width as f32,\n+            0.0,\n+            stage_area.height as f32,\n+            0.0,\n+            1.0,\n+        );\n+\n+        //Upload them to the GPU\n+        renderer.upload_uniform_mat_4(\"u_size\", &scaling_mat.as_slice())?;\n+        renderer.upload_uniform_mat_4(\"u_camera\", &camera_mat.as_slice())?;\n+\n+        //need the location for the attrib_divisor below\n+        let loc = renderer.get_attribute_location_value(\"a_position\")?;\n+        //upload instance positions\n+        renderer.upload_buffer(\n+            instance_id,\n+            BufferData::new(\n+                &instance_positions,\n+                BufferTarget::ArrayBuffer,\n+                BufferUsage::StaticDraw,\n+            ),\n+        )?;\n+\n+        renderer.activate_attribute_loc(loc, &AttributeOptions::new(2, DataType::Float));\n+\n+        renderer.vertex_attrib_divisor(loc, 1)?;\n+        renderer.draw_arrays_instanced(BeginMode::TriangleStrip, 0, 4, len as u32)?;\n+\n+        Ok(())\n+    }\n+}\ndiff --git a/examples/bunnies/src/systems.rs b/examples/bunnies/src/systems.rs\nnew file mode 100644\nindex 0000000..83d5f4a\n--- /dev/null\n+++ b/examples/bunnies/src/systems.rs\n@@ -0,0 +1,156 @@\n+use crate::components::*;\n+use crate::config::*;\n+use crate::geometry::*;\n+use rand::prelude::*;\n+use shipyard::*;\n+\n+pub const TICK: &str = \"TICK\";\n+\n+pub fn register_workloads(world: &World) {\n+    world\n+        .add_workload(TICK)\n+        .with_system(system!(start))\n+        .with_system(system!(handle_controller))\n+        .with_system(system!(update))\n+        .with_system(system!(commit))\n+        .with_system(system!(render))\n+        .with_system(system!(end))\n+        .build();\n+}\n+\n+pub fn start(mut fps_counter: UniqueViewMut<FpsCounter>) {\n+    fps_counter.begin();\n+}\n+\n+pub fn handle_controller(\n+    mut entities: EntitiesViewMut,\n+    controller: UniqueView<Controller>,\n+    mut positions: ViewMut<Position>,\n+    mut speeds: ViewMut<Speed>,\n+    mut gravities: ViewMut<Gravity>,\n+    stage_area: UniqueView<StageArea>,\n+    img_area: UniqueView<ImageArea>,\n+    mut instance_positions: UniqueViewMut<InstancePositions>,\n+) {\n+    if *controller == Controller::Adding {\n+        let count = positions.len();\n+        let len = count + N_BUNNIES_PER_TICK;\n+        let stage_size = &stage_area.0;\n+        let img_size = &img_area.0;\n+\n+        positions.reserve(N_BUNNIES_PER_TICK);\n+        speeds.reserve(N_BUNNIES_PER_TICK);\n+        gravities.reserve(N_BUNNIES_PER_TICK);\n+\n+        for count in 0..N_BUNNIES_PER_TICK {\n+            //alternate between corners\n+            let pos_x = match count % 2 {\n+                0 => 0.0_f64,\n+                _ => (stage_size.width - img_size.width) as f64,\n+            };\n+\n+            let pos_y = (stage_size.height - img_size.height) as f64;\n+            let position = Point { x: pos_x, y: pos_y };\n+\n+            let mut speed = Point::new_random();\n+\n+            speed.x *= 10.0;\n+            speed.y = (speed.y * 10.0) - 5.0;\n+\n+            entities.add_entity(\n+                (&mut positions, &mut speeds, &mut gravities),\n+                (Position(position), Speed(speed), Gravity(START_GRAVITY)),\n+            );\n+        }\n+\n+        instance_positions.0.resize(len * 2, 0.0);\n+    }\n+}\n+\n+pub fn update(\n+    mut positions: ViewMut<Position>,\n+    mut speeds: ViewMut<Speed>,\n+    mut gravities: ViewMut<Gravity>,\n+    stage_area: UniqueView<StageArea>,\n+    img_area: UniqueView<ImageArea>,\n+) {\n+    let stage_size = &stage_area.0;\n+    let img_size = &img_area.0;\n+\n+    (&mut positions, &mut speeds, &mut gravities)\n+        .iter()\n+        .for_each(|(pos, speed, gravity)| {\n+            let mut pos = &mut pos.0;\n+            let mut speed = &mut speed.0;\n+            let gravity = &gravity.0;\n+\n+            //movement is made to match https://github.com/pixijs/bunny-mark/blob/master/src/Bunny.js\n+            pos.x += speed.x;\n+            pos.y -= speed.y;\n+\n+            speed.y += *gravity;\n+\n+            let bounds_right = (stage_size.width - img_size.width) as f64;\n+            if pos.x > bounds_right {\n+                speed.x *= -1.0;\n+                pos.x = bounds_right;\n+            } else if pos.x < 0.0 {\n+                speed.x *= -1.0;\n+                pos.x = 0.0\n+            }\n+\n+            let bounds_top = (stage_size.height - img_size.height) as f64;\n+\n+            if pos.y < 0.0 {\n+                speed.y *= -0.85;\n+                pos.y = 0.0;\n+                let rand_bool: bool = thread_rng().gen();\n+                if rand_bool {\n+                    let rand_float: f64 = thread_rng().gen();\n+                    speed.y -= rand_float * 6.0;\n+                }\n+            } else if pos.y > bounds_top {\n+                speed.y = 0.0;\n+                pos.y = bounds_top;\n+            }\n+        });\n+}\n+\n+pub fn commit(positions: View<Position>, mut instance_positions: UniqueViewMut<InstancePositions>) {\n+    let instance_positions = &mut instance_positions.0[..];\n+\n+    (&positions).iter().enumerate().for_each(|(index, pos)| {\n+        //Set the instance data from bunny positions\n+        let instance_idx = index * 2;\n+        instance_positions[instance_idx] = pos.0.x as f32;\n+        instance_positions[instance_idx + 1] = pos.0.y as f32;\n+    });\n+}\n+\n+pub fn render(\n+    mut renderer: NonSendSync<UniqueViewMut<SceneRenderer>>,\n+    positions: View<Position>,\n+    stage_area: UniqueView<StageArea>,\n+    img_area: UniqueView<ImageArea>,\n+    instance_positions: UniqueView<InstancePositions>,\n+) {\n+    renderer\n+        .render(\n+            positions.len(),\n+            &img_area.0,\n+            &stage_area.0,\n+            &instance_positions.0,\n+        )\n+        .unwrap();\n+}\n+\n+pub fn end(\n+    mut fps_counter: UniqueViewMut<FpsCounter>,\n+    mut hud: NonSendSync<UniqueViewMut<Hud>>,\n+    positions: View<Position>,\n+) {\n+    fps_counter.end();\n+    let fps = fps_counter.current.ceil() as u32;\n+    let len = positions.len();\n+    hud.update(len, fps);\n+}\ndiff --git a/examples/el_key/Cargo.toml b/examples/el_key/Cargo.toml\nnew file mode 100644\nindex 0000000..285f414\n--- /dev/null\n+++ b/examples/el_key/Cargo.toml\n@@ -0,0 +1,16 @@\n+[package]\n+name = \"el_key\"\n+version = \"0.1.0\"\n+authors = [\"Ildar Akhmetgaleev <akhilman@gmail.com>\"]\n+edition = \"2018\"\n+\n+[lib]\n+crate-type = [\"cdylib\"]\n+\n+[dependencies]\n+seed = { path = \"../../\" }\n+wasm-bindgen = \"0.2.60\"\n+rand = { version = \"0.7.3\", features = [\"wasm-bindgen\", \"small_rng\"] }\n+scarlet = \"1.1.0\"\n+static_assertions = \"1.1.0\"\n+regex = \"1.3.7\"\ndiff --git a/examples/el_key/Makefile.toml b/examples/el_key/Makefile.toml\nnew file mode 100644\nindex 0000000..527773c\n--- /dev/null\n+++ b/examples/el_key/Makefile.toml\n@@ -0,0 +1,22 @@\n+extend = \"../../Makefile.toml\"\n+\n+# ---- BUILD ----\n+\n+[tasks.build]\n+alias = \"default_build\"\n+\n+[tasks.build_release]\n+alias = \"default_build_release\"\n+\n+# ---- START ----\n+\n+[tasks.start]\n+alias = \"default_start\"\n+\n+[tasks.start_release]\n+alias = \"default_start_release\"\n+\n+# ---- LINT ----\n+\n+[tasks.clippy]\n+alias = \"default_clippy\"\ndiff --git a/examples/el_key/README.md b/examples/el_key/README.md\nnew file mode 100644\nindex 0000000..bb56422\n--- /dev/null\n+++ b/examples/el_key/README.md\n@@ -0,0 +1,141 @@\n+## Element key example\n+\n+This example shows how to control a DOM update using element keys and empty nodes.\n+\n+<!-- hidden sections will not appear in the aplication -->\n+<!-- hidden begin -->\n+![Screenshot](public/screenshot.png)\n+<!-- hidden end -->\n+\n+### Page sections\n+#### Card table\n+\n+At the top you can see color cards with letters. Below them, in the form of smaller letters, are disabled cards.\n+\n+![Catd table](public/card-table.png)\n+\n+To select a card, click it with the mouse button.\n+You can also change the order of enabled cards by dragging them with the mouse.\n+\n+Upon appearance or replacement, an outline of the card is highlighted in red.\n+If a card is updated in-place, you will see a smooth transition between the old and new colors.\n+This way you can distinguish which cards were replaced, and which were updated in-place.\n+\n+A rotating circle inside a card shows the time since the appearance or replacement of this card.\n+\n+#### Control buttons\n+\n+Then you can see the control buttons.\n+\n+![Control buttons](public/control-buttons.png)\n+\n+They rotate cards or their colors, shuffle them, enable and disable selected cards, deselect all cards and reset their state.\n+\n+Rotating cards or colors shifts them by one and the last card or color becomes the first.\n+\n+Shuffling reorders cards or colors at random.\n+\n+Rotation and shuffling is applied to the selected and enabled cards, or to all enabled if no cards are selected.\n+Enabling and disabling is applied to selected cards.\n+\n+#### Options\n+\n+And finally, two options to switch element keys and empty nodes.\n+\n+![Options](public/options.png)\n+\n+### Enabling and disabling elements\n+\n+An example shows how the elements behave when they appear and disappear.\n+\n+ 1. Make sure that the options are set as described below.\n+ 2. Select a few cards in the middle, for example: `C`&nbsp;`D`&nbsp;`I`&nbsp;`J`.\n+ 3. Press `Disable` and `Enable` buttons in turn.\n+\n+#### With element keys\n+\n+`Use element keys` is checked, `Use empty nodes` does not affect the result.\n+\n+The correspondence between old and new elements is determined using keys.\n+\n+![Enable and disable with keys](public/enable-disable-with-keys.gif)\n+\n+Note that only the cards that appear are highlighted, and all other cards stay unchanged.\n+\n+#### With empty nodes\n+\n+`Use element keys` is unchecked, `Use empty nodes` is checked.\n+\n+Empty nodes are used as a placeholders for disabled elements. This allows to maintain the correspondence between old and new elements.\n+\n+![Enable and disable with empty nodes](public/enable-disable-with-empty.gif)\n+\n+Result must be same as with element keys.\n+\n+#### Without element keys an empty nodes\n+\n+Both `Use element keys` and `Use empty nodes` is unchecked.\n+\n+All the elements with the same tag and namespace are updated in-place. \n+\n+If there are fewer old elements than new ones, then the elements are added to the end.\n+If there are more old elements than new ones, then the elements are removed from the end.\n+\n+![Enable and disable without keys and empty nodes](public/enable-disable-without-keys-and-empty.gif)\n+\n+Note the color transition of the cards, these cards are updated in-place.\n+\n+### Reordering elements\n+\n+An example shows how the elements behave when their order changes.\n+\n+ 1. Make sure that the options are set as described below.\n+ 2. Select a few cards in the middle, for example: `B`&nbsp;`C`&nbsp;`D`&nbsp;`E`.\n+ 3. Press `Rotate` or `Shuffle` button to the right of the `Cards:`.\n+\n+#### With element keys\n+\n+`Use element keys` is checked, `Use empty nodes` does not affect the result.\n+\n+The correspondence between old and new elements is determined using keys.\n+\n+![Reordering with keys](public/reordering-with-keys.gif)\n+\n+Note that some of the cards are highlighted in red, while the rest remains unchanged.\n+In case of rotation, only the first card is highlighted in red.\n+\n+#### Without element keys\n+\n+`Use element keys` is unchecked, `Use empty nodes` does not affect the result.\n+\n+Application cannot determine the correspondence between old and new the elements and all elements are updated in-place.\n+\n+![Reordering without keys](public/reordering-without-keys.gif)\n+\n+Note the color transition of the cards. None of the cards are highlighted in red.\n+\n+### Color reordering\n+\n+This example shows what happens when the attributes of the elements change but the order remains the same.\n+\n+Both `Use element keys` and `Use empty nodes` do not affect the result.\n+\n+ 1. Select a few cards in the middle, for example: `B`&nbsp;`C`&nbsp;`D`&nbsp;`E`.\n+ 2. Press `Rotate` or `Shuffle` button to the right of the `Colors:`.\n+\n+All elements are updated in-place.\n+\n+![Reordering Colors](public/reordering-colors.gif)\n+\n+Note the color transition of the cards. None of cards are highlighted in red.\n+\n+<!-- hidden begin -->\n+\n+---\n+\n+```bash\n+cargo make start\n+```\n+\n+Open [127.0.0.1:8000](http://127.0.0.1:8000) in your browser.\n+<!-- hidden end -->\ndiff --git a/examples/el_key/index.html b/examples/el_key/index.html\nnew file mode 100644\nindex 0000000..7b1695e\n--- /dev/null\n+++ b/examples/el_key/index.html\n@@ -0,0 +1,29 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+  <head>\n+    <meta charset=\"utf-8\" />\n+    <meta\n+      name=\"viewport\"\n+      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n+    />\n+\n+    <meta name=\"description\" content=\"\" />\n+\n+    <link rel=\"icon\" type=\"image/png\" href=\"/public/favicon.png\" />\n+\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"/public/el_key.css\" />\n+\n+    <title>Element key demo</title>\n+\n+    <!-- Because of Edge, see https://github.com/samthor/fast-text-encoding -->\n+    <script type=\"text/javascript\" src=\"/public/text-polyfill.min.js\"></script>\n+  </head>\n+  <body>\n+    <section id=\"app\"></section>\n+    <script type=\"module\">\n+      // https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html\n+      import init from \"/pkg/package.js\";\n+      init(\"/pkg/package_bg.wasm\");\n+    </script>\n+  </body>\n+</html>\ndiff --git a/examples/el_key/public/card-table.png b/examples/el_key/public/card-table.png\nnew file mode 100644\nindex 0000000..5271789\nBinary files /dev/null and b/examples/el_key/public/card-table.png differ\ndiff --git a/examples/el_key/public/control-buttons.png b/examples/el_key/public/control-buttons.png\nnew file mode 100644\nindex 0000000..c015440\nBinary files /dev/null and b/examples/el_key/public/control-buttons.png differ\ndiff --git a/examples/el_key/public/el_key.css b/examples/el_key/public/el_key.css\nnew file mode 100644\nindex 0000000..341698c\n--- /dev/null\n+++ b/examples/el_key/public/el_key.css\n@@ -0,0 +1,231 @@\n+/*\n+ * The size of the card is defined by variable and can be changed.\n+ * The radius of the spinner's circle is relative to the size of the card.\n+ * The stroke length is equal to the circumference of the spinner.\n+ * By animating the dashoffset, we create an spinner's animation similar to a clock.\n+ * Search for \"SVG spinner animation\" for more info.\n+ */\n+:root {\n+  --card__size: 64px;\n+  --spinner__radius: calc(var(--card__size) * 0.8 / 2);\n+  --spinner__stroke-lenght: calc(\n+    var(--spinner__radius) * 2 * 3.141592653589793\n+  );\n+}\n+\n+body {\n+  background-color: LightGray;\n+}\n+\n+#app {\n+  display: flex;\n+  align-items: center;\n+  justify-content: center;\n+  overflow: auto;\n+  margin: auto;\n+  min-height: 95vh;\n+}\n+#content {\n+  flex-grow: 1;\n+  max-width: 460px;\n+  padding-left: 64px;\n+  padding-right: 64px;\n+  padding-top: 32px;\n+  padding-bottom: 64px;\n+  background-color: white;\n+  color: black;\n+  display: flex;\n+  flex-direction: column;\n+  align-items: center;\n+}\n+\n+#content > * {\n+  margin-top: 10px;\n+  margin-bottom: 10px;\n+}\n+\n+#title {\n+  text-align: center;\n+  margin-top: 18px;\n+  margin-bottom: 18px;\n+}\n+\n+#card-table {\n+  width: 100%;\n+}\n+\n+#card-table__grid--enabled {\n+  width: 100%;\n+  display: grid;\n+  grid-template-columns: repeat(auto-fit, calc(var(--card__size) + 8px));\n+  grid-gap: 2px;\n+  justify-content: center;\n+}\n+#card-table__grid--disabled {\n+  margin-top: 5px;\n+  width: 100%;\n+  display: grid;\n+  grid-template-columns: repeat(auto-fit, 1.5em);\n+  grid-gap: 5px;\n+  justify-content: center;\n+}\n+\n+.card-table__card {\n+  cursor: pointer;\n+}\n+.card-table__card * {\n+  pointer-events: none;\n+}\n+\n+.card-table__card--disabled {\n+  text-align: center;\n+}\n+\n+.card-table__card--enabled,\n+.card-table__card--enabled * {\n+  transition: transform 0.5s ease-in-out, fill 0.5s ease-in-out,\n+    stroke 0.5s ease-in-out, opacity 0.5s ease-in-out;\n+}\n+\n+.card-table__card--enabled,\n+.card-table__card--enabled svg {\n+  width: calc(var(--card__size) + 8px);\n+  height: calc(var(--card__size) + 8px);\n+  transform-origin: 50% 50%;\n+}\n+\n+/*\n+ * Animation of flashing red border of a card.\n+ * This animation plays when the card is initialized or replaced,\n+ * Doesn't trigger when the card is patched.\n+ */\n+@keyframes card__redraw-animation {\n+  from {\n+    stroke: rgba(255, 0, 0, 0);\n+  }\n+  25% {\n+    stroke: rgba(255, 0, 0, 255);\n+  }\n+  to {\n+    stroke: rgba(255, 0, 0, 0);\n+  }\n+}\n+.card-table__card--enabled .card-table__card-background {\n+  x: 4px;\n+  y: 4px;\n+  width: var(--card__size);\n+  height: var(--card__size);\n+  rx: 8px;\n+  stroke-width: 4px;\n+\n+  animation-duration: 1s;\n+  animation-timing-function: ease-in-out;\n+  animation-iteration-count: 1;\n+  animation-fill-mode: both;\n+  animation-name: card__redraw-animation;\n+}\n+\n+/*\n+ * Drag and drop effects.\n+ */\n+.card-table__card--enabled.card-table__card--dragover,\n+.card-table__card--enabled.card-table__card--dragged {\n+  transform: scale(0.9);\n+  opacity: 50%;\n+}\n+\n+.card-table__card--enabled .card-table__card-text {\n+  transform-origin: 50% 50%;\n+  text-anchor: middle;\n+  dominant-baseline: middle;\n+  stroke: none;\n+  font-size: calc(var(--card__size) * 0.666);\n+}\n+.card-table__card--enabled.card-table__card--selected .card-table__card-text {\n+  transform: scale(1.4);\n+}\n+.card-table__card--disabled.card-table__card--selected {\n+  font-weight: bold;\n+}\n+\n+@keyframes card-table__card-spinner-animation {\n+  from {\n+    stroke-dashoffset: var(--spinner__stroke-lenght);\n+  }\n+  to {\n+    stroke-dashoffset: calc(var(--spinner__stroke-lenght) * -1);\n+  }\n+}\n+.card-table__card--enabled .card-table__card-spinner {\n+  cx: 50%;\n+  cy: 50%;\n+  r: var(--spinner__radius);\n+  transform-origin: 50% 50%;\n+  transform: rotate(-90deg);\n+\n+  fill: none;\n+  stroke-width: calc(var(--spinner__radius) / 10);\n+  stroke-dasharray: var(--spinner__stroke-lenght);\n+\n+  animation-duration: 60s;\n+  animation-timing-function: linear;\n+  animation-iteration-count: infinite;\n+  animation-fill-mode: both;\n+  animation-name: card-table__card-spinner-animation;\n+  animation-play-state: running;\n+}\n+.card-table__card--enabled.card-table__card--selected\n+  .card-table__card-spinner {\n+  stroke-width: calc(var(--spinner__radius) / 20);\n+  opacity: 30%;\n+  transform: rotate(-90deg) scale(1.15);\n+}\n+\n+#control-buttons button {\n+  margin: 2px;\n+}\n+\n+#control-buttons__order-buttons {\n+  display: grid;\n+  grid-template-columns: repeat(3, auto);\n+  justify-items: stretch;\n+  align-items: center;\n+}\n+#control-buttons__order-buttons div {\n+  text-align: right;\n+  margin-left: 5px;\n+  margin-right: 5px;\n+}\n+\n+#control-buttons__buttons {\n+  display: flex;\n+  flex-wrap: wrap;\n+  flex-direction: row;\n+  justify-content: center;\n+}\n+\n+#options {\n+  display: flex;\n+  flex-wrap: wrap;\n+  flex-direction: row;\n+  justify-content: center;\n+}\n+#options > div {\n+  margin-right: 5px;\n+}\n+\n+#readme {\n+  width: 100%;\n+  display: block;\n+}\n+#readme code {\n+  background-color: #e5e5ff;\n+  padding: 3px;\n+}\n+#readme img {\n+  display: block;\n+  max-width: 100%;\n+  max-height: 100%;\n+  margin-left: auto;\n+  margin-right: auto;\n+}\ndiff --git a/examples/el_key/public/enable-disable-with-empty.gif b/examples/el_key/public/enable-disable-with-empty.gif\nnew file mode 100644\nindex 0000000..85fbb07\nBinary files /dev/null and b/examples/el_key/public/enable-disable-with-empty.gif differ\ndiff --git a/examples/el_key/public/enable-disable-with-keys.gif b/examples/el_key/public/enable-disable-with-keys.gif\nnew file mode 100644\nindex 0000000..5e7f20e\nBinary files /dev/null and b/examples/el_key/public/enable-disable-with-keys.gif differ\ndiff --git a/examples/el_key/public/enable-disable-without-keys-and-empty.gif b/examples/el_key/public/enable-disable-without-keys-and-empty.gif\nnew file mode 100644\nindex 0000000..6650210\nBinary files /dev/null and b/examples/el_key/public/enable-disable-without-keys-and-empty.gif differ\ndiff --git a/examples/el_key/public/favicon.png b/examples/el_key/public/favicon.png\nnew file mode 100644\nindex 0000000..1b2d12c\nBinary files /dev/null and b/examples/el_key/public/favicon.png differ\ndiff --git a/examples/el_key/public/options.png b/examples/el_key/public/options.png\nnew file mode 100644\nindex 0000000..8d17a45\nBinary files /dev/null and b/examples/el_key/public/options.png differ\ndiff --git a/examples/el_key/public/reordering-colors.gif b/examples/el_key/public/reordering-colors.gif\nnew file mode 100644\nindex 0000000..93ead7a\nBinary files /dev/null and b/examples/el_key/public/reordering-colors.gif differ\ndiff --git a/examples/el_key/public/reordering-with-keys.gif b/examples/el_key/public/reordering-with-keys.gif\nnew file mode 100644\nindex 0000000..d2b569e\nBinary files /dev/null and b/examples/el_key/public/reordering-with-keys.gif differ\ndiff --git a/examples/el_key/public/reordering-without-keys.gif b/examples/el_key/public/reordering-without-keys.gif\nnew file mode 100644\nindex 0000000..ed0f205\nBinary files /dev/null and b/examples/el_key/public/reordering-without-keys.gif differ\ndiff --git a/examples/el_key/public/screenshot.png b/examples/el_key/public/screenshot.png\nnew file mode 100644\nindex 0000000..c135755\nBinary files /dev/null and b/examples/el_key/public/screenshot.png differ\ndiff --git a/examples/el_key/public/text-polyfill.min.js b/examples/el_key/public/text-polyfill.min.js\nnew file mode 100644\nindex 0000000..63b7d46\n--- /dev/null\n+++ b/examples/el_key/public/text-polyfill.min.js\n@@ -0,0 +1,5 @@\n+(function(l){function m(b){b=void 0===b?\"utf-8\":b;if(\"utf-8\"!==b)throw new RangeError(\"Failed to construct 'TextEncoder': The encoding label provided ('\"+b+\"') is invalid.\");}function k(b,a){b=void 0===b?\"utf-8\":b;a=void 0===a?{fatal:!1}:a;if(\"utf-8\"!==b)throw new RangeError(\"Failed to construct 'TextDecoder': The encoding label provided ('\"+b+\"') is invalid.\");if(a.fatal)throw Error(\"Failed to construct 'TextDecoder': the 'fatal' option is unsupported.\");}if(l.TextEncoder&&l.TextDecoder)return!1;\n+Object.defineProperty(m.prototype,\"encoding\",{value:\"utf-8\"});m.prototype.encode=function(b,a){a=void 0===a?{stream:!1}:a;if(a.stream)throw Error(\"Failed to encode: the 'stream' option is unsupported.\");a=0;for(var h=b.length,f=0,c=Math.max(32,h+(h>>1)+7),e=new Uint8Array(c>>3<<3);a<h;){var d=b.charCodeAt(a++);if(55296<=d&&56319>=d){if(a<h){var g=b.charCodeAt(a);56320===(g&64512)&&(++a,d=((d&1023)<<10)+(g&1023)+65536)}if(55296<=d&&56319>=d)continue}f+4>e.length&&(c+=8,c*=1+a/b.length*2,c=c>>3<<3,\n+g=new Uint8Array(c),g.set(e),e=g);if(0===(d&4294967168))e[f++]=d;else{if(0===(d&4294965248))e[f++]=d>>6&31|192;else if(0===(d&4294901760))e[f++]=d>>12&15|224,e[f++]=d>>6&63|128;else if(0===(d&4292870144))e[f++]=d>>18&7|240,e[f++]=d>>12&63|128,e[f++]=d>>6&63|128;else continue;e[f++]=d&63|128}}return e.slice(0,f)};Object.defineProperty(k.prototype,\"encoding\",{value:\"utf-8\"});Object.defineProperty(k.prototype,\"fatal\",{value:!1});Object.defineProperty(k.prototype,\"ignoreBOM\",{value:!1});k.prototype.decode=\n+function(b,a){a=void 0===a?{stream:!1}:a;if(a.stream)throw Error(\"Failed to decode: the 'stream' option is unsupported.\");b=new Uint8Array(b);a=0;for(var h=b.length,f=[];a<h;){var c=b[a++];if(0===c)break;if(0===(c&128))f.push(c);else if(192===(c&224)){var e=b[a++]&63;f.push((c&31)<<6|e)}else if(224===(c&240)){e=b[a++]&63;var d=b[a++]&63;f.push((c&31)<<12|e<<6|d)}else if(240===(c&248)){e=b[a++]&63;d=b[a++]&63;var g=b[a++]&63;c=(c&7)<<18|e<<12|d<<6|g;65535<c&&(c-=65536,f.push(c>>>10&1023|55296),c=56320|\n+c&1023);f.push(c)}}return String.fromCharCode.apply(null,f)};l.TextEncoder=m;l.TextDecoder=k})(\"undefined\"!==typeof window?window:\"undefined\"!==typeof global?global:this);\ndiff --git a/examples/el_key/src/lib.rs b/examples/el_key/src/lib.rs\nnew file mode 100644\nindex 0000000..b8754bd\n--- /dev/null\n+++ b/examples/el_key/src/lib.rs\n@@ -0,0 +1,508 @@\n+//! This example shows how to control a DOM update using element keys and empty nodes.\n+//! See README.md for more details.\n+\n+use rand::{rngs::SmallRng, seq::SliceRandom, SeedableRng};\n+use regex::Regex;\n+use scarlet::{\n+    color::{Color, RGBColor},\n+    colors::hslcolor::HSLColor,\n+};\n+use seed::{prelude::*, *};\n+use static_assertions::const_assert;\n+use std::mem;\n+\n+type CardId = char;\n+type NumCards = u8;\n+\n+// NUM_CARDS have to be in the range [0, 26] (inclusive).\n+// 26 is the number of letters in the English alphabet.\n+const NUM_CARDS: NumCards = 12;\n+const_assert!(NUM_CARDS <= 26);\n+\n+// ------ ------\n+//     Init\n+// ------ ------\n+\n+fn init(_: Url, _: &mut impl Orders<Msg>) -> Model {\n+    Model::new()\n+}\n+\n+// ------ ------\n+//     Model\n+// ------ ------\n+\n+// ------ Model ------\n+\n+#[derive(Debug)]\n+struct Model {\n+    cards: Vec<Card>,\n+    // VDOM options\n+    el_key_enabled: bool,\n+    empty_enabled: bool,\n+    // Save the README.md content into the model to mitigate rendering slowdown\n+    // due to Regex replacement and MD conversion.\n+    readme: Vec<Node<Msg>>,\n+}\n+\n+impl Model {\n+    fn new() -> Self {\n+        let readme = Regex::new(r\"<!-- hidden begin -->[\\s\\S]*?<!-- hidden end -->\")\n+            .unwrap()\n+            .replace_all(include_str!(\"../README.md\"), \"\");\n+\n+        Self {\n+            cards: Card::new_cards(),\n+            el_key_enabled: true,\n+            empty_enabled: true,\n+            readme: md!(&readme),\n+        }\n+    }\n+}\n+\n+// ------ Card ------\n+\n+#[derive(Debug, Copy, Clone)]\n+struct Card {\n+    id: CardId,\n+    fg_color: RGBColor,\n+    bg_color: RGBColor,\n+    enabled: bool,\n+    selected: bool,\n+    drag: Option<Drag>,\n+}\n+\n+impl Card {\n+    fn new_cards() -> Vec<Self> {\n+        (0..NUM_CARDS)\n+            .map(|card_n| Self {\n+                id: CardId::from(b'A' + card_n),\n+                fg_color: Self::fg_color(card_n),\n+                bg_color: Self::bg_color(card_n),\n+                enabled: true,\n+                selected: false,\n+                drag: None,\n+            })\n+            .collect()\n+    }\n+\n+    fn bg_color(card_n: NumCards) -> RGBColor {\n+        let card_hue = f64::from(card_n) / f64::from(NUM_CARDS) * 360.0;\n+        (HSLColor {\n+            h: card_hue % 360.0,\n+            s: 0.98,\n+            l: 0.81,\n+        })\n+        .convert()\n+    }\n+\n+    fn fg_color(card_n: NumCards) -> RGBColor {\n+        let card_hue = f64::from(card_n) / f64::from(NUM_CARDS) * 360.0;\n+        (HSLColor {\n+            h: (card_hue + 240.0) % 360.0,\n+            s: 0.45,\n+            l: 0.31,\n+        })\n+        .convert()\n+    }\n+}\n+\n+// ------ Drag ------\n+\n+#[derive(Debug, Copy, Clone)]\n+enum Drag {\n+    Dragged,\n+    Over,\n+}\n+\n+// ------ ------\n+//    Update\n+// ------ ------\n+\n+#[derive(Debug, Copy, Clone)]\n+enum Msg {\n+    // ------ Selecting ------\n+    SelectNone,\n+    ToggleSelected(CardId),\n+    // ------- Drag and drop ------\n+    DragStart(CardId),\n+    DragEnd,\n+    DragEnter(CardId),\n+    DragLeave(CardId),\n+    Drop(CardId, CardId),\n+    // ------ Control buttons ------\n+    DisableSelected,\n+    EnableSelected,\n+    Reset,\n+    // Change the order and colors of cards.\n+    // Applies to selected cards or to all enabled if there are no selected cards.\n+    RotateCards,\n+    RotateColors,\n+    ShuffleCards,\n+    ShuffleColors,\n+    // ------ Options ------\n+    ToggleElKey,\n+    ToggleEmpty,\n+}\n+\n+fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n+    log!(\"update:\", msg);\n+    match msg {\n+        // ------ Selecting ------\n+        Msg::SelectNone => {\n+            model\n+                .cards\n+                .iter_mut()\n+                .for_each(|card| card.selected = false);\n+        }\n+        Msg::ToggleSelected(card_id) => {\n+            if let Some(card) = model.cards.iter_mut().find(|card| card.id == card_id) {\n+                card.selected = !card.selected;\n+            }\n+        }\n+        // ------- Drag and drop ------\n+        Msg::DragStart(card_id) => {\n+            if let Some(card) = model.cards.iter_mut().find(|card| card.id == card_id) {\n+                card.drag = Some(Drag::Dragged);\n+            }\n+        }\n+        Msg::DragEnd => {\n+            for card in &mut model.cards {\n+                card.drag = None;\n+            }\n+        }\n+        Msg::DragEnter(card_id) => {\n+            if let Some(card) = model.cards.iter_mut().find(|card| card.id == card_id) {\n+                card.drag = Some(Drag::Over);\n+            }\n+        }\n+        Msg::DragLeave(card_id) => {\n+            if let Some(card) = model.cards.iter_mut().find(|card| card.id == card_id) {\n+                card.drag = None;\n+            }\n+        }\n+        Msg::Drop(from_id, to_id) => {\n+            swap(&mut model.cards, from_id, to_id);\n+            orders.skip().send_msg(Msg::DragEnd);\n+        }\n+        // ------ Control buttons ------\n+        Msg::DisableSelected => {\n+            model.cards.iter_mut().for_each(|card| {\n+                card.enabled = card.enabled && !card.selected;\n+            });\n+        }\n+        Msg::EnableSelected => {\n+            model.cards.iter_mut().for_each(|card| {\n+                card.enabled = card.enabled || card.selected;\n+            });\n+        }\n+        Msg::Reset => model.cards = Card::new_cards(),\n+        // Change the order and colors of cards.\n+        // Applies to selected cards or to all enabled if there are no selected cards.\n+        Msg::RotateCards => {\n+            let indices = selected_or_all_enabled(&model.cards);\n+            rotate_by_indices(&mut model.cards, &indices);\n+        }\n+        Msg::RotateColors => {\n+            let indices = selected_or_all_enabled(&model.cards);\n+            rotate_colors_by_indices(&mut model.cards, &indices);\n+        }\n+        Msg::ShuffleCards => {\n+            let mut indices = selected_or_all_enabled(&model.cards);\n+            indices.shuffle(&mut SmallRng::from_entropy());\n+            rotate_by_indices(&mut model.cards, &indices);\n+        }\n+        Msg::ShuffleColors => {\n+            let mut indices = selected_or_all_enabled(&model.cards);\n+            indices.shuffle(&mut SmallRng::from_entropy());\n+            rotate_colors_by_indices(&mut model.cards, &indices);\n+        }\n+        // ------ Options ------\n+        Msg::ToggleElKey => model.el_key_enabled = !model.el_key_enabled,\n+        Msg::ToggleEmpty => model.empty_enabled = !model.empty_enabled,\n+    };\n+}\n+\n+fn selected_or_all_enabled(cards: &[Card]) -> Vec<usize> {\n+    let selected: Vec<usize> = cards\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(i, card)| IF!(card.selected && card.enabled => i))\n+        .collect();\n+\n+    if !selected.is_empty() {\n+        return selected;\n+    }\n+\n+    cards\n+        .iter()\n+        .enumerate()\n+        .filter_map(|(i, card)| IF!(card.enabled => i))\n+        .collect()\n+}\n+\n+fn rotate_by_indices<T>(arr: &mut [T], indices: &[usize]) {\n+    indices\n+        .iter()\n+        .rev()\n+        .skip(1)\n+        .zip(indices.iter().rev())\n+        .for_each(|(&a, &b)| arr.swap(a, b));\n+}\n+\n+fn rotate_colors_by_indices(cards: &mut [Card], indices: &[usize]) {\n+    if let Some(&last_i) = indices.last() {\n+        let mut bg = cards[last_i].bg_color;\n+        let mut fg = cards[last_i].fg_color;\n+        for &i in indices {\n+            let card = &mut cards[i];\n+            mem::swap(&mut bg, &mut card.bg_color);\n+            mem::swap(&mut fg, &mut card.fg_color);\n+        }\n+    }\n+}\n+\n+fn swap(cards: &mut [Card], a_id: CardId, b_id: CardId) {\n+    if let (Some(a_index), Some(b_index)) = (card_index(cards, a_id), card_index(cards, b_id)) {\n+        cards.swap(a_index, b_index);\n+    }\n+}\n+\n+fn card_index(cards: &[Card], card_id: CardId) -> Option<usize> {\n+    cards\n+        .iter()\n+        .enumerate()\n+        .find_map(|(i, card)| IF!(card.id == card_id => i))\n+}\n+\n+// ------ ------\n+//     View\n+// ------ ------\n+\n+// Note: It's macro so you can use it with all events.\n+macro_rules! stop_and_prevent {\n+    { $event:expr } => {\n+        {\n+            $event.stop_propagation();\n+            $event.prevent_default();\n+        }\n+     };\n+}\n+\n+fn view(model: &Model) -> impl IntoNodes<Msg> {\n+    div![\n+        id![\"content\"],\n+        h1![id![\"title\"], \"Element key example\"],\n+        card_table(model),\n+        control_buttons(),\n+        options(model),\n+        readme(&model.readme),\n+    ]\n+}\n+\n+fn card_table(model: &Model) -> Node<Msg> {\n+    section![\n+        id![\"card-table\"],\n+        div![\n+            id![\"card-table__grid--enabled\"],\n+            model.cards.iter().filter_map(|card| {\n+                if card.enabled {\n+                    Some(enabled_card(card, model.el_key_enabled))\n+                } else if model.empty_enabled {\n+                    Some(empty![])\n+                } else {\n+                    None\n+                }\n+            })\n+        ],\n+        div![\n+            id![\"card-table__grid--disabled\"],\n+            model.cards.iter().filter_map(|card| {\n+                if !card.enabled {\n+                    Some(disabled_card(card, model.el_key_enabled))\n+                } else if model.empty_enabled {\n+                    Some(empty![])\n+                } else {\n+                    None\n+                }\n+            })\n+        ]\n+    ]\n+}\n+\n+fn disabled_card(card: &Card, el_key_enabled: bool) -> Node<Msg> {\n+    let card_id = card.id;\n+    div![\n+        id!(format!(\"card-table__card-{}\", card.id)),\n+        IF!(el_key_enabled => el_key(&card_id)),\n+        C![\n+            \"card-table__card\",\n+            \"card-table__card--disabled\",\n+            IF!(card.selected => \"card-table__card--selected\"),\n+        ],\n+        style! {\n+            St::Color => card.fg_color.to_string(),\n+        },\n+        ev(Ev::Click, move |_| Msg::ToggleSelected(card_id)),\n+        format!(\"{}\", card.id),\n+    ]\n+}\n+\n+fn enabled_card(card: &Card, el_key_enabled: bool) -> Node<Msg> {\n+    div![\n+        id!(format!(\"card-table__card-{}\", card.id)),\n+        IF!(el_key_enabled => el_key(&card.id)),\n+        C![\n+            \"card-table__card\",\n+            \"card-table__card--enabled\",\n+            card.drag.map(|drag| match drag {\n+                Drag::Dragged => \"card-table__card--dragged\",\n+                Drag::Over => \"card-table__card--dragover\",\n+            }),\n+            IF!(card.selected => \"card-table__card--selected\"),\n+        ],\n+        attrs! {\n+            At::Draggable => true\n+        },\n+        enabled_card_graphics(card),\n+        enabled_card_event_handlers(card),\n+    ]\n+}\n+\n+fn enabled_card_graphics(card: &Card) -> Node<Msg> {\n+    svg![\n+        rect![\n+            C!(\"card-table__card-background\"),\n+            attrs! {\n+                At::Fill => card.bg_color.to_string(),\n+            },\n+        ],\n+        circle![\n+            C!(\"card-table__card-spinner\"),\n+            attrs! {\n+                At::Stroke => card.fg_color.to_string(),\n+            }\n+        ],\n+        text![\n+            C!(\"card-table__card-text\"),\n+            attrs! {\n+                // SVG Text's `x` and `y` is not CSS properties.\n+                At::X => percent(50),\n+                At::Y => percent(if card.id == 'J' { 50 } else { 55 }),\n+                At::Fill => card.fg_color.to_string(),\n+            },\n+            card.id.to_string(),\n+        ],\n+    ]\n+}\n+\n+fn enabled_card_event_handlers(card: &Card) -> Vec<EventHandler<Msg>> {\n+    let card_id = card.id;\n+    vec![\n+        ev(Ev::Click, move |_| Msg::ToggleSelected(card_id)),\n+        drag_ev(Ev::DragStart, move |event| {\n+            event\n+                .data_transfer()\n+                .map(|dt| dt.set_data(\"card_id\", &card_id.to_string()));\n+            Msg::DragStart(card_id)\n+        }),\n+        drag_ev(Ev::DragEnter, move |event| {\n+            stop_and_prevent!(event);\n+            event.data_transfer().unwrap().set_drop_effect(\"move\");\n+            Msg::DragEnter(card_id)\n+        }),\n+        drag_ev(Ev::DragLeave, move |event| {\n+            stop_and_prevent!(event);\n+            event.data_transfer().unwrap().set_drop_effect(\"move\");\n+            Msg::DragLeave(card_id)\n+        }),\n+        drag_ev(Ev::DragOver, |event| -> Option<Msg> {\n+            stop_and_prevent!(event);\n+            event.data_transfer().unwrap().set_drop_effect(\"move\");\n+            None\n+        }),\n+        drag_ev(Ev::Drop, move |event| {\n+            stop_and_prevent!(event);\n+            event\n+                .data_transfer()\n+                .unwrap()\n+                .get_data(\"card_id\")\n+                .ok()\n+                .map(|d| d.parse().ok())\n+                .flatten()\n+                .map(|src_id| Msg::Drop(src_id, card_id))\n+        }),\n+        drag_ev(Ev::DragEnd, |_| Msg::DragEnd),\n+    ]\n+}\n+\n+fn control_buttons() -> Node<Msg> {\n+    section![\n+        id![\"control-buttons\"],\n+        div![\n+            id![\"control-buttons__order-buttons\"],\n+            div![\"Cards:\"],\n+            button![\"Rotate\", ev(Ev::Click, |_| Msg::RotateCards)],\n+            button![\"Shuffle\", ev(Ev::Click, |_| Msg::ShuffleCards)],\n+            div![\"Colors:\"],\n+            button![\"Rotate\", ev(Ev::Click, |_| Msg::RotateColors)],\n+            button![\"Shuffle\", ev(Ev::Click, |_| Msg::ShuffleColors)],\n+        ],\n+        div![\n+            id!(\"control-buttons__buttons\"),\n+            button![\"Disable\", ev(Ev::Click, |_| Msg::DisableSelected)],\n+            button![\"Enable\", ev(Ev::Click, |_| Msg::EnableSelected)],\n+            button![\"Select none\", ev(Ev::Click, |_| Msg::SelectNone)],\n+            button![\"Reset\", ev(Ev::Click, |_| Msg::Reset)],\n+        ],\n+    ]\n+}\n+\n+fn options(model: &Model) -> Node<Msg> {\n+    section![\n+        id![\"options\"],\n+        div![\n+            input![attrs! {\n+                At::Type => \"checkbox\",\n+                At::Name => \"use-el-key\",\n+                At::Checked => model.el_key_enabled.as_at_value(),\n+            },],\n+            label![\n+                attrs! {\n+                    At::For => \"use-el-key\"\n+                },\n+                \"Use element keys\",\n+            ],\n+            ev(Ev::Click, |_| Msg::ToggleElKey),\n+        ],\n+        div![\n+            input![attrs! {\n+                At::Type => \"checkbox\",\n+                At::Name => \"use-empty\",\n+                At::Checked => model.empty_enabled.as_at_value(),\n+            },],\n+            label![\n+                attrs! {\n+                    At::For => \"use-empty\"\n+                },\n+                \"Use empty nodes\",\n+            ],\n+            ev(Ev::Click, |_| Msg::ToggleEmpty),\n+        ],\n+    ]\n+}\n+\n+fn readme(readme: &[Node<Msg>]) -> Node<Msg> {\n+    section![\n+        id!(\"readme\"),\n+        details![attrs! {At::Open => true}, summary![\"Readme\"], readme]\n+    ]\n+}\n+\n+// ------ ------\n+//     Start\n+// ------ ------\n+\n+#[wasm_bindgen(start)]\n+pub fn start() {\n+    App::start(\"app\", init, update, view);\n+}\ndiff --git a/examples/server_integration/Makefile.toml b/examples/server_integration/Makefile.toml\nindex aaf2950..86b0bba 100644\n--- a/examples/server_integration/Makefile.toml\n+++ b/examples/server_integration/Makefile.toml\n@@ -1,73 +1,78 @@\n \n # ---- BUILD ----\n \n [tasks.build]\n description = \"Build client and server\"\n clear = true\n workspace = false\n dependencies = [\"build_client\", \"build_server\"]\n \n [tasks.build_release]\n extend = \"build\"\n description = \"Build client and server in release mode\"\n dependencies = [\"build_client_release\", \"build_server_release\"]\n \n [tasks.build_client]\n description = \"Build client\"\n workspace = false\n install_crate = { crate_name = \"wasm-pack\", binary = \"wasm-pack\", test_arg = \"-V\" }\n command = \"wasm-pack\"\n args = [\"build\", \"client\", \"--target\", \"web\", \"--out-name\", \"package\", \"--dev\"]\n \n [tasks.build_client_release]\n extend = \"build_client\"\n description = \"Build client in release mode\"\n args = [\"build\", \"client\", \"--target\", \"web\", \"--out-name\", \"package\", \"--release\"]\n \n [tasks.build_server]\n description = \"Build server\"\n workspace = false\n command = \"cargo\"\n args = [\"build\", \"--package\", \"server\"]\n \n [tasks.build_server_release]\n extend = \"build_server\"\n description = \"Build server in release mode\"\n args = [\"build\", \"--package\", \"server\", \"--release\"]\n \n # ---- START ----\n \n [tasks.start]\n description = \"Build and start Actix server with client on port 8000\"\n workspace = false\n command = \"cargo\"\n args = [\"run\", \"--package\", \"server\"]\n dependencies = [\"build\"]\n \n [tasks.start_release]\n extend = \"start\"\n description = \"Build and start Actix server with client on port 8000 in release mode\"\n args = [\"run\", \"--package\", \"server\", \"--release\"]\n dependencies = [\"build_release\"]\n \n # ---- LINT ----\n \n [tasks.fmt]\n description = \"Format with rustfmt\"\n workspace = false\n install_crate = { crate_name = \"rustfmt-nightly\", rustup_component_name = \"rustfmt\", binary = \"rustfmt\", test_arg = \"--help\" }\n command = \"cargo\"\n args = [\"fmt\", \"--all\"]\n \n [tasks.fmt_check]\n extend = \"fmt\"\n description = \"Check format with rustfmt\"\n args = [\"fmt\", \"--all\", \"--\", \"--check\"]\n \n [tasks.clippy]\n description = \"Lint with Clippy\"\n clear = true\n workspace = false\n install_crate = { rustup_component_name = \"clippy\", binary = \"cargo-clippy\", test_arg = \"--help\" }\n command = \"cargo\"\n-args = [\"clippy\", \"--all-features\", \"--\", \"--deny\", \"clippy::all\", \"--deny\", \"clippy::pedantic\", \"--deny\", \"clippy::nursery\"]\n\\ No newline at end of file\n+args = [\"clippy\", \"--all-features\", \"--\",\n+    \"--deny\", \"warnings\",\n+    \"--deny\", \"clippy::pedantic\",\n+    \"--deny\", \"clippy::nursery\",\n+    \"--allow\", \"clippy::wildcard_imports\" # for `use seed::{prelude::*, *};`\n+]\ndiff --git a/examples/server_integration/client/src/example_a.rs b/examples/server_integration/client/src/example_a.rs\nindex 671d847..bbb3489 100644\n--- a/examples/server_integration/client/src/example_a.rs\n+++ b/examples/server_integration/client/src/example_a.rs\n@@ -1,97 +1,95 @@\n use seed::{self, prelude::*, *};\n use std::borrow::Cow;\n \n-use shared;\n-\n pub const TITLE: &str = \"Example A\";\n pub const DESCRIPTION: &str = \"Write something into input and click on 'Send message'.\n     Message will be send to server and then it wil be returned with ordinal number.\n     Ordinal number is incremented by server with each request.\";\n \n fn get_request_url() -> impl Into<Cow<'static, str>> {\n     \"/api/send-message\"\n }\n \n // ------ ------\n //     Model\n // ------ -----\n \n #[derive(Default)]\n pub struct Model {\n     pub new_message: String,\n     pub response_data: Option<shared::SendMessageResponseBody>,\n }\n \n // ------ ------\n //    Update\n // ------ ------\n \n pub enum Msg {\n     NewMessageChanged(String),\n     SendRequest,\n     Fetched(fetch::Result<shared::SendMessageResponseBody>),\n }\n \n pub fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n     match msg {\n         Msg::NewMessageChanged(message) => {\n             model.new_message = message;\n         }\n         Msg::SendRequest => {\n             orders.skip().perform_cmd({\n                 let message = model.new_message.clone();\n                 async { Msg::Fetched(send_message(message).await) }\n             });\n         }\n \n         Msg::Fetched(Ok(response_data)) => {\n             model.response_data = Some(response_data);\n         }\n \n         Msg::Fetched(Err(fetch_error)) => {\n             log!(\"Example_A error:\", fetch_error);\n             orders.skip();\n         }\n     }\n }\n \n async fn send_message(new_message: String) -> fetch::Result<shared::SendMessageResponseBody> {\n     Request::new(get_request_url())\n         .method(Method::Post)\n         .json(&shared::SendMessageRequestBody { text: new_message })?\n         .fetch()\n         .await?\n         .check_status()?\n         .json()\n         .await\n }\n \n // ------ ------\n //     View\n // ------ ------\n \n pub fn view(model: &Model, intro: impl FnOnce(&str, &str) -> Vec<Node<Msg>>) -> Vec<Node<Msg>> {\n     nodes![\n         intro(TITLE, DESCRIPTION),\n         view_message(&model.response_data),\n         input![\n             input_ev(Ev::Input, Msg::NewMessageChanged),\n             attrs! {\n                 At::Value => model.new_message,\n                 At::AutoFocus => AtValue::None,\n             }\n         ],\n         button![ev(Ev::Click, |_| Msg::SendRequest), \"Send message\"],\n     ]\n }\n \n fn view_message(message: &Option<shared::SendMessageResponseBody>) -> Node<Msg> {\n     let message = match message {\n         Some(message) => message,\n         None => return empty![],\n     };\n     div![format!(\n         r#\"{}. message: \"{}\"\"#,\n         message.ordinal_number, message.text\n     )]\n }\ndiff --git a/examples/server_integration/server/src/main.rs b/examples/server_integration/server/src/main.rs\nindex a697d36..7f4d81c 100644\n--- a/examples/server_integration/server/src/main.rs\n+++ b/examples/server_integration/server/src/main.rs\n@@ -1,104 +1,101 @@\n use actix::prelude::*;\n use actix_files::{Files, NamedFile};\n use actix_multipart::{Multipart, MultipartError};\n use actix_web::{get, post, web, App, HttpServer};\n use std::fmt::Write;\n use std::time;\n-use tokio_timer;\n-\n-use shared;\n \n mod count_actor;\n use count_actor::{CountActor, MsgIncrement};\n \n // ---- Apis (\"/api/*\") ----\n \n #[allow(clippy::needless_pass_by_value)]\n #[post(\"send-message\")]\n fn send_message(\n     state: web::Data<State>,\n     request_data: web::Json<shared::SendMessageRequestBody>,\n ) -> impl Future<Item = web::Json<shared::SendMessageResponseBody>, Error = actix::MailboxError> {\n     let text = request_data.text.clone();\n     state\n         .count_actor\n         .send(MsgIncrement)\n         .and_then(move |ordinal_number| {\n             Ok(web::Json(shared::SendMessageResponseBody {\n                 ordinal_number,\n                 text,\n             }))\n         })\n }\n \n #[get(\"delayed-response/{delay}\")]\n fn delayed_response(\n     delay: web::Path<u64>,\n ) -> impl Future<Item = String, Error = tokio_timer::Error> {\n     tokio_timer::sleep(time::Duration::from_millis(*delay))\n         .and_then(move |()| Ok(format!(\"Delay was set to {}ms.\", delay)))\n }\n \n #[post(\"form\")]\n fn form(form: Multipart) -> impl Future<Item = String, Error = MultipartError> {\n     form.map(|field| {\n         // get field name\n         let name = field\n             .content_disposition()\n             .and_then(|cd| cd.get_name().map(ToString::to_string))\n             .expect(\"Can't get field name!\");\n \n         field\n             // get field value stream\n             .fold(Vec::new(), |mut value, bytes| -> Result<Vec<u8>, MultipartError> {\n                 for byte in bytes {\n                     value.push(byte)\n                 }\n                 Ok(value)\n             })\n             .map(|value| String::from_utf8_lossy(&value).into_owned())\n             // add name into stream\n             .map(move |value| (name, value))\n             .into_stream()\n     })\n     .flatten()\n     .fold(\n         String::new(),\n         |mut output, (name, value)| -> Result<String, MultipartError> {\n             writeln!(&mut output, \"{}: {}\", name, value).unwrap();\n             writeln!(&mut output, \"___________________\").unwrap();\n             Ok(output)\n         },\n     )\n }\n \n struct State {\n     count_actor: Addr<CountActor>,\n }\n \n fn main() -> std::io::Result<()> {\n     let system = System::new(\"server-integration-example\");\n \n     let count_actor_addr = CountActor(0).start();\n \n     HttpServer::new(move || {\n         App::new()\n             .data(State {\n                 count_actor: count_actor_addr.clone(),\n             })\n             .service(\n                 web::scope(\"/api/\")\n                     .service(send_message)\n                     .service(delayed_response)\n                     .service(form)\n                     .default_service(web::route().to(web::HttpResponse::NotFound)),\n             )\n             .service(Files::new(\"/public\", \"./client/public\"))\n             .service(Files::new(\"/pkg\", \"./client/pkg\"))\n             .default_service(web::get().to(|| NamedFile::open(\"./client/index.html\")))\n     })\n     .bind(\"127.0.0.1:8000\")?\n     .run()?;\n \n     system.run()\n }\ndiff --git a/examples/subscribe/src/lib.rs b/examples/subscribe/src/lib.rs\nindex 1694347..4c87724 100644\n--- a/examples/subscribe/src/lib.rs\n+++ b/examples/subscribe/src/lib.rs\n@@ -1,239 +1,238 @@\n use itertools::Itertools;\n-use js_sys;\n use seed::{prelude::*, *};\n use wasm_bindgen::JsCast;\n \n mod counter;\n \n // ------ ------\n //     Init\n // ------ ------\n \n fn init(url: Url, orders: &mut impl Orders<Msg>) -> Model {\n     orders\n         .subscribe(Msg::UrlRequested)\n         .subscribe(Msg::UrlChanged)\n         .notify(subs::UrlChanged(url))\n         .stream(streams::window_event(Ev::Resize, |_| Msg::OnResize))\n         .stream(streams::document_event(Ev::SelectionChange, |_| {\n             Msg::OnSelection\n         }));\n \n     Model {\n         sub_handles: Vec::new(),\n         timer_handle: None,\n         timeout_handle: None,\n         seconds: 0,\n         counter: counter::init(&mut orders.proxy(Msg::Counter)),\n         window_size: window_size(),\n     }\n }\n \n // ------ ------\n //     Model\n // ------ ------\n \n struct Model {\n     sub_handles: Vec<SubHandle>,\n     timer_handle: Option<StreamHandle>,\n     timeout_handle: Option<CmdHandle>,\n     seconds: u32,\n     counter: counter::Model,\n     window_size: (f64, f64),\n }\n \n // ------ ------\n //    Update\n // ------ ------\n \n enum Msg {\n     Subscribe,\n     Notify,\n     Unsubscribe,\n \n     StartTimer,\n     StopTimer,\n     OnTick,\n \n     Counter(counter::Msg),\n     ResetCounter,\n \n     StringReceived(String),\n     UrlRequested(subs::UrlRequested),\n     UrlChanged(subs::UrlChanged),\n \n     SetTimeout,\n     CancelTimeout,\n \n     OnResize,\n     OnSelection,\n }\n \n fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n     match msg {\n         Msg::Subscribe => {\n             log!(\"--- Subscribe ---\");\n             model.sub_handles = vec![\n                 orders.subscribe_with_handle(|number: i32| log!(\"Number Received\", number)),\n                 orders.subscribe_with_handle(Msg::StringReceived),\n                 orders.subscribe_with_handle(Msg::StringReceived),\n             ];\n         }\n         Msg::Notify => {\n             log!(\"--- Notify ---\");\n             orders.notify(15).notify(21).notify(\"Hello!\".to_owned());\n         }\n         Msg::Unsubscribe => {\n             log!(\"--- Unsubscribe ---\");\n             model.sub_handles.clear();\n         }\n         Msg::StartTimer => {\n             model.timer_handle =\n                 Some(orders.stream_with_handle(streams::interval(1000, || Msg::OnTick)))\n         }\n         Msg::StopTimer => {\n             model.timer_handle = None;\n         }\n         Msg::OnTick => {\n             model.seconds += 1;\n         }\n         Msg::Counter(msg) => counter::update(msg, &mut model.counter),\n         Msg::ResetCounter => {\n             orders.notify(counter::DoReset);\n         }\n         Msg::StringReceived(message) => {\n             log!(\"String Received\", message);\n         }\n         Msg::UrlRequested(subs::UrlRequested(url, _url_request)) => {\n             log!(\"Url Requested\", url);\n         }\n         Msg::UrlChanged(subs::UrlChanged(url)) => {\n             log!(\"Url Changed\", url);\n         }\n         Msg::SetTimeout => {\n             log!(\"--- Set timeout ---\");\n             model.timeout_handle =\n                 Some(orders.perform_cmd_with_handle(cmds::timeout(2000, || log!(\"Timeout!!\"))));\n         }\n         Msg::CancelTimeout => {\n             log!(\"--- Cancel timeout ---\");\n             model.timeout_handle = None;\n         }\n         Msg::OnResize => {\n             model.window_size = window_size();\n         }\n         Msg::OnSelection => {\n             if let Some(selection) = document().get_selection().expect(\"get selection\") {\n                 let selection = selection\n                     .to_string()\n                     .as_string()\n                     .expect(\"cast JsString to String\");\n                 if not(selection.is_empty()) {\n                     log!(\"Selection\", selection);\n                 }\n             }\n         }\n     }\n }\n \n // ------ ------\n //     View\n // ------ ------\n \n fn view(model: &Model) -> impl IntoNodes<Msg> {\n     let centered_column = style! {\n         St::Display => \"flex\",\n         St::FlexDirection => \"column\",\n         St::AlignItems => \"center\"\n     };\n \n     div![\n         centered_column.clone(),\n         \"Open Console log, please\",\n         divider(),\n         // --- Subscribe | Notify | Unsubscribe ---\n         div![with_spaces(vec![\n             button![ev(Ev::Click, |_| Msg::Subscribe), \"1. Subscribe\"],\n             button![ev(Ev::Click, |_| Msg::Notify), \"2. Notify\"],\n             button![ev(Ev::Click, |_| Msg::Unsubscribe), \"3. Unsubscribe\"],\n         ]),],\n         divider(),\n         // --- Request new URL ---\n         a![attrs! {At::Href => \"/requested_url\"}, \"Request new URL\"],\n         divider(),\n         // --- Counter ---\n         div![\n             centered_column,\n             counter::view(&model.counter).map_msg(Msg::Counter),\n             button![\n                 style! {St::MarginTop => rem(0.5)},\n                 ev(Ev::Click, |_| Msg::ResetCounter),\n                 ev(Ev::Click, |_| log!(\"Reset counter!\")),\n                 \"Reset counter\"\n             ],\n         ],\n         divider(),\n         // --- Seconds ---\n         div![\n             style! {St::Display => \"flex\"},\n             with_spaces(vec![\n                 div![\"Seconds: \", model.seconds,],\n                 button![ev(Ev::Click, |_| Msg::StartTimer), \"Start\"],\n                 button![ev(Ev::Click, |_| Msg::StopTimer), \"Stop\"],\n             ]),\n         ],\n         divider(),\n         // --- Timeout ---\n         div![\n             style! {St::Display => \"flex\"},\n             with_spaces(vec![\n                 button![ev(Ev::Click, |_| Msg::SetTimeout), \"Set 2s timeout\"],\n                 button![ev(Ev::Click, |_| Msg::CancelTimeout), \"Cancel\"],\n             ]),\n         ],\n         divider(),\n         // --- Window size ---\n         {\n             let (width, height) = &model.window_size;\n             format!(\"Window size: {} x {}\", width, height)\n         }\n     ]\n }\n \n fn divider() -> Node<Msg> {\n     div![style! {St::Margin => rem(2)}]\n }\n \n fn with_spaces(nodes: Vec<Node<Msg>>) -> impl Iterator<Item = Node<Msg>> {\n     nodes.into_iter().intersperse(span![\n         style! {St::Width => rem(1), St::Display => \"inline-block\"}\n     ])\n }\n \n // ------ ------\n //    Helpers\n // ------ ------\n \n fn window_size() -> (f64, f64) {\n     let window = window();\n     let width = window\n         .inner_width()\n         .expect(\"window width\")\n         .unchecked_into::<js_sys::Number>()\n         .value_of();\n     let height = window\n         .inner_height()\n         .expect(\"window height\")\n         .unchecked_into::<js_sys::Number>()\n         .value_of();\n     (width, height)\n }\n \n // ------ ------\n //     Start\n // ------ ------\n \n #[wasm_bindgen(start)]\n pub fn start() {\n     App::start(\"app\", init, update, view);\n }\ndiff --git a/examples/url/src/lib.rs b/examples/url/src/lib.rs\nindex fad2c0a..b0b5b41 100644\n--- a/examples/url/src/lib.rs\n+++ b/examples/url/src/lib.rs\n@@ -1,135 +1,141 @@\n use seed::{prelude::*, *};\n use std::rc::Rc;\n \n // ------ ------\n //     Init\n // ------ ------\n \n fn init(url: Url, orders: &mut impl Orders<Msg>) -> Model {\n     orders.subscribe(Msg::UrlChanged);\n \n     Model::new(url, orders.clone_base_path())\n }\n \n // ------ ------\n //     Model\n // ------ ------\n \n struct Model {\n     base_path: Rc<Vec<String>>,\n     initial_url: Url,\n     next_path_part: Option<String>,\n     remaining_path_parts: Vec<String>,\n     base_url: Url,\n }\n \n impl Model {\n     fn new(mut url: Url, base_path: Rc<Vec<String>>) -> Self {\n+        log!(&url);\n+        log!(url.to_string());\n+        log!(\"_______________________________\");\n+\n         Self {\n             base_path,\n             initial_url: url.clone(),\n             base_url: url.to_base_url(),\n             next_path_part: url.next_path_part().map(ToOwned::to_owned),\n             remaining_path_parts: url\n                 .remaining_path_parts()\n                 .into_iter()\n                 .map(ToOwned::to_owned)\n                 .collect(),\n         }\n     }\n }\n \n // ------ ------\n //    Update\n // ------ ------\n \n enum Msg {\n     UrlChanged(subs::UrlChanged),\n     GoToUrl(Url),\n }\n \n fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n     match msg {\n         Msg::UrlChanged(subs::UrlChanged(url)) => {\n             *model = Model::new(url, orders.clone_base_path())\n         }\n         Msg::GoToUrl(url) => {\n             orders.notify(subs::UrlRequested::new(url));\n         }\n     }\n }\n \n // ------ ------\n //     View\n // ------ ------\n \n fn view(model: &Model) -> Node<Msg> {\n     ol![\n         li![\n             button![\n                 \"Go to '/ui/a/b/c?x=1?#hash'` and reload the page\",\n                 ev(Ev::Click, |_| {\n                     Url::new()\n                         .set_path(&[\"ui\", \"a\", \"b\", \"c\"])\n-                        .set_search(\"x=1\")\n+                        .set_search(UrlSearch::new(vec![\n+                            (\"x\", vec![\"1\"])\n+                        ]))\n                         .set_hash(\"hash\")\n                         .go_and_load()\n                 })\n             ],\n         ],\n         li![\n             format!(\"Base path ...... \\\"{}\\\"  ......  (comment out `base` element in `index.html`, refresh the page and watch changes)\", &model.base_path.join(\"/\")),\n         ],\n         li![\n             format!(\"Initial Url ...... \\\"{}\\\"\", &model.initial_url),\n         ],\n         li![\n             format!(\"Base Url ...... \\\"{}\\\"  ......  (the path part is the most important here)\", &model.base_url),\n         ],\n         li![\n             format!(\"Next path part ...... \\\"{:?}\\\"\", &model.next_path_part),\n         ],\n         li![\n             format!(\"Remaining path parts ...... \\\"{:?}\\\"\", &model.remaining_path_parts),\n         ],\n         li![\n             button![\n                 \"Go to '/' and don't trigger `UrlChanged`\",\n                 ev(Ev::Click, |_| {\n                     Url::new().go_and_push()\n                 })\n             ],\n         ],\n         li![\n             button![\n                 \"Go back\",\n                 ev(Ev::Click, |_| {\n                     Url::go_back(1)\n                 })\n             ],\n         ],\n         li![\n             button![\n                 \"Go to '/' and trigger `UrlChanged` (simulate `<a>` link click)\",\n                 ev(Ev::Click, |_| Msg::GoToUrl(Url::new()))\n             ],\n         ],\n         li![\n             button![\n                 \"Go to 'https://example.com'\",\n                 ev(Ev::Click, |_| {\n                     Url::go_and_load_with_str(\"https://example.com\")\n                 })\n             ],\n         ],\n     ]\n }\n \n // ------ ------\n //     Start\n // ------ ------\n \n #[wasm_bindgen(start)]\n pub fn start() {\n     App::start(\"app\", init, update, view);\n }\ndiff --git a/src/app.rs b/src/app.rs\nindex 7859254..726bc21 100644\n--- a/src/app.rs\n+++ b/src/app.rs\n@@ -1,681 +1,684 @@\n use crate::browser::dom::virtual_dom_bridge;\n use crate::browser::{\n     service::routing,\n     util::{self, window, ClosureNew},\n     Url, DUMMY_BASE_URL,\n };\n use crate::virtual_dom::{patch, El, EventHandlerManager, IntoNodes, Mailbox, Node, Tag};\n use builder::{\n     init::{Init, InitFn as BuilderInitFn},\n     IntoAfterMount, MountPointInitInitAPI, UndefinedInitAPI, UndefinedMountPoint,\n };\n use enclose::{enc, enclose};\n use std::{\n     any::Any,\n     cell::{Cell, RefCell},\n     collections::VecDeque,\n     marker::PhantomData,\n     rc::Rc,\n };\n-use types::*;\n+use types::{RoutesFn, SinkFn, UpdateFn, ViewFn, WindowEventsFn};\n use wasm_bindgen::closure::Closure;\n use web_sys::Element;\n \n pub mod builder;\n pub mod cfg;\n pub mod cmd_manager;\n pub mod cmds;\n pub mod data;\n pub mod effects;\n pub mod get_element;\n pub mod message_mapper;\n pub mod orders;\n-pub mod render_timestamp_delta;\n+pub mod render_info;\n pub mod stream_manager;\n pub mod streams;\n pub mod sub_manager;\n pub mod subs;\n pub mod types;\n \n pub use builder::{\n     AfterMount, BeforeMount, Builder as AppBuilder, MountPoint, MountType, UndefinedAfterMount,\n     UrlHandling,\n };\n pub use cfg::{AppCfg, AppInitCfg};\n pub use cmd_manager::{CmdHandle, CmdManager};\n pub use data::AppData;\n pub use effects::Effect;\n pub use get_element::GetElement;\n pub use message_mapper::MessageMapper;\n pub use orders::{Orders, OrdersContainer, OrdersProxy};\n-pub use render_timestamp_delta::RenderTimestampDelta;\n+pub use render_info::RenderInfo;\n pub use stream_manager::{StreamHandle, StreamManager};\n pub use sub_manager::{Notification, SubHandle, SubManager};\n \n pub struct UndefinedGMsg;\n \n type OptDynInitCfg<Ms, Mdl, INodes, GMs> =\n     Option<AppInitCfg<Ms, Mdl, INodes, GMs, dyn IntoAfterMount<Ms, Mdl, INodes, GMs>>>;\n \n /// Determines if an update should cause the `VDom` to rerender or not.\n pub enum ShouldRender {\n     Render,\n     ForceRenderNow,\n     Skip,\n }\n \n pub struct App<Ms, Mdl, INodes, GMs = UndefinedGMsg>\n where\n     Ms: 'static,\n     Mdl: 'static,\n     INodes: IntoNodes<Ms>,\n {\n     /// Temporary app configuration that is removed after app begins running.\n     pub init_cfg: OptDynInitCfg<Ms, Mdl, INodes, GMs>,\n     /// App configuration available for the entire application lifetime.\n     pub cfg: Rc<AppCfg<Ms, Mdl, INodes, GMs>>,\n     /// Mutable app state.\n     pub data: Rc<AppData<Ms, Mdl>>,\n }\n \n impl<Ms: 'static, Mdl: 'static, INodes: IntoNodes<Ms>, GMs> ::std::fmt::Debug\n     for App<Ms, Mdl, INodes, GMs>\n {\n     fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n         write!(f, \"App\")\n     }\n }\n \n impl<Ms, Mdl, INodes: IntoNodes<Ms>, GMs> Clone for App<Ms, Mdl, INodes, GMs> {\n     fn clone(&self) -> Self {\n         Self {\n             init_cfg: None,\n             cfg: Rc::clone(&self.cfg),\n             data: Rc::clone(&self.data),\n         }\n     }\n }\n \n /// We use a struct instead of series of functions, in order to avoid passing\n /// repetitive sequences of parameters.\n impl<Ms, Mdl, INodes: IntoNodes<Ms> + 'static, GMs: 'static> App<Ms, Mdl, INodes, GMs> {\n     // @TODO: Relax input function restrictions - init: fn => FnOnce, update & view: FnOnce + Clone.\n     // @TODO: Refactor while removing `Builder`.\n     /// Create, mount and start the `App`. It's the standard way to create a Seed app.\n     ///\n     /// _NOTE:_ It tries to hydrate the root element content => you can use it also for prerendered website.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     /// fn init(url: Url, orders: &mut impl Orders<Msg>) -> Model {\n     ///     orders\n     ///         .subscribe(Msg::UrlChanged)\n     ///         .notify(subs::UrlChanged(url));\n     ///\n     ///     Model {\n     ///         clicks: 0,\n     ///     }\n     /// }\n     ///\n     ///fn update(msg: Msg, model: &mut Model, _orders: &mut impl Orders<Msg>) {\n     ///   match msg {\n     ///       Msg::Clicked => model.clicks += 1,\n     ///   }\n     ///}\n     ///\n     ///fn view(model: &Model) -> impl IntoNodes<Msg> {\n     ///   button![\n     ///       format!(\"Clicked: {}\", model.clicks),\n     ///       ev(Ev::Click, |_| Msg::Clicked),\n     ///   ]\n     ///}\n     ///\n     ///#[wasm_bindgen(start)]\n     /// pub fn start() {\n     ///     // Mount to the root element with id \"app\".\n     ///     // You can pass also `web_sys::Element` or `web_sys::HtmlElement` as a root element.\n     ///     // It's NOT recommended to mount into body or into elements which contain scripts.\n     ///     App::start(\"app\", init, update, view);\n     /// }\n     /// ```\n     ///\n     /// # Panics\n     ///\n     /// Panics if the root element cannot be found.\n     ///\n     pub fn start(\n         root_element: impl GetElement,\n         init: impl FnOnce(Url, &mut OrdersContainer<Ms, Mdl, INodes, GMs>) -> Mdl + 'static,\n         update: UpdateFn<Ms, Mdl, INodes, GMs>,\n         view: ViewFn<Mdl, INodes>,\n     ) -> Self {\n         // @TODO: Remove as soon as Webkit is fixed and older browsers are no longer in use.\n         // https://github.com/seed-rs/seed/issues/241\n         // https://bugs.webkit.org/show_bug.cgi?id=202881\n         let _ = util::document().query_selector(\"html\");\n \n         // Allows panic messages to output to the browser console.error.\n         console_error_panic_hook::set_once();\n \n         let root_element = root_element.get_element().expect(\"get root element\");\n \n         let base_path: Rc<Vec<String>> = Rc::new(\n             util::document()\n                 .query_selector(\"base\")\n                 .expect(\"query element with 'base' tag\")\n                 .and_then(|element| element.get_attribute(\"href\"))\n                 .and_then(|href| web_sys::Url::new_with_base(&href, DUMMY_BASE_URL).ok())\n                 .map(|url| {\n                     url.pathname()\n                         .trim_start_matches('/')\n                         .split('/')\n                         .map(ToOwned::to_owned)\n                         .collect()\n                 })\n                 .unwrap_or_default(),\n         );\n \n         let app_init_cfg = AppInitCfg {\n             mount_type: MountType::Takeover,\n             phantom: PhantomData,\n             into_after_mount: Box::new({\n                 let base_path = Rc::clone(&base_path);\n                 move |url: Url,\n                       orders: &mut OrdersContainer<Ms, Mdl, INodes, GMs>|\n                       -> AfterMount<Mdl> {\n                     let url = url.skip_base_path(&base_path);\n                     let model = init(url, orders);\n                     AfterMount::new(model).url_handling(UrlHandling::None)\n                 }\n             }) as Box<dyn IntoAfterMount<Ms, Mdl, INodes, GMs>>,\n         };\n         let app = Self::new(\n             update,\n             None,\n             view,\n             root_element,\n             None,\n             None,\n             Some(app_init_cfg),\n             base_path,\n         );\n         app.run()\n     }\n \n     /// Creates a new `AppBuilder` instance. It's the standard way to create a Seed app.\n     ///\n     /// Then you can call optional builder methods like `routes` or `sink`.\n     /// And you have to call method `build_and_start` to build and run a new `App` instance.\n     ///\n     /// _NOTE:_ If your `Model` doesn't implement `Default`, you have to call builder method `after_mount`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///fn update(msg: Msg, model: &mut Model, _orders: &mut impl Orders<Msg, GMsg>) {\n     ///   match msg {\n     ///       Msg::Clicked => model.clicks += 1,\n     ///   }\n     ///}\n     ///\n     ///fn view(model: &Model) -> impl IntoNodes<Msg> {\n     ///   vec![\n     ///       button![\n     ///           format!(\"Clicked: {}\", model.clicks),\n     ///           simple_ev(Ev::Click, Msg::Clicked),\n     ///       ],\n     ///   ]\n     ///}\n     ///\n     ///App::builder(update, view)\n     /// ```\n     pub fn builder(\n         update: UpdateFn<Ms, Mdl, INodes, GMs>,\n         view: ViewFn<Mdl, INodes>,\n     ) -> AppBuilder<Ms, Mdl, INodes, GMs, UndefinedInitAPI> {\n         // @TODO: Remove as soon as Webkit is fixed and older browsers are no longer in use.\n         // https://github.com/David-OConnor/seed/issues/241\n         // https://bugs.webkit.org/show_bug.cgi?id=202881\n         let _ = util::document().query_selector(\"html\");\n \n         // Allows panic messages to output to the browser console.error.\n         console_error_panic_hook::set_once();\n \n         AppBuilder::new(update, view)\n     }\n \n     /// This runs whenever the state is changed, ie the user-written update function is called.\n     /// It updates the state, and any DOM elements affected by this change.\n     /// todo this is where we need to compare against differences and only update nodes affected\n     /// by the state change.\n     ///\n     /// We re-create the whole virtual dom each time (Is there a way around this? Probably not without\n     /// knowing what vars the model holds ahead of time), but only edit the rendered, `web_sys` dom\n     /// for things that have been changed.\n     /// We re-render the virtual DOM on every change, but (attempt to) only change\n     /// the actual DOM, via `web_sys`, when we need.\n     /// The model stored in inner is the old model; `updated_model` is a newly-calculated one.\n     pub fn update(&self, message: Ms) {\n         let mut queue: VecDeque<Effect<Ms, GMs>> = VecDeque::new();\n         queue.push_front(message.into());\n         self.process_effect_queue(queue);\n     }\n \n     pub fn notify<SubMs: 'static + Any + Clone>(&self, message: SubMs) {\n         let mut queue: VecDeque<Effect<Ms, GMs>> = VecDeque::new();\n         queue.push_front(Effect::Notification(Notification::new(message)));\n         self.process_effect_queue(queue);\n     }\n \n     pub fn notify_with_notification(&self, notification: Notification) {\n         let mut queue: VecDeque<Effect<Ms, GMs>> = VecDeque::new();\n         queue.push_front(Effect::Notification(notification));\n         self.process_effect_queue(queue);\n     }\n \n     pub fn sink(&self, g_msg: GMs) {\n         let mut queue: VecDeque<Effect<Ms, GMs>> = VecDeque::new();\n         queue.push_front(Effect::GMsg(g_msg));\n         self.process_effect_queue(queue);\n     }\n \n     pub fn process_effect_queue(&self, mut queue: VecDeque<Effect<Ms, GMs>>) {\n         while let Some(effect) = queue.pop_front() {\n             match effect {\n                 Effect::Msg(msg) => {\n                     let mut new_effects = self.process_queue_message(msg);\n                     queue.append(&mut new_effects);\n                 }\n                 Effect::GMsg(g_msg) => {\n                     let mut new_effects = self.process_queue_global_message(g_msg);\n                     queue.append(&mut new_effects);\n                 }\n                 Effect::Notification(notification) => {\n                     let mut new_effects = self.process_queue_notification(&notification);\n                     queue.append(&mut new_effects);\n                 }\n             }\n         }\n     }\n \n     pub fn patch_window_event_handlers(&self) {\n         if let Some(window_events) = self.cfg.window_events {\n             let new_event_handlers = (window_events)(self.data.model.borrow().as_ref().unwrap());\n             let new_manager = EventHandlerManager::with_event_handlers(new_event_handlers);\n \n             let mut old_manager = self.data.window_event_handler_manager.replace(new_manager);\n             let mut new_manager = self.data.window_event_handler_manager.borrow_mut();\n \n             new_manager.attach_listeners(util::window(), Some(&mut old_manager), &self.mailbox());\n         }\n     }\n \n     pub fn add_message_listener<F>(&self, listener: F)\n     where\n         F: Fn(&Ms) + 'static,\n     {\n         self.data\n             .msg_listeners\n             .borrow_mut()\n             .push(Box::new(listener));\n     }\n \n     #[allow(clippy::too_many_arguments)]\n     pub(super) fn new(\n         update: UpdateFn<Ms, Mdl, INodes, GMs>,\n         sink: Option<SinkFn<Ms, Mdl, INodes, GMs>>,\n         view: ViewFn<Mdl, INodes>,\n         mount_point: Element,\n         routes: Option<RoutesFn<Ms>>,\n         window_events: Option<WindowEventsFn<Ms, Mdl>>,\n         init_cfg: OptDynInitCfg<Ms, Mdl, INodes, GMs>,\n         base_path: Rc<Vec<String>>,\n     ) -> Self {\n         let window = util::window();\n         let document = window.document().expect(\"get window's document\");\n \n         Self {\n             init_cfg,\n             cfg: Rc::new(AppCfg {\n                 document,\n                 mount_point,\n                 update,\n                 sink,\n                 view,\n                 window_events,\n                 base_path,\n             }),\n             data: Rc::new(AppData {\n                 model: RefCell::new(None),\n                 // This is filled for the first time in run()\n                 main_el_vdom: RefCell::new(None),\n                 popstate_closure: RefCell::new(None),\n                 hashchange_closure: RefCell::new(None),\n                 routes: RefCell::new(routes),\n                 window_event_handler_manager: RefCell::new(EventHandlerManager::new()),\n                 sub_manager: RefCell::new(SubManager::new()),\n                 msg_listeners: RefCell::new(Vec::new()),\n                 scheduled_render_handle: RefCell::new(None),\n                 after_next_render_callbacks: RefCell::new(Vec::new()),\n-                render_timestamp: Cell::new(None),\n+                render_info: Cell::new(None),\n             }),\n         }\n     }\n \n     /// Bootstrap the dom with the vdom by taking over all children of the mount point and\n     /// replacing them with the vdom if requested. Will otherwise ignore the original children of\n     /// the mount point.\n     fn bootstrap_vdom(&self, mount_type: MountType) -> El<Ms> {\n         // \"new\" name is for consistency with `update` function.\n         // this section parent is a placeholder, so we can iterate over children\n         // in a way consistent with patching code.\n         let mut new = El::empty(Tag::Placeholder);\n \n         // Map the DOM's elements onto the virtual DOM if requested to takeover.\n         if mount_type == MountType::Takeover {\n             // Construct a vdom from the root element. Subsequently strip the workspace so that we\n             // can recreate it later - this is a kind of simple way to avoid missing nodes (but\n             // not entirely correct).\n             // TODO: 1) Please refer to [issue #277](https://github.com/seed-rs/seed/issues/277)\n             let mut dom_nodes: El<Ms> = (&self.cfg.mount_point).into();\n             #[cfg(debug_assertions)]\n             dom_nodes.warn_about_script_tags();\n \n             dom_nodes.strip_ws_nodes_from_self_and_children();\n \n             // Replace the root dom with a placeholder tag and move the children from the root element\n             // to the newly created root. Uses `Placeholder` to mimic update logic.\n             new.children = dom_nodes.children;\n         }\n \n         // Recreate the needed nodes. Only do this if requested to takeover the mount point since\n         // it should only be needed here.\n         if mount_type == MountType::Takeover {\n             // TODO: Please refer to [issue #277](https://github.com/seed-rs/seed/issues/277)\n             virtual_dom_bridge::assign_ws_nodes_to_el(&util::document(), &mut new);\n \n             // Remove all old elements. We'll swap them out with the newly created elements later.\n             // This maneuver will effectively allow us to remove everything in the mount and thus\n             // takeover the mount point.\n             while let Some(child) = self.cfg.mount_point.first_child() {\n                 self.cfg\n                     .mount_point\n                     .remove_child(&child)\n                     .expect(\"No problem removing node from parent.\");\n             }\n \n             // Attach all top-level elements to the mount point if present. This means that we have\n             // effectively taken full control of everything within the mounting element.\n             for child in &mut new.children {\n                 match child {\n                     Node::Element(child_el) => {\n                         virtual_dom_bridge::attach_el_and_children(\n                             child_el,\n                             &self.cfg.mount_point,\n                             &self.mailbox(),\n                         );\n                     }\n                     Node::Text(top_child_text) => {\n                         virtual_dom_bridge::attach_text_node(top_child_text, &self.cfg.mount_point);\n                     }\n                     Node::Empty => (),\n                 }\n             }\n         }\n \n         new\n     }\n \n     fn process_queue_notification(&self, notification: &Notification) -> VecDeque<Effect<Ms, GMs>> {\n         self.data\n             .sub_manager\n             .borrow()\n             .notify(notification)\n             .into_iter()\n             .map(Effect::Msg)\n             .collect()\n     }\n \n     fn process_queue_message(&self, message: Ms) -> VecDeque<Effect<Ms, GMs>> {\n         for l in self.data.msg_listeners.borrow().iter() {\n             (l)(&message)\n         }\n \n         let mut orders = OrdersContainer::new(self.clone());\n         (self.cfg.update)(\n             message,\n             &mut self.data.model.borrow_mut().as_mut().unwrap(),\n             &mut orders,\n         );\n \n         self.patch_window_event_handlers();\n \n         match orders.should_render {\n             ShouldRender::Render => self.schedule_render(),\n             ShouldRender::ForceRenderNow => {\n                 self.cancel_scheduled_render();\n                 self.rerender_vdom();\n             }\n             ShouldRender::Skip => (),\n         };\n         orders.effects\n     }\n \n     fn process_queue_global_message(&self, g_message: GMs) -> VecDeque<Effect<Ms, GMs>> {\n         let mut orders = OrdersContainer::new(self.clone());\n \n         if let Some(sink) = self.cfg.sink {\n             sink(\n                 g_message,\n                 &mut self.data.model.borrow_mut().as_mut().unwrap(),\n                 &mut orders,\n             );\n         }\n \n         self.patch_window_event_handlers();\n \n         match orders.should_render {\n             ShouldRender::Render => self.schedule_render(),\n             ShouldRender::ForceRenderNow => {\n                 self.cancel_scheduled_render();\n                 self.rerender_vdom();\n             }\n             ShouldRender::Skip => (),\n         };\n         orders.effects\n     }\n \n     fn schedule_render(&self) {\n         let mut scheduled_render_handle = self.data.scheduled_render_handle.borrow_mut();\n \n         if scheduled_render_handle.is_none() {\n             let cb = Closure::new(enclose!((self => s) move |_| {\n                 s.data.scheduled_render_handle.borrow_mut().take();\n                 s.rerender_vdom();\n             }));\n \n             *scheduled_render_handle = Some(util::request_animation_frame(cb));\n         }\n     }\n \n     fn cancel_scheduled_render(&self) {\n         // Cancel animation frame request by dropping it.\n         self.data.scheduled_render_handle.borrow_mut().take();\n     }\n \n     fn rerender_vdom(&self) {\n         let new_render_timestamp = window().performance().expect(\"get `Performance`\").now();\n \n         // Create a new vdom: The top element, and all its children. Does not yet\n         // have associated web_sys elements.\n         let mut new = El::empty(Tag::Placeholder);\n         new.children = (self.cfg.view)(self.data.model.borrow().as_ref().unwrap()).into_nodes();\n \n         let old = self\n             .data\n             .main_el_vdom\n             .borrow_mut()\n             .take()\n             .expect(\"missing main_el_vdom\");\n \n         patch::patch_els(\n             &self.cfg.document,\n             &self.mailbox(),\n             &self.clone(),\n             &self.cfg.mount_point,\n             old.children.into_iter(),\n             new.children.iter_mut(),\n         );\n \n         // Now that we've re-rendered, replace our stored El with the new one;\n         // it will be used as the old El next time.\n         self.data.main_el_vdom.borrow_mut().replace(new);\n \n         // Execute `after_next_render_callbacks`.\n \n-        let old_render_timestamp = self\n-            .data\n-            .render_timestamp\n-            .replace(Some(new_render_timestamp));\n-\n-        let timestamp_delta = old_render_timestamp.map(|old_render_timestamp| {\n-            RenderTimestampDelta::new(new_render_timestamp - old_render_timestamp)\n-        });\n+        let render_info = match self.data.render_info.take() {\n+            Some(old_render_info) => RenderInfo {\n+                timestamp: new_render_timestamp,\n+                timestamp_delta: Some(new_render_timestamp - old_render_info.timestamp),\n+            },\n+            None => RenderInfo {\n+                timestamp: new_render_timestamp,\n+                timestamp_delta: None,\n+            },\n+        };\n+        self.data.render_info.set(Some(render_info));\n \n         self.process_effect_queue(\n             self.data\n                 .after_next_render_callbacks\n                 .replace(Vec::new())\n                 .into_iter()\n-                .filter_map(|callback| callback(timestamp_delta).map(Effect::Msg))\n+                .filter_map(|callback| callback(render_info).map(Effect::Msg))\n                 .collect(),\n         );\n     }\n \n     fn mailbox(&self) -> Mailbox<Ms> {\n         Mailbox::new(enclose!((self => s) move |option_message| {\n             if let Some(message) = option_message {\n                 s.update(message);\n             } else {\n                 s.rerender_vdom();\n             }\n         }))\n     }\n \n     #[deprecated(\n         since = \"0.5.0\",\n         note = \"Use `builder` with `AppBuilder::{after_mount, before_mount}` instead.\"\n     )]\n     pub fn build(\n         init: impl FnOnce(Url, &mut OrdersContainer<Ms, Mdl, INodes, GMs>) -> Init<Mdl> + 'static,\n         update: UpdateFn<Ms, Mdl, INodes, GMs>,\n         view: ViewFn<Mdl, INodes>,\n     ) -> InitAppBuilder<Ms, Mdl, INodes, GMs> {\n         Self::builder(update, view).init(Box::new(init))\n     }\n \n     /// App initialization: Collect its fundamental components, setup, and perform\n     /// an initial render.\n     #[deprecated(\n         since = \"0.4.2\",\n         note = \"Please use `AppBuilder.build_and_start` instead\"\n     )]\n     pub fn run(mut self) -> Self {\n         let AppInitCfg {\n             mount_type,\n             into_after_mount,\n             ..\n         } = self.init_cfg.take().expect(\n             \"`init_cfg` should be set in `App::new` which is called from `AppBuilder::build_and_start`\",\n         );\n \n         // Bootstrap the virtual DOM.\n         self.data\n             .main_el_vdom\n             .replace(Some(self.bootstrap_vdom(mount_type)));\n \n         let mut orders = OrdersContainer::new(self.clone());\n         let AfterMount {\n             model,\n             url_handling,\n         } = into_after_mount.into_after_mount(Url::current(), &mut orders);\n \n         self.data.model.replace(Some(model));\n \n         match url_handling {\n             UrlHandling::PassToRoutes => {\n                 let url = Url::current();\n \n                 self.notify(subs::UrlChanged(url.clone()));\n \n                 let routing_msg = self\n                     .data\n                     .routes\n                     .borrow()\n                     .as_ref()\n                     .and_then(|routes| routes(url));\n                 if let Some(routing_msg) = routing_msg {\n                     orders.effects.push_back(routing_msg.into());\n                 }\n             }\n             UrlHandling::None => (),\n         };\n \n         self.patch_window_event_handlers();\n \n         // Update the state on page load, based\n         // on the starting URL. Must be set up on the server as well.\n         let routes = *self.data.routes.borrow();\n         routing::setup_popstate_listener(\n             enc!((self => s) move |msg| s.update(msg)),\n             enc!((self => s) move |closure| {\n                 s.data.popstate_closure.replace(Some(closure));\n             }),\n             enc!((self => s) move |notification| s.notify_with_notification(notification)),\n             routes,\n             Rc::clone(&self.cfg.base_path),\n         );\n         routing::setup_hashchange_listener(\n             enc!((self => s) move |msg| s.update(msg)),\n             enc!((self => s) move |closure| {\n                 s.data.hashchange_closure.replace(Some(closure));\n             }),\n             enc!((self => s) move |notification| s.notify_with_notification(notification)),\n             routes,\n             Rc::clone(&self.cfg.base_path),\n         );\n         routing::setup_link_listener(\n             enc!((self => s) move |msg| s.update(msg)),\n             enc!((self => s) move |notification| s.notify_with_notification(notification)),\n             routes,\n         );\n \n         orders.subscribe(enc!((self => s) move |url_requested| {\n             routing::url_request_handler(\n                 url_requested,\n                 Rc::clone(&s.cfg.base_path),\n                 move |notification| s.notify_with_notification(notification),\n             )\n         }));\n \n         self.process_effect_queue(orders.effects);\n         // TODO: In the future, only run the following line if the above statement:\n         //  - didn't force-rerender vdom\n         //  - didn't schedule render\n         //  - doesn't want to skip render\n \n         self.rerender_vdom();\n \n         self\n     }\n }\n \n #[deprecated(since = \"0.5.0\", note = \"Part of the old Init API.\")]\n type InitAppBuilder<Ms, Mdl, INodes, GMs> = AppBuilder<\n     Ms,\n     Mdl,\n     INodes,\n     GMs,\n     MountPointInitInitAPI<UndefinedMountPoint, BuilderInitFn<Ms, Mdl, INodes, GMs>>,\n >;\ndiff --git a/src/app/builder.rs b/src/app/builder.rs\nindex d1345e3..33f3bdf 100644\n--- a/src/app/builder.rs\n+++ b/src/app/builder.rs\n@@ -1,586 +1,587 @@\n-use super::{types::*, App, AppInitCfg, OrdersContainer};\n+use super::types::{RoutesFn, SinkFn, UpdateFn, ViewFn, WindowEventsFn};\n+use super::{App, AppInitCfg, OrdersContainer};\n use crate::browser::Url;\n use crate::virtual_dom::IntoNodes;\n use std::marker::PhantomData;\n use std::rc::Rc;\n \n pub mod after_mount;\n pub mod before_mount;\n pub mod init;\n \n pub use after_mount::{AfterMount, IntoAfterMount, UndefinedAfterMount, UrlHandling};\n pub use before_mount::{BeforeMount, MountPoint, MountType, UndefinedMountPoint};\n pub use init::{IntoInit, UndefinedInitAPI, UndefinedIntoInit};\n \n #[deprecated(\n     since = \"0.5.0\",\n     note = \"Used for compatibility with old Init API. Use `BeforeAfterInitAPI` together with `BeforeMount` and `AfterMount` instead.\"\n )]\n pub struct MountPointInitInitAPI<MP, II> {\n     mount_point: MP,\n     into_init: II,\n }\n // TODO Remove when removing the other `InitAPI`s.\n pub struct BeforeAfterInitAPI<IAM> {\n     before_mount_handler: Box<dyn FnOnce(Url) -> BeforeMount>,\n     into_after_mount: IAM,\n }\n // TODO Remove when removing the other `InitAPI`s.\n impl Default for BeforeAfterInitAPI<UndefinedAfterMount> {\n     fn default() -> Self {\n         BeforeAfterInitAPI {\n             before_mount_handler: Box::new(|_| BeforeMount::default()),\n             into_after_mount: UndefinedAfterMount,\n         }\n     }\n }\n \n // TODO Remove when removing the other `InitAPI`s.\n pub trait InitAPI<Ms: 'static, Mdl, INodes: IntoNodes<Ms>, GMs> {\n     type Builder;\n     fn build(builder: Self::Builder) -> App<Ms, Mdl, INodes, GMs>;\n }\n \n // TODO Remove when removing the other `InitAPI`s.\n pub trait InitAPIData {\n     type IntoAfterMount;\n     #[deprecated(\n         since = \"0.5.0\",\n         note = \"Used for compatibility with old Init API. Use `IntoBeforeMount` and `IntoAfterMount` instead.\"\n     )]\n     type IntoInit;\n     #[deprecated(\n         since = \"0.5.0\",\n         note = \"Used for compatibility with old Init API. Use `IntoBeforeMount` and `IntoAfterMount` instead.\"\n     )]\n     type MountPoint;\n \n     fn before_mount(\n         self,\n         before_mount_handler: Box<dyn FnOnce(Url) -> BeforeMount>,\n     ) -> BeforeAfterInitAPI<Self::IntoAfterMount>;\n     fn after_mount<\n         Ms: 'static,\n         Mdl,\n         INodes: IntoNodes<Ms>,\n         GMs,\n         NewIAM: IntoAfterMount<Ms, Mdl, INodes, GMs>,\n     >(\n         self,\n         into_after_mount: NewIAM,\n     ) -> BeforeAfterInitAPI<NewIAM>;\n \n     #[deprecated(\n         since = \"0.5.0\",\n         note = \"Used for compatibility with old Init API. Use `before_mount` and `after_mount` instead.\"\n     )]\n     fn init<Ms: 'static, Mdl, INodes: IntoNodes<Ms>, GMs, NewII: IntoInit<Ms, Mdl, INodes, GMs>>(\n         self,\n         into_init: NewII,\n     ) -> MountPointInitInitAPI<Self::MountPoint, NewII>;\n     #[deprecated(\n         since = \"0.5.0\",\n         note = \"Used for compatibility with old Init API. Use `before_mount` and `after_mount` instead.\"\n     )]\n     fn mount<NewMP: MountPoint>(\n         self,\n         mount_point: NewMP,\n     ) -> MountPointInitInitAPI<NewMP, Self::IntoInit>;\n }\n \n // TODO Remove when removing the other `InitAPI`s.\n #[deprecated(\n     since = \"0.5.0\",\n     note = \"Used for compatibility with old Init API. Use `BeforeAfterInitAPI` together with `BeforeMount` and `AfterMount` instead.\"\n )]\n impl<\n         Ms: 'static,\n         Mdl: 'static,\n         INodes: 'static + IntoNodes<Ms>,\n         GMs: 'static,\n         MP: MountPoint,\n         II: IntoInit<Ms, Mdl, INodes, GMs>,\n     > InitAPI<Ms, Mdl, INodes, GMs> for MountPointInitInitAPI<MP, II>\n {\n     type Builder = Builder<Ms, Mdl, INodes, GMs, Self>;\n     fn build(builder: Self::Builder) -> App<Ms, Mdl, INodes, GMs> {\n         let MountPointInitInitAPI {\n             into_init,\n             mount_point,\n         } = builder.init_api;\n \n         let mut app = App::new(\n             builder.update,\n             builder.sink,\n             builder.view,\n             mount_point.element_getter()(),\n             builder.routes,\n             builder.window_events,\n             None,\n             Rc::new(Vec::new()),\n         );\n \n         let mut initial_orders = OrdersContainer::new(app.clone());\n         let init = into_init.into_init(Url::current(), &mut initial_orders);\n \n         app.init_cfg.replace(AppInitCfg {\n             mount_type: init.mount_type,\n             into_after_mount: Box::new((init, initial_orders)),\n             phantom: PhantomData,\n         });\n \n         app\n     }\n }\n // TODO Remove when removing the other `InitAPI`s.\n impl<\n         Ms: 'static,\n         Mdl: 'static,\n         INodes: 'static + IntoNodes<Ms>,\n         GMs: 'static,\n         IAM: 'static + IntoAfterMount<Ms, Mdl, INodes, GMs>,\n     > InitAPI<Ms, Mdl, INodes, GMs> for BeforeAfterInitAPI<IAM>\n {\n     type Builder = Builder<Ms, Mdl, INodes, GMs, Self>;\n     fn build(builder: Self::Builder) -> App<Ms, Mdl, INodes, GMs> {\n         let BeforeAfterInitAPI {\n             before_mount_handler,\n             into_after_mount,\n         } = builder.init_api;\n \n         let BeforeMount {\n             mount_point_getter,\n             mount_type,\n         } = before_mount_handler(Url::current());\n \n         App::new(\n             builder.update,\n             builder.sink,\n             builder.view,\n             mount_point_getter(),\n             builder.routes,\n             builder.window_events,\n             Some(AppInitCfg {\n                 mount_type,\n                 into_after_mount: Box::new(into_after_mount),\n                 phantom: PhantomData,\n             }),\n             Rc::new(Vec::new()),\n         )\n     }\n }\n // TODO Remove when removing the other `InitAPI`s.\n impl<Ms: 'static, Mdl: 'static + Default, INodes: 'static + IntoNodes<Ms>, GMs: 'static>\n     InitAPI<Ms, Mdl, INodes, GMs> for UndefinedInitAPI\n {\n     type Builder = Builder<Ms, Mdl, INodes, GMs, Self>;\n     fn build(builder: Self::Builder) -> App<Ms, Mdl, INodes, GMs> {\n         BeforeAfterInitAPI::build(Builder {\n             update: builder.update,\n             view: builder.view,\n \n             routes: builder.routes,\n             window_events: builder.window_events,\n             sink: builder.sink,\n \n             init_api: BeforeAfterInitAPI::default(),\n         })\n     }\n }\n \n #[deprecated(\n     since = \"0.5.0\",\n     note = \"Used for compatibility with old Init API. Use `BeforeAfterInitAPI` together with `BeforeMount` and `AfterMount` instead.\"\n )]\n impl<MP, II> InitAPIData for MountPointInitInitAPI<MP, II> {\n     type IntoAfterMount = UndefinedAfterMount;\n     type IntoInit = II;\n     type MountPoint = MP;\n \n     fn before_mount(\n         self,\n         before_mount_handler: Box<dyn FnOnce(Url) -> BeforeMount>,\n     ) -> BeforeAfterInitAPI<Self::IntoAfterMount> {\n         BeforeAfterInitAPI {\n             before_mount_handler,\n             into_after_mount: UndefinedAfterMount,\n         }\n     }\n     fn after_mount<\n         Ms: 'static,\n         Mdl,\n         INodes: IntoNodes<Ms>,\n         GMs,\n         NewIAM: IntoAfterMount<Ms, Mdl, INodes, GMs>,\n     >(\n         self,\n         into_after_mount: NewIAM,\n     ) -> BeforeAfterInitAPI<NewIAM> {\n         BeforeAfterInitAPI {\n             into_after_mount,\n             before_mount_handler: Box::new(|_| BeforeMount::default()),\n         }\n     }\n \n     fn init<Ms: 'static, Mdl, INodes: IntoNodes<Ms>, GMs, NewII: IntoInit<Ms, Mdl, INodes, GMs>>(\n         self,\n         into_init: NewII,\n     ) -> MountPointInitInitAPI<Self::MountPoint, NewII> {\n         MountPointInitInitAPI {\n             into_init,\n             mount_point: self.mount_point,\n         }\n     }\n     fn mount<NewMP: MountPoint>(\n         self,\n         mount_point: NewMP,\n     ) -> MountPointInitInitAPI<NewMP, Self::IntoInit> {\n         MountPointInitInitAPI {\n             mount_point,\n             into_init: self.into_init,\n         }\n     }\n }\n // TODO Remove when removing the other `InitAPI`s.\n impl<IAM> InitAPIData for BeforeAfterInitAPI<IAM> {\n     type IntoAfterMount = IAM;\n     type IntoInit = UndefinedIntoInit;\n     type MountPoint = UndefinedMountPoint;\n \n     fn before_mount(\n         self,\n         before_mount_handler: Box<dyn FnOnce(Url) -> BeforeMount>,\n     ) -> BeforeAfterInitAPI<Self::IntoAfterMount> {\n         BeforeAfterInitAPI {\n             before_mount_handler,\n             into_after_mount: self.into_after_mount,\n         }\n     }\n     fn after_mount<\n         Ms: 'static,\n         Mdl,\n         INodes: IntoNodes<Ms>,\n         GMs,\n         NewIAM: IntoAfterMount<Ms, Mdl, INodes, GMs>,\n     >(\n         self,\n         into_after_mount: NewIAM,\n     ) -> BeforeAfterInitAPI<NewIAM> {\n         BeforeAfterInitAPI {\n             into_after_mount,\n             before_mount_handler: self.before_mount_handler,\n         }\n     }\n \n     fn init<Ms: 'static, Mdl, INodes: IntoNodes<Ms>, GMs, NewII: IntoInit<Ms, Mdl, INodes, GMs>>(\n         self,\n         into_init: NewII,\n     ) -> MountPointInitInitAPI<Self::MountPoint, NewII> {\n         MountPointInitInitAPI {\n             into_init,\n             mount_point: UndefinedMountPoint,\n         }\n     }\n     fn mount<NewMP: MountPoint>(\n         self,\n         mount_point: NewMP,\n     ) -> MountPointInitInitAPI<NewMP, Self::IntoInit> {\n         MountPointInitInitAPI {\n             mount_point,\n             into_init: UndefinedIntoInit,\n         }\n     }\n }\n // TODO Remove when removing the other `InitAPI`s.\n impl InitAPIData for UndefinedInitAPI {\n     type IntoAfterMount = UndefinedAfterMount;\n     type IntoInit = UndefinedIntoInit;\n     type MountPoint = UndefinedMountPoint;\n \n     fn before_mount(\n         self,\n         before_mount_handler: Box<dyn FnOnce(Url) -> BeforeMount>,\n     ) -> BeforeAfterInitAPI<Self::IntoAfterMount> {\n         BeforeAfterInitAPI {\n             before_mount_handler,\n             into_after_mount: UndefinedAfterMount,\n         }\n     }\n     fn after_mount<\n         Ms: 'static,\n         Mdl,\n         INodes: IntoNodes<Ms>,\n         GMs,\n         NewIAM: IntoAfterMount<Ms, Mdl, INodes, GMs>,\n     >(\n         self,\n         into_after_mount: NewIAM,\n     ) -> BeforeAfterInitAPI<NewIAM> {\n         BeforeAfterInitAPI {\n             into_after_mount,\n             before_mount_handler: Box::new(|_| BeforeMount::default()),\n         }\n     }\n \n     fn init<Ms: 'static, Mdl, INodes: IntoNodes<Ms>, GMs, NewII: IntoInit<Ms, Mdl, INodes, GMs>>(\n         self,\n         into_init: NewII,\n     ) -> MountPointInitInitAPI<Self::MountPoint, NewII> {\n         MountPointInitInitAPI {\n             into_init,\n             mount_point: UndefinedMountPoint,\n         }\n     }\n     fn mount<NewMP: MountPoint>(\n         self,\n         mount_point: NewMP,\n     ) -> MountPointInitInitAPI<NewMP, Self::IntoInit> {\n         MountPointInitInitAPI {\n             mount_point,\n             into_init: UndefinedIntoInit,\n         }\n     }\n }\n \n /// Used to create and store initial app configuration, ie items passed by the app creator.\n pub struct Builder<Ms: 'static, Mdl: 'static, INodes: IntoNodes<Ms>, GMs, InitAPIType> {\n     update: UpdateFn<Ms, Mdl, INodes, GMs>,\n     view: ViewFn<Mdl, INodes>,\n \n     routes: Option<RoutesFn<Ms>>,\n     window_events: Option<WindowEventsFn<Ms, Mdl>>,\n     sink: Option<SinkFn<Ms, Mdl, INodes, GMs>>,\n \n     // TODO: Remove when removing legacy init fields.\n     init_api: InitAPIType,\n }\n \n impl<Ms, Mdl, INodes: IntoNodes<Ms> + 'static, GMs: 'static>\n     Builder<Ms, Mdl, INodes, GMs, UndefinedInitAPI>\n {\n     /// Constructs the Builder.\n     pub(super) fn new(update: UpdateFn<Ms, Mdl, INodes, GMs>, view: ViewFn<Mdl, INodes>) -> Self {\n         Builder {\n             update,\n             view,\n \n             routes: None,\n             window_events: None,\n             sink: None,\n \n             init_api: UndefinedInitAPI,\n         }\n     }\n }\n \n impl<\n         Ms,\n         Mdl,\n         INodes: IntoNodes<Ms> + 'static,\n         GMs: 'static,\n         IAM: 'static,\n         MP,\n         II,\n         InitAPIType: InitAPIData<IntoInit = II, MountPoint = MP, IntoAfterMount = IAM>,\n     > Builder<Ms, Mdl, INodes, GMs, InitAPIType>\n {\n     #[deprecated(\n         since = \"0.5.0\",\n         note = \"Used for compatibility with old Init API. Use `before_mount` and `after_mount` instead.\"\n     )]\n     pub fn init<NewII: IntoInit<Ms, Mdl, INodes, GMs>>(\n         self,\n         new_init: NewII,\n     ) -> Builder<Ms, Mdl, INodes, GMs, MountPointInitInitAPI<MP, NewII>> {\n         Builder {\n             update: self.update,\n             view: self.view,\n \n             routes: self.routes,\n             window_events: self.window_events,\n             sink: self.sink,\n \n             init_api: self.init_api.init(new_init),\n         }\n     }\n \n     /// Choose the element where the application will be mounted.\n     /// The default one is the element with `id` = \"app\".\n     ///\n     /// # Examples\n     ///\n     /// ```rust,no_run\n     /// // argument is `&str`\n     /// mount(\"another_id\")\n     ///\n     /// // argument is `HTMLElement`\n     /// // NOTE: Be careful with mounting into body,\n     /// // it can cause hard-to-debug bugs when there are other scripts in the body.\n     /// mount(seed::body())\n     ///\n     /// // argument is `Element`\n     /// mount(seed::body().querySelector(\"section\").unwrap().unwrap())\n     /// ```\n     #[deprecated(\n         since = \"0.5.0\",\n         note = \"Used for compatibility with old Init API. Use `before_mount` and `after_mount` instead.\"\n     )]\n     pub fn mount<NewMP: MountPoint>(\n         self,\n         new_mount_point: NewMP,\n     ) -> Builder<Ms, Mdl, INodes, GMs, MountPointInitInitAPI<NewMP, II>> {\n         Builder {\n             update: self.update,\n             view: self.view,\n \n             routes: self.routes,\n             window_events: self.window_events,\n             sink: self.sink,\n \n             init_api: self.init_api.mount(new_mount_point),\n         }\n     }\n \n     /// Select HTML element where the app will be mounted and how it'll be mounted.\n     ///\n     /// See `BeforeMount::mount_point` and `BeforeMount::mount_type` docs for more info.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///fn before_mount(_url: Url) -> BeforeMount {\n     ///    BeforeMount::new()\n     ///        .mount_point(\"main\")\n     ///        .mount_type(MountType::Takeover)\n     ///}\n     /// ```\n     pub fn before_mount(\n         self,\n         before_mount: impl FnOnce(Url) -> BeforeMount + 'static,\n     ) -> Builder<Ms, Mdl, INodes, GMs, BeforeAfterInitAPI<IAM>> {\n         Builder {\n             update: self.update,\n             view: self.view,\n \n             routes: self.routes,\n             window_events: self.window_events,\n             sink: self.sink,\n \n             init_api: self.init_api.before_mount(Box::new(before_mount)),\n         }\n     }\n \n     /// You can create your `Model` and handle initial URL in this method.\n     ///\n     /// See `AfterMount::url_handling` for more info about initial URL handling.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///fn after_mount(_url: Url, _orders: &mut impl Orders<Msg, GMsg>) -> AfterMount<Model> {\n     ///    let model = Model { clicks: 0 };\n     ///    AfterMount::new(model).url_handling(UrlHandling::None)\n     ///}\n     /// ```\n     pub fn after_mount<AM: 'static + IntoAfterMount<Ms, Mdl, INodes, GMs>>(\n         self,\n         after_mount: AM,\n     ) -> Builder<Ms, Mdl, INodes, GMs, BeforeAfterInitAPI<AM>> {\n         Builder {\n             update: self.update,\n             view: self.view,\n \n             routes: self.routes,\n             window_events: self.window_events,\n             sink: self.sink,\n \n             init_api: self.init_api.after_mount(after_mount),\n         }\n     }\n \n     /// Registers a function which maps URLs to messages.\n     ///\n     /// When you return `None`, Seed doesn't call your `update` function\n     /// and also doesn't push the new route or prevent page refresh.\n     /// It's useful if the user clicked on a link and Seed shouldn't intercept it,\n     /// because it's e.g. a download link.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///fn routes(url: Url) -> Option<Msg> {\n     ///    Some(Msg::UrlChanged(url))\n     ///}\n     /// ```\n     pub fn routes(mut self, routes: RoutesFn<Ms>) -> Self {\n         self.routes = Some(routes);\n         self\n     }\n \n     /// Registers a function which decides how window events will be handled.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///fn window_events(_model: &Model) -> Vec<Listener<Msg>> {\n     ///    vec![keyboard_ev(Ev::KeyDown, Msg::KeyPressed)]\n     ///}\n     /// ```\n     pub fn window_events(mut self, window_events: WindowEventsFn<Ms, Mdl>) -> Self {\n         self.window_events = Some(window_events);\n         self\n     }\n \n     /// Registers a sink function.\n     ///\n     /// The sink function is a function which can update the model based\n     /// on global messages. Consider to use a sink function when a\n     /// submodule needs to trigger changes in other modules.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///fn sink(g_msg: GMsg, _model: &mut Model, _orders: &mut impl Orders<Msg, GMsg>) {\n     ///    match g_msg {\n     ///        GMsg::SayHello => log!(\"Hello!\"),\n     ///    }\n     ///}\n     /// ```\n     pub fn sink(mut self, sink: SinkFn<Ms, Mdl, INodes, GMs>) -> Self {\n         self.sink = Some(sink);\n         self\n     }\n }\n \n impl<\n         Ms: 'static,\n         Mdl,\n         INodes: IntoNodes<Ms> + 'static,\n         GMs: 'static,\n         InitAPIType: InitAPI<Ms, Mdl, INodes, GMs, Builder = Self>,\n     > Builder<Ms, Mdl, INodes, GMs, InitAPIType>\n {\n     /// Build, mount and start the app.\n     pub fn build_and_start(self) -> App<Ms, Mdl, INodes, GMs> {\n         InitAPIType::build(self).run()\n     }\n }\n \n impl<\n         Ms: 'static,\n         Mdl,\n         INodes: IntoNodes<Ms> + 'static,\n         GMs: 'static,\n         MP: MountPoint,\n         II: IntoInit<Ms, Mdl, INodes, GMs>,\n     > Builder<Ms, Mdl, INodes, GMs, MountPointInitInitAPI<MP, II>>\n {\n     /// Turn this [`Builder`] into an [`App`] which is ready to run.\n     ///\n     /// [`Builder`]: struct.Builder.html\n     /// [`App`]: struct.App.html\n     #[deprecated(since = \"0.4.2\", note = \"Please use `.build_and_start` instead\")]\n     pub fn finish(self) -> App<Ms, Mdl, INodes, GMs> {\n         MountPointInitInitAPI::build(self)\n     }\n }\ndiff --git a/src/app/cfg.rs b/src/app/cfg.rs\nindex f1cf288..a2b7d8c 100644\n--- a/src/app/cfg.rs\n+++ b/src/app/cfg.rs\n@@ -1,33 +1,34 @@\n-use super::{builder::IntoAfterMount, types::*, MountType};\n+use super::types::{SinkFn, UpdateFn, ViewFn, WindowEventsFn};\n+use super::{builder::IntoAfterMount, MountType};\n use crate::virtual_dom::IntoNodes;\n use std::marker::PhantomData;\n use std::rc::Rc;\n \n #[allow(clippy::module_name_repetitions)]\n pub struct AppInitCfg<Ms, Mdl, INodes, GMs, IAM: ?Sized>\n where\n     Ms: 'static,\n     Mdl: 'static,\n     INodes: IntoNodes<Ms>,\n     IAM: IntoAfterMount<Ms, Mdl, INodes, GMs>,\n {\n     pub mount_type: MountType,\n     pub into_after_mount: Box<IAM>,\n     pub phantom: PhantomData<(Ms, Mdl, INodes, GMs)>,\n }\n \n #[allow(clippy::module_name_repetitions)]\n pub struct AppCfg<Ms, Mdl, INodes, GMs>\n where\n     Ms: 'static,\n     Mdl: 'static,\n     INodes: IntoNodes<Ms>,\n {\n     pub document: web_sys::Document,\n     pub mount_point: web_sys::Element,\n     pub update: UpdateFn<Ms, Mdl, INodes, GMs>,\n     pub sink: Option<SinkFn<Ms, Mdl, INodes, GMs>>,\n     pub view: ViewFn<Mdl, INodes>,\n     pub window_events: Option<WindowEventsFn<Ms, Mdl>>,\n     pub base_path: Rc<Vec<String>>,\n }\ndiff --git a/src/app/data.rs b/src/app/data.rs\nindex 2cd2a8c..a73bbe6 100644\n--- a/src/app/data.rs\n+++ b/src/app/data.rs\n@@ -1,25 +1,25 @@\n-use super::{render_timestamp_delta::RenderTimestamp, types::*, RenderTimestampDelta, SubManager};\n+use super::types::{MsgListeners, RoutesFn};\n+use super::{RenderInfo, SubManager};\n use crate::browser::util;\n use crate::virtual_dom::{El, EventHandlerManager};\n use std::cell::{Cell, RefCell};\n use wasm_bindgen::closure::Closure;\n \n type StoredPopstate = RefCell<Option<Closure<dyn FnMut(web_sys::Event)>>>;\n \n /// Used as part of an interior-mutability pattern, ie Rc<RefCell<>>\n #[allow(clippy::type_complexity, clippy::module_name_repetitions)]\n pub struct AppData<Ms: 'static, Mdl> {\n     // Model is in a RefCell here so we can modify it in self.update().\n     pub model: RefCell<Option<Mdl>>,\n     pub main_el_vdom: RefCell<Option<El<Ms>>>,\n     pub popstate_closure: StoredPopstate,\n     pub hashchange_closure: StoredPopstate,\n     pub routes: RefCell<Option<RoutesFn<Ms>>>,\n     pub window_event_handler_manager: RefCell<EventHandlerManager<Ms>>,\n     pub sub_manager: RefCell<SubManager<Ms>>,\n     pub msg_listeners: RefCell<MsgListeners<Ms>>,\n     pub scheduled_render_handle: RefCell<Option<util::RequestAnimationFrameHandle>>,\n-    pub after_next_render_callbacks:\n-        RefCell<Vec<Box<dyn FnOnce(Option<RenderTimestampDelta>) -> Option<Ms>>>>,\n-    pub render_timestamp: Cell<Option<RenderTimestamp>>,\n+    pub after_next_render_callbacks: RefCell<Vec<Box<dyn FnOnce(RenderInfo) -> Option<Ms>>>>,\n+    pub render_info: Cell<Option<RenderInfo>>,\n }\ndiff --git a/src/app/orders.rs b/src/app/orders.rs\nindex 8ceb8fc..d72e16a 100644\n--- a/src/app/orders.rs\n+++ b/src/app/orders.rs\n@@ -1,286 +1,287 @@\n-use super::{App, CmdHandle, RenderTimestampDelta, StreamHandle, SubHandle, UndefinedGMsg};\n+use super::{App, CmdHandle, RenderInfo, StreamHandle, SubHandle, UndefinedGMsg};\n use crate::virtual_dom::IntoNodes;\n use futures::stream::Stream;\n use std::{any::Any, future::Future, rc::Rc};\n \n // @TODO: Add links to doc comment once https://github.com/rust-lang/rust/issues/43466 is resolved\n // or use nightly rustdoc. Applicable to the entire code base.\n \n pub mod container;\n pub mod proxy;\n \n pub use container::OrdersContainer;\n pub use proxy::OrdersProxy;\n \n pub trait Orders<Ms: 'static, GMs = UndefinedGMsg> {\n     type AppMs: 'static;\n     type Mdl: 'static;\n     type INodes: IntoNodes<Self::AppMs> + 'static;\n \n     /// Automatically map message type. It allows you to pass `Orders` into child module.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///Msg::Child(child_msg) => {\n     ///    child::update(child_msg, &mut model.child, &mut orders.proxy(Msg::Child));\n     ///}\n     /// ```\n     fn proxy<ChildMs: 'static>(\n         &mut self,\n         f: impl FnOnce(ChildMs) -> Ms + 'static + Clone,\n     ) -> OrdersProxy<ChildMs, Self::AppMs, Self::Mdl, Self::INodes, GMs>;\n \n     /// Schedule web page rerender after model update. It's the default behaviour.\n     fn render(&mut self) -> &mut Self;\n \n     /// Force web page to rerender immediately after model update.\n     fn force_render_now(&mut self) -> &mut Self;\n \n     /// Don't rerender web page after model update.\n     fn skip(&mut self) -> &mut Self;\n \n     /// Notify all subscription handlers that listen for messages with the `message`'s type.\n     ///\n     /// _Note:_ Seed's native subscriptions / `messages` can be also sent - e.g.\n     /// `orders.notify(subs::UrlRequested::new(url))`.\n     /// The most is ignored by the Seed's runtime, but some of them are processed and\n     /// trigger side-effects - e.g. simulate `<a>` link click by sending `subs::UrlRequested`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///orders.notify(counter::DoReset);\n     ///orders.notify(\"Hello!\");\n     /// ...\n     ///orders.subscribe(Msg::Reset);  // `Msg::Reset(counter::DoReset)`\n     ///orders.subscribe(|greeting: &'static str| log!(greeting));\n     /// ```\n     ///\n     /// _Note:_: All notifications are pushed to the queue - i.e. `update` function is NOT called immediately.\n     fn notify(&mut self, message: impl Any + Clone) -> &mut Self;\n \n     /// Invoke function `update` with the given `msg`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///orders.msg(Msg::Increment);\n     /// ```\n     ///\n     /// _Note:_: All `msg`s are pushed to the queue - i.e. `update` function is NOT called immediately.\n     fn send_msg(&mut self, msg: Ms) -> &mut Self;\n \n     /// Execute `cmd` and send its output (if it's `Msg`) to `update` function.\n     ///\n     /// Output has to be `Msg`, `Option<Msg>` or `()`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///orders.perform_cmd(cmds::timeout(2000, || Msg::OnTimeout));\n     ///orders.perform_cmd(async { log!(\"Hello!\") });\n     /// ```\n     ///\n     /// _Note:_: Use the alternative `perform_cmd_with_handle` to control `cmd`'s lifetime.\n     ///\n     /// # Panics\n     ///\n     /// Panics when the output isn't `Msg`, `Option<Msg>` or `()`.\n     /// (It will be changed to a compile-time error).\n     #[allow(clippy::shadow_unrelated)]\n     // @TODO remove `'static`s once `optin_builtin_traits`, `negative_impls`\n     // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable\n     fn perform_cmd<MsU: 'static>(&mut self, cmd: impl Future<Output = MsU> + 'static) -> &mut Self;\n \n     /// Execute given `cmd` and send its output (if it's `Msg`) to `update` function.\n     /// - Returns `CmdHandle` that you should save to your `Model`.\n     ///   The `cmd` is aborted on the handle drop.\n     ///\n     /// Output has to be `Msg`, `Option<Msg>` or `()`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///let timeout_handle = orders.perform_cmd_with_handle(cmds::timeout(2000, || Msg::OnTimeout));\n     ///let cmd_handle = orders.perform_cmd_with_handle(async { log!(\"Hello!\") });\n     /// ```\n     ///\n     /// # Panics\n     ///\n     /// Panics when the output isn't `Msg`, `Option<Msg>` or `()`.\n     /// (It will be changed to a compile-time error).\n     #[must_use = \"cmd is aborted on its handle drop\"]\n     #[allow(clippy::shadow_unrelated)]\n     // @TODO remove `'static`s once `optin_builtin_traits`, `negative_impls`\n     // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable\n     fn perform_cmd_with_handle<MsU: 'static>(\n         &mut self,\n         cmd: impl Future<Output = MsU> + 'static,\n     ) -> CmdHandle;\n \n     /// Similar to `send_msg`, but calls function `sink` with the given global message.\n     fn send_g_msg(&mut self, g_msg: GMs) -> &mut Self;\n \n     /// Similar to `perform_cmd`, but result is send to function `sink`.\n     fn perform_g_cmd(&mut self, g_cmd: impl Future<Output = GMs> + 'static) -> &mut Self;\n \n     /// Similar to `perform_g_cmd`, but result is send to function `sink`.\n     /// - Returns `CmdHandle` that you should save to your `Model`.\n     ///   `cmd` is aborted on the handle drop.\n     ///\n     #[must_use = \"cmd is aborted on its handle drop\"]\n     fn perform_g_cmd_with_handle(\n         &mut self,\n         g_cmd: impl Future<Output = GMs> + 'static,\n     ) -> CmdHandle;\n \n     /// Get app instance. Cloning is cheap because `App` contains only `Rc` fields.\n     fn clone_app(&self) -> App<Self::AppMs, Self::Mdl, Self::INodes, GMs>;\n \n     /// Get the function that maps module's `Msg` to app's (root's) one.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///let (app, msg_mapper) = (orders.clone_app(), orders.msg_mapper());\n     ///app.update(msg_mapper(Msg::AMessage));\n     /// ```\n     fn msg_mapper(&self) -> Box<dyn Fn(Ms) -> Self::AppMs>;\n \n     /// Register the callback that will be executed after the next render.\n     ///\n-    /// Callback's only parameter is `Option<RenderTimestampDelta>` - the difference between\n-    /// the old render timestamp and the new one.\n-    /// The parameter has value `None` if it's the first rendering.\n+    /// Callback's only parameter is `RenderInfo` - it has fields `timestamp`\n+    /// and `timestamp_delta`.\n+    /// `timestamp_delta` is the difference between the old render timestamp and the new one\n+    /// and it has value `None` if it's the first rendering.\n     ///\n     /// - It's useful when you want to use DOM API or make animations.\n     /// - You can call this function multiple times - callbacks will be executed in the same order.\n     /// - Callback has to return `Msg`, `Option<Msg>` or `()`.\n     ///\n     /// _Note:_ [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)\n     ///  is used under the hood to get timestamps.\n     ///\n     /// # Panics\n     ///\n     /// Panics when the handler doesn't return `Msg`, `Option<Msg>` or `()`.\n     /// (It will be changed to a compile-time error).\n     #[allow(clippy::shadow_unrelated)]\n     // @TODO remove `'static`s once `optin_builtin_traits`, `negative_impls`\n     // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable\n     fn after_next_render<MsU: 'static>(\n         &mut self,\n-        callback: impl FnOnce(Option<RenderTimestampDelta>) -> MsU + 'static,\n+        callback: impl FnOnce(RenderInfo) -> MsU + 'static,\n     ) -> &mut Self;\n \n     /// Subscribe for messages with the `handler`s input type.\n     ///\n     /// Handler has to return `Msg`, `Option<Msg>` or `()`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///orders.subscribe(Msg::Reset);  // `Msg::Reset(counter::DoReset)`\n     ///orders.subscribe(|greeting: &'static str| log!(greeting));\n     ///orders.subscribe(Msg::UrlChanged)  // `update(... Msg::UrlChanged(subs::UrlChanged(url)) =>`\n     /// ...\n     ///orders.notify(counter::DoReset);\n     ///orders.notify(\"Hello!\");\n     /// ```\n     ///\n     /// _Note:_: Use the alternative `subscribe_with_handle` to control `sub`'s lifetime.\n     ///\n     /// # Panics\n     ///\n     /// Panics when the handler doesn't return `Msg`, `Option<Msg>` or `()`.\n     /// (It will be changed to a compile-time error).\n     #[allow(clippy::shadow_unrelated)]\n     // @TODO remove `'static`s once `optin_builtin_traits`, `negative_impls`\n     // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable\n     fn subscribe<MsU: 'static, SubMs: 'static + Clone>(\n         &mut self,\n         handler: impl FnOnce(SubMs) -> MsU + Clone + 'static,\n     ) -> &mut Self;\n \n     /// Subscribe for messages with the `handler`s input type.\n     /// - Returns `SubHandle` that you should save to your `Model`.\n     ///   The `sub` is cancelled on the handle drop.\n     ///\n     /// Handler has to return `Msg`, `Option<Msg>` or `()`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///let sub_handle = orders.subscribe_with_handle(Msg::Reset);  // `Msg::Reset(counter::DoReset)`\n     ///orders.subscribe_with_handle(|greeting: &'static str| log!(greeting));\n     ///let url_changed_handle = orders.subscribe_with_handle(Msg::UrlChanged)  // `update(... Msg::UrlChanged(subs::UrlChanged(url)) =>`\n     /// ...\n     ///orders.notify(counter::DoReset);\n     ///orders.notify(\"Hello!\");\n     /// ```\n     ///\n     /// # Panics\n     ///\n     /// Panics when the handler doesn't return `Msg`, `Option<Msg>` or `()`.\n     /// (It will be changed to a compile-time error).\n     #[must_use = \"subscription is cancelled on its handle drop\"]\n     #[allow(clippy::shadow_unrelated)]\n     // @TODO remove `'static`s once `optin_builtin_traits`, `negative_impls`\n     // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable\n     fn subscribe_with_handle<MsU: 'static, SubMs: 'static + Clone>(\n         &mut self,\n         handler: impl FnOnce(SubMs) -> MsU + Clone + 'static,\n     ) -> SubHandle;\n \n     /// Stream `Msg`, `Option<Msg>` or `()`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///orders.stream(streams::interval(1000, || Msg::OnTick));\n     ///orders.stream(streams::window_event(Ev::Resize, |_| Msg::OnResize));\n     /// ```\n     ///\n     /// _Note:_: Use the alternative `stream_with_handle` to control `stream`'s lifetime.\n     ///\n     /// # Panics\n     ///\n     /// Panics when the handler doesn't return `Msg`, `Option<Msg>` or `()`.\n     /// (It will be changed to a compile-time error).\n     #[allow(clippy::shadow_unrelated)]\n     // @TODO remove `'static`s once `optin_builtin_traits`, `negative_impls`\n     // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable\n     fn stream<MsU: 'static>(&mut self, stream: impl Stream<Item = MsU> + 'static) -> &mut Self;\n \n     /// Stream `Msg`, `Option<Msg>` or `()`.\n     /// - Returns `StreamHandle` that you should save to your `Model`.\n     ///   The `stream` is cancelled on the handle drop.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///let timer_handler = orders.stream_with_handle(streams::interval(1000, || Msg::OnTick));\n     ///let stream_handler = orders.stream_with_handle(streams::window_event(Ev::Resize, |_| Msg::OnResize));\n     /// ```\n     ///\n     /// # Panics\n     ///\n     /// Panics when the handler doesn't return `Msg`, `Option<Msg>` or `()`.\n     /// (It will be changed to a compile-time error).\n     #[must_use = \"stream is stopped on its handle drop\"]\n     #[allow(clippy::shadow_unrelated)]\n     // @TODO remove `'static`s once `optin_builtin_traits`, `negative_impls`\n     // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable\n     fn stream_with_handle<MsU: 'static>(\n         &mut self,\n         stream: impl Stream<Item = MsU> + 'static,\n     ) -> StreamHandle;\n \n     /// Cheap clone base path loaded from element `<base href=\"base/path\">`.\n     ///\n     /// Returns empty `Vec` if there is no `base` element in your HTML\n     /// or there were problems with parsing.\n     fn clone_base_path(&self) -> Rc<Vec<String>> {\n         Rc::clone(&self.clone_app().cfg.base_path)\n     }\n }\ndiff --git a/src/app/orders/container.rs b/src/app/orders/container.rs\nindex d1ee52a..18237c7 100644\n--- a/src/app/orders/container.rs\n+++ b/src/app/orders/container.rs\n@@ -1,242 +1,242 @@\n use crate::app::orders::{proxy::OrdersProxy, Orders};\n use crate::app::{\n-    effects::Effect, render_timestamp_delta::RenderTimestampDelta, App, CmdHandle, CmdManager,\n-    Notification, ShouldRender, StreamHandle, StreamManager, SubHandle, UndefinedGMsg,\n+    effects::Effect, App, CmdHandle, CmdManager, Notification, RenderInfo, ShouldRender,\n+    StreamHandle, StreamManager, SubHandle, UndefinedGMsg,\n };\n use crate::virtual_dom::IntoNodes;\n use futures::future::FutureExt;\n use futures::stream::{Stream, StreamExt};\n use std::{\n     any::{Any, TypeId},\n     collections::VecDeque,\n     convert::identity,\n     future::Future,\n     rc::Rc,\n };\n \n #[allow(clippy::module_name_repetitions)]\n pub struct OrdersContainer<Ms: 'static, Mdl: 'static, INodes: IntoNodes<Ms>, GMs = UndefinedGMsg> {\n     pub(crate) should_render: ShouldRender,\n     pub(crate) effects: VecDeque<Effect<Ms, GMs>>,\n     app: App<Ms, Mdl, INodes, GMs>,\n }\n \n impl<Ms, Mdl, INodes: IntoNodes<Ms>, GMs> OrdersContainer<Ms, Mdl, INodes, GMs> {\n     pub fn new(app: App<Ms, Mdl, INodes, GMs>) -> Self {\n         Self {\n             should_render: ShouldRender::Render,\n             effects: VecDeque::new(),\n             app,\n         }\n     }\n \n     pub(crate) fn merge(&mut self, mut other: Self) {\n         self.should_render = other.should_render;\n         self.effects.append(&mut other.effects);\n     }\n }\n \n impl<Ms: 'static, Mdl, INodes: IntoNodes<Ms> + 'static, GMs: 'static> Orders<Ms, GMs>\n     for OrdersContainer<Ms, Mdl, INodes, GMs>\n {\n     type AppMs = Ms;\n     type Mdl = Mdl;\n     type INodes = INodes;\n \n     #[allow(clippy::redundant_closure)]\n     fn proxy<ChildMs: 'static>(\n         &mut self,\n         f: impl FnOnce(ChildMs) -> Ms + 'static + Clone,\n     ) -> OrdersProxy<ChildMs, Ms, Mdl, INodes, GMs> {\n         OrdersProxy::new(self, move |child_ms| f.clone()(child_ms))\n     }\n \n     fn render(&mut self) -> &mut Self {\n         self.should_render = ShouldRender::Render;\n         self\n     }\n \n     fn force_render_now(&mut self) -> &mut Self {\n         self.should_render = ShouldRender::ForceRenderNow;\n         self\n     }\n \n     fn skip(&mut self) -> &mut Self {\n         self.should_render = ShouldRender::Skip;\n         self\n     }\n \n     fn notify(&mut self, message: impl Any + Clone) -> &mut Self {\n         self.effects\n             .push_back(Effect::Notification(Notification::new(message)));\n         self\n     }\n \n     fn send_msg(&mut self, msg: Ms) -> &mut Self {\n         self.effects.push_back(msg.into());\n         self\n     }\n \n     fn perform_cmd<MsU: 'static>(&mut self, cmd: impl Future<Output = MsU> + 'static) -> &mut Self {\n         let app = self.app.clone();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Cmds can return only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let cmd = cmd.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(msg)\n             }\n         });\n         CmdManager::perform_cmd(cmd);\n         self\n     }\n \n     fn perform_cmd_with_handle<MsU: 'static>(\n         &mut self,\n         cmd: impl Future<Output = MsU> + 'static,\n     ) -> CmdHandle {\n         let app = self.app.clone();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Cmds can return only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let cmd = cmd.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(msg)\n             }\n         });\n         CmdManager::perform_cmd_with_handle(cmd)\n     }\n \n     fn send_g_msg(&mut self, g_msg: GMs) -> &mut Self {\n         let effect = Effect::GMsg(g_msg);\n         self.effects.push_back(effect);\n         self\n     }\n \n     fn perform_g_cmd(&mut self, cmd: impl Future<Output = GMs> + 'static) -> &mut Self {\n         let app = self.app.clone();\n         let cmd = cmd.map(move |msg| app.sink(msg));\n         CmdManager::perform_cmd(cmd);\n         self\n     }\n \n     fn perform_g_cmd_with_handle(&mut self, cmd: impl Future<Output = GMs> + 'static) -> CmdHandle {\n         let app = self.app.clone();\n         let cmd = cmd.map(move |msg| app.sink(msg));\n         CmdManager::perform_cmd_with_handle(cmd)\n     }\n \n     fn clone_app(&self) -> App<Self::AppMs, Self::Mdl, Self::INodes, GMs> {\n         self.app.clone()\n     }\n \n     fn msg_mapper(&self) -> Box<dyn Fn(Ms) -> Self::AppMs> {\n         Box::new(identity)\n     }\n \n     fn after_next_render<MsU: 'static>(\n         &mut self,\n-        callback: impl FnOnce(Option<RenderTimestampDelta>) -> MsU + 'static,\n+        callback: impl FnOnce(RenderInfo) -> MsU + 'static,\n     ) -> &mut Self {\n         let callback = map_callback_return_to_option_ms!(\n-            dyn FnOnce(Option<RenderTimestampDelta>) -> Option<Ms>,\n+            dyn FnOnce(RenderInfo) -> Option<Ms>,\n             callback,\n             \"Callback can return only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         self.app\n             .data\n             .after_next_render_callbacks\n             .borrow_mut()\n             .push(callback);\n         self\n     }\n \n     fn subscribe<MsU: 'static, SubMs: 'static + Clone>(\n         &mut self,\n         handler: impl FnOnce(SubMs) -> MsU + Clone + 'static,\n     ) -> &mut Self {\n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(SubMs) -> Option<Ms>,\n             handler.clone(),\n             \"Handler can return only Msg, Option<Msg> or ()!\",\n             Rc\n         );\n \n         self.app\n             .data\n             .sub_manager\n             .borrow_mut()\n             .subscribe(move |sub_ms| handler(sub_ms));\n         self\n     }\n \n     fn subscribe_with_handle<MsU: 'static, SubMs: 'static + Clone>(\n         &mut self,\n         handler: impl FnOnce(SubMs) -> MsU + Clone + 'static,\n     ) -> SubHandle {\n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(SubMs) -> Option<Ms>,\n             handler.clone(),\n             \"Handler can return only Msg, Option<Msg> or ()!\",\n             Rc\n         );\n \n         self.app\n             .data\n             .sub_manager\n             .borrow_mut()\n             .subscribe_with_handle(move |sub_ms| handler(sub_ms))\n     }\n \n     fn stream<MsU: 'static>(&mut self, stream: impl Stream<Item = MsU> + 'static) -> &mut Self {\n         let app = self.app.clone();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Streams can stream only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let stream = stream.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(msg)\n             }\n         });\n         StreamManager::stream(stream);\n         self\n     }\n \n     fn stream_with_handle<MsU: 'static>(\n         &mut self,\n         stream: impl Stream<Item = MsU> + 'static,\n     ) -> StreamHandle {\n         let app = self.app.clone();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Streams can stream only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let stream = stream.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(msg)\n             }\n         });\n         StreamManager::stream_with_handle(stream)\n     }\n }\ndiff --git a/src/app/orders/proxy.rs b/src/app/orders/proxy.rs\nindex 163579a..45ed06d 100644\n--- a/src/app/orders/proxy.rs\n+++ b/src/app/orders/proxy.rs\n@@ -1,261 +1,261 @@\n use super::{\n     super::{\n-        App, CmdHandle, CmdManager, RenderTimestampDelta, StreamHandle, StreamManager, SubHandle,\n+        App, CmdHandle, CmdManager, RenderInfo, StreamHandle, StreamManager, SubHandle,\n         UndefinedGMsg,\n     },\n     Orders, OrdersContainer,\n };\n use crate::virtual_dom::IntoNodes;\n use futures::future::{Future, FutureExt};\n use futures::stream::{Stream, StreamExt};\n use std::{\n     any::{Any, TypeId},\n     convert::identity,\n     rc::Rc,\n };\n \n #[allow(clippy::module_name_repetitions)]\n pub struct OrdersProxy<\n     'a,\n     Ms,\n     AppMs: 'static,\n     Mdl: 'static,\n     INodes: IntoNodes<AppMs>,\n     GMs: 'static = UndefinedGMsg,\n > {\n     orders_container: &'a mut OrdersContainer<AppMs, Mdl, INodes, GMs>,\n     f: Rc<dyn Fn(Ms) -> AppMs>,\n }\n \n impl<'a, Ms: 'static, AppMs: 'static, Mdl, INodes: IntoNodes<AppMs>, GMs>\n     OrdersProxy<'a, Ms, AppMs, Mdl, INodes, GMs>\n {\n     pub fn new(\n         orders_container: &'a mut OrdersContainer<AppMs, Mdl, INodes, GMs>,\n         f: impl Fn(Ms) -> AppMs + 'static,\n     ) -> Self {\n         OrdersProxy {\n             orders_container,\n             f: Rc::new(f),\n         }\n     }\n }\n \n impl<'a, Ms: 'static, AppMs: 'static, Mdl, INodes: IntoNodes<AppMs> + 'static, GMs> Orders<Ms, GMs>\n     for OrdersProxy<'a, Ms, AppMs, Mdl, INodes, GMs>\n {\n     type AppMs = AppMs;\n     type Mdl = Mdl;\n     type INodes = INodes;\n \n     fn proxy<ChildMs: 'static>(\n         &mut self,\n         f: impl FnOnce(ChildMs) -> Ms + 'static + Clone,\n     ) -> OrdersProxy<ChildMs, AppMs, Mdl, INodes, GMs> {\n         let previous_f = self.f.clone();\n         OrdersProxy {\n             orders_container: self.orders_container,\n             f: Rc::new(move |child_ms| previous_f(f.clone()(child_ms))),\n         }\n     }\n \n     fn render(&mut self) -> &mut Self {\n         self.orders_container.render();\n         self\n     }\n \n     fn force_render_now(&mut self) -> &mut Self {\n         self.orders_container.force_render_now();\n         self\n     }\n \n     fn skip(&mut self) -> &mut Self {\n         self.orders_container.skip();\n         self\n     }\n \n     fn notify(&mut self, message: impl Any + Clone) -> &mut Self {\n         self.orders_container.notify(message);\n         self\n     }\n \n     #[allow(clippy::redundant_closure)]\n     fn send_msg(&mut self, msg: Ms) -> &mut Self {\n         let f = self.f.clone();\n         self.orders_container.send_msg(f(msg));\n         self\n     }\n \n     #[allow(clippy::redundant_closure)]\n     fn perform_cmd<MsU: 'static>(&mut self, cmd: impl Future<Output = MsU> + 'static) -> &mut Self {\n         let f = self.f.clone();\n         let app = self.clone_app();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Cmds can return only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let cmd = cmd.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(f(msg))\n             }\n         });\n         CmdManager::perform_cmd(cmd);\n         self\n     }\n \n     fn perform_cmd_with_handle<MsU: 'static>(\n         &mut self,\n         cmd: impl Future<Output = MsU> + 'static,\n     ) -> CmdHandle {\n         let f = self.f.clone();\n         let app = self.clone_app();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Cmds can return only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let cmd = cmd.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(f(msg))\n             }\n         });\n         CmdManager::perform_cmd_with_handle(cmd)\n     }\n \n     fn send_g_msg(&mut self, g_msg: GMs) -> &mut Self {\n         self.orders_container.send_g_msg(g_msg);\n         self\n     }\n \n     fn perform_g_cmd(&mut self, g_cmd: impl Future<Output = GMs> + 'static) -> &mut Self {\n         self.orders_container.perform_g_cmd(g_cmd);\n         self\n     }\n \n     fn perform_g_cmd_with_handle(\n         &mut self,\n         g_cmd: impl Future<Output = GMs> + 'static,\n     ) -> CmdHandle {\n         self.orders_container.perform_g_cmd_with_handle(g_cmd)\n     }\n \n     fn clone_app(&self) -> App<Self::AppMs, Self::Mdl, Self::INodes, GMs> {\n         self.orders_container.clone_app()\n     }\n \n     #[allow(clippy::redundant_closure)]\n     fn msg_mapper(&self) -> Box<dyn Fn(Ms) -> Self::AppMs> {\n         let f = self.f.clone();\n         Box::new(move |ms| f(ms))\n     }\n \n     fn after_next_render<MsU: 'static>(\n         &mut self,\n-        callback: impl FnOnce(Option<RenderTimestampDelta>) -> MsU + 'static,\n+        callback: impl FnOnce(RenderInfo) -> MsU + 'static,\n     ) -> &mut Self {\n         let callback = map_callback_return_to_option_ms!(\n-            dyn FnOnce(Option<RenderTimestampDelta>) -> Option<Ms>,\n+            dyn FnOnce(RenderInfo) -> Option<Ms>,\n             callback,\n             \"Callback can return only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let f = self.f.clone();\n         self.clone_app()\n             .data\n             .after_next_render_callbacks\n             .borrow_mut()\n-            .push(Box::new(move |timestamp_delta| {\n-                callback(timestamp_delta).map(|ms| f(ms))\n+            .push(Box::new(move |render_info| {\n+                callback(render_info).map(|ms| f(ms))\n             }));\n         self\n     }\n \n     fn subscribe<MsU: 'static, SubMs: 'static + Clone>(\n         &mut self,\n         handler: impl FnOnce(SubMs) -> MsU + Clone + 'static,\n     ) -> &mut Self {\n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(SubMs) -> Option<Ms>,\n             handler.clone(),\n             \"Handler can return only Msg, Option<Msg> or ()!\",\n             Rc\n         );\n \n         let f = self.f.clone();\n         self.clone_app()\n             .data\n             .sub_manager\n             .borrow_mut()\n             .subscribe(move |sub_ms| handler(sub_ms).map(|ms| f(ms)));\n         self\n     }\n \n     fn subscribe_with_handle<MsU: 'static, SubMs: 'static + Clone>(\n         &mut self,\n         handler: impl FnOnce(SubMs) -> MsU + Clone + 'static,\n     ) -> SubHandle {\n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(SubMs) -> Option<Ms>,\n             handler.clone(),\n             \"Handler can return only Msg, Option<Msg> or ()!\",\n             Rc\n         );\n \n         let f = self.f.clone();\n         self.clone_app()\n             .data\n             .sub_manager\n             .borrow_mut()\n             .subscribe_with_handle(move |sub_ms| handler(sub_ms).map(|ms| f(ms)))\n     }\n \n     fn stream<MsU: 'static>(&mut self, stream: impl Stream<Item = MsU> + 'static) -> &mut Self {\n         let f = self.f.clone();\n         let app = self.clone_app();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Streams can stream only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let stream = stream.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(f(msg))\n             }\n         });\n         StreamManager::stream(stream);\n         self\n     }\n \n     fn stream_with_handle<MsU: 'static>(\n         &mut self,\n         stream: impl Stream<Item = MsU> + 'static,\n     ) -> StreamHandle {\n         let f = self.f.clone();\n         let app = self.clone_app();\n \n         let handler = map_callback_return_to_option_ms!(\n             dyn Fn(MsU) -> Option<Ms>,\n             identity,\n             \"Streams can stream only Msg, Option<Msg> or ()!\",\n             Box\n         );\n \n         let stream = stream.map(move |msg| {\n             if let Some(msg) = handler(msg) {\n                 app.update(f(msg))\n             }\n         });\n         StreamManager::stream_with_handle(stream)\n     }\n }\ndiff --git a/src/app/render_info.rs b/src/app/render_info.rs\nnew file mode 100644\nindex 0000000..c05168d\n--- /dev/null\n+++ b/src/app/render_info.rs\n@@ -0,0 +1,5 @@\n+#[derive(Copy, Clone, Debug)]\n+pub struct RenderInfo {\n+    pub timestamp: f64,\n+    pub timestamp_delta: Option<f64>,\n+}\ndiff --git a/src/app/render_timestamp_delta.rs b/src/app/render_timestamp_delta.rs\ndeleted file mode 100644\nindex cf56def..0000000\n--- a/src/app/render_timestamp_delta.rs\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-pub type RenderTimestamp = f64;\n-\n-#[derive(Copy, Clone, PartialEq, Default, Debug, PartialOrd)]\n-pub struct RenderTimestampDelta(f64);\n-\n-impl RenderTimestampDelta {\n-    pub const fn new(delta: f64) -> Self {\n-        Self(delta)\n-    }\n-}\n-\n-impl From<RenderTimestampDelta> for f64 {\n-    fn from(delta: RenderTimestampDelta) -> Self {\n-        delta.0\n-    }\n-}\ndiff --git a/src/browser.rs b/src/browser.rs\nindex 56cb081..d8d2980 100644\n--- a/src/browser.rs\n+++ b/src/browser.rs\n@@ -1,8 +1,8 @@\n pub mod dom;\n pub mod fetch;\n pub mod service;\n pub mod url;\n pub mod util;\n pub mod web_storage;\n \n-pub use url::{Url, DUMMY_BASE_URL};\n+pub use url::{Url, UrlSearch, DUMMY_BASE_URL};\ndiff --git a/src/browser/dom/cast.rs b/src/browser/dom/cast.rs\nindex d6d86b0..739d040 100644\n--- a/src/browser/dom/cast.rs\n+++ b/src/browser/dom/cast.rs\n@@ -1,45 +1,59 @@\n use wasm_bindgen::JsCast;\n \n /// Convenience function used in event handling: Convert an event target\n /// to an input element; eg so you can take its value.\n pub fn to_input(target: &web_sys::EventTarget) -> &web_sys::HtmlInputElement {\n     target\n         .dyn_ref::<web_sys::HtmlInputElement>()\n         .expect(\"Unable to cast as an input element\")\n }\n \n /// See [`to_input`](fn.to_input.html)\n pub fn to_textarea(target: &web_sys::EventTarget) -> &web_sys::HtmlTextAreaElement {\n     target\n         .dyn_ref::<web_sys::HtmlTextAreaElement>()\n         .expect(\"Unable to cast as a textarea element\")\n }\n \n /// See [`to_input`](fn.to_input.html)\n pub fn to_select(target: &web_sys::EventTarget) -> &web_sys::HtmlSelectElement {\n     target\n         .dyn_ref::<web_sys::HtmlSelectElement>()\n         .expect(\"Unable to cast as a select element\")\n }\n \n /// See [`to_input`](fn.to_input.html)\n pub fn to_html_el(target: &web_sys::EventTarget) -> &web_sys::HtmlElement {\n     target\n         .dyn_ref::<web_sys::HtmlElement>()\n         .expect(\"Unable to cast as an HTML element\")\n }\n \n /// Convert a `web_sys::Event` to a `web_sys::KeyboardEvent`. Useful for extracting\n /// info like which key has been pressed, which is not available with normal Events.\n-pub fn to_kbevent(event: &web_sys::Event) -> &web_sys::KeyboardEvent {\n+pub fn to_keyboard_event(event: &web_sys::Event) -> &web_sys::KeyboardEvent {\n     event\n         .dyn_ref::<web_sys::KeyboardEvent>()\n         .expect(\"Unable to cast as a keyboard event\")\n }\n \n-/// See `to_kbevent`\n+/// See `to_keyboard_event`\n pub fn to_mouse_event(event: &web_sys::Event) -> &web_sys::MouseEvent {\n     event\n         .dyn_ref::<web_sys::MouseEvent>()\n         .expect(\"Unable to cast as a mouse event\")\n }\n+\n+/// See `to_keyboard_event`\n+pub fn to_touch_event(event: &web_sys::Event) -> &web_sys::TouchEvent {\n+    event\n+        .dyn_ref::<web_sys::TouchEvent>()\n+        .expect(\"Unable to cast as a touch event\")\n+}\n+\n+/// See `to_keyboard_event`\n+pub fn to_drag_event(event: &web_sys::Event) -> &web_sys::DragEvent {\n+    event\n+        .dyn_ref::<web_sys::DragEvent>()\n+        .expect(\"Unable to cast as a drag event\")\n+}\ndiff --git a/src/browser/dom/event_handler.rs b/src/browser/dom/event_handler.rs\nindex 15575a4..05adcb8 100644\n--- a/src/browser/dom/event_handler.rs\n+++ b/src/browser/dom/event_handler.rs\n@@ -1,128 +1,164 @@\n //! This module contains code related to event handling; ie things that update the dom, related to\n //! `web_sys::Event`\n \n use super::super::util;\n use crate::virtual_dom::{Ev, EventHandler};\n use std::any::{Any, TypeId};\n use std::rc::Rc;\n use wasm_bindgen::JsCast;\n \n /// Create an event that passes a String of field text, for fast input handling.\n #[allow(clippy::shadow_unrelated)]\n pub fn input_ev<Ms: 'static, MsU: 'static>(\n     trigger: impl Into<Ev>,\n     handler: impl FnOnce(String) -> MsU + 'static + Clone,\n ) -> EventHandler<Ms> {\n     let handler = map_callback_return_to_option_ms!(\n         dyn Fn(String) -> Option<Ms>,\n         handler.clone(),\n         \"Handler can return only Msg, Option<Msg> or ()!\",\n         Rc\n     );\n     let handler = move |event: web_sys::Event| {\n         let value = event\n             .target()\n             .as_ref()\n             .ok_or(\"Can't get event target reference\")\n             .and_then(util::get_value)\n             .map_err(crate::error)\n             .unwrap_or_default();\n         handler(value)\n     };\n     EventHandler::new(trigger, handler)\n }\n \n /// Create an event that passes a `web_sys::KeyboardEvent`, allowing easy access\n /// to items like `key_code`() and key().\n #[allow(clippy::shadow_unrelated)]\n pub fn keyboard_ev<Ms: 'static, MsU: 'static>(\n     trigger: impl Into<Ev>,\n     handler: impl FnOnce(web_sys::KeyboardEvent) -> MsU + 'static + Clone,\n ) -> EventHandler<Ms> {\n     let handler = map_callback_return_to_option_ms!(\n         dyn Fn(web_sys::KeyboardEvent) -> Option<Ms>,\n         handler.clone(),\n         \"Handler can return only Msg, Option<Msg> or ()!\",\n         Rc\n     );\n     let handler = move |event: web_sys::Event| {\n         handler(event.dyn_ref::<web_sys::KeyboardEvent>().unwrap().clone())\n     };\n     EventHandler::new(trigger, handler)\n }\n \n /// See `keyboard_ev`\n #[allow(clippy::shadow_unrelated)]\n pub fn mouse_ev<Ms: 'static, MsU: 'static>(\n     trigger: impl Into<Ev>,\n     handler: impl FnOnce(web_sys::MouseEvent) -> MsU + 'static + Clone,\n ) -> EventHandler<Ms> {\n     let handler = map_callback_return_to_option_ms!(\n         dyn Fn(web_sys::MouseEvent) -> Option<Ms>,\n         handler.clone(),\n         \"Handler can return only Msg, Option<Msg> or ()!\",\n         Rc\n     );\n     let handler = move |event: web_sys::Event| {\n         handler(event.dyn_ref::<web_sys::MouseEvent>().unwrap().clone())\n     };\n     EventHandler::new(trigger, handler)\n }\n \n+/// See `keyboard_ev`\n+#[allow(clippy::shadow_unrelated)]\n+pub fn touch_ev<Ms: 'static, MsU: 'static>(\n+    trigger: impl Into<Ev>,\n+    handler: impl FnOnce(web_sys::TouchEvent) -> MsU + 'static + Clone,\n+) -> EventHandler<Ms> {\n+    let handler = map_callback_return_to_option_ms!(\n+        dyn Fn(web_sys::TouchEvent) -> Option<Ms>,\n+        handler.clone(),\n+        \"Handler can return only Msg, Option<Msg> or ()!\",\n+        Rc\n+    );\n+    let handler = move |event: web_sys::Event| {\n+        handler(event.dyn_ref::<web_sys::TouchEvent>().unwrap().clone())\n+    };\n+    EventHandler::new(trigger, handler)\n+}\n+\n+/// See `keyboard_ev`\n+#[allow(clippy::shadow_unrelated)]\n+pub fn drag_ev<Ms: 'static, MsU: 'static>(\n+    trigger: impl Into<Ev>,\n+    handler: impl FnOnce(web_sys::DragEvent) -> MsU + 'static + Clone,\n+) -> EventHandler<Ms> {\n+    let handler = map_callback_return_to_option_ms!(\n+        dyn Fn(web_sys::DragEvent) -> Option<Ms>,\n+        handler.clone(),\n+        \"Handler can return only Msg, Option<Msg> or ()!\",\n+        Rc\n+    );\n+    let handler = move |event: web_sys::Event| {\n+        handler(event.dyn_ref::<web_sys::DragEvent>().unwrap().clone())\n+    };\n+    EventHandler::new(trigger, handler)\n+}\n+\n /// See `keyboard_ev`\n #[allow(clippy::shadow_unrelated)]\n pub fn pointer_ev<Ms: 'static, MsU: 'static>(\n     trigger: impl Into<Ev>,\n     handler: impl FnOnce(web_sys::PointerEvent) -> MsU + 'static + Clone,\n ) -> EventHandler<Ms> {\n     let handler = map_callback_return_to_option_ms!(\n         dyn Fn(web_sys::PointerEvent) -> Option<Ms>,\n         handler.clone(),\n         \"Handler can return only Msg, Option<Msg> or ()!\",\n         Rc\n     );\n     let handler = move |event: web_sys::Event| {\n         handler(event.dyn_ref::<web_sys::PointerEvent>().unwrap().clone())\n     };\n     EventHandler::new(trigger, handler)\n }\n \n /// Create an event that accepts a closure, and passes a `web_sys::Event`, allowing full control of\n /// event-handling.\n #[deprecated(since = \"0.6.0\", note = \"Use `ev` instead.\")]\n pub fn raw_ev<Ms: 'static, MsU: 'static>(\n     trigger: impl Into<Ev>,\n     handler: impl FnOnce(web_sys::Event) -> MsU + 'static + Clone,\n ) -> EventHandler<Ms> {\n     ev(trigger, handler)\n }\n \n /// Create an event handler that accepts a closure, and passes a `web_sys::Event`, allowing full control of\n /// event-handling.\n ///\n /// Handler has to return `Msg`, `Option<Msg>` or `()`.\n ///\n /// # Panics\n ///\n /// Panics when the handler doesn't return `Msg` or `()`. (It will be changed to a compile-time error).\n #[allow(clippy::shadow_unrelated)]\n pub fn ev<Ms: 'static, MsU: 'static>(\n     trigger: impl Into<Ev>,\n     handler: impl FnOnce(web_sys::Event) -> MsU + 'static + Clone,\n ) -> EventHandler<Ms> {\n     let handler = map_callback_return_to_option_ms!(\n         dyn Fn(web_sys::Event) -> Option<Ms>,\n         handler.clone(),\n         \"Handler can return only Msg, Option<Msg> or ()!\",\n         Rc\n     );\n     EventHandler::new(trigger, move |event| handler(event))\n }\n \n /// Create an event that passes no data, other than it occurred. Foregoes using a closure,\n /// in favor of pointing to a message directly.\n pub fn simple_ev<Ms: Clone + 'static>(trigger: impl Into<Ev>, message: Ms) -> EventHandler<Ms> {\n     let handler = || Some(message);\n     let closure_handler = move |_| handler.clone()();\n     EventHandler::new(trigger, closure_handler)\n }\ndiff --git a/src/browser/dom/namespace.rs b/src/browser/dom/namespace.rs\nindex ca8ed59..ad5d65b 100644\n--- a/src/browser/dom/namespace.rs\n+++ b/src/browser/dom/namespace.rs\n@@ -1,38 +1,37 @@\n /// Common Namespaces\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Namespace {\n     Html,\n     Svg,\n     MathMl,\n     Xul,\n     Xbl,\n     Custom(String),\n }\n \n // https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS\n impl Namespace {\n     pub fn as_str(&self) -> &str {\n-        use Namespace::*;\n         match self {\n-            Html => \"http://www.w3.org/1999/xhtml\",\n-            Svg => \"http://www.w3.org/2000/svg\",\n-            MathMl => \"http://www.w3.org/1998/mathml\",\n-            Xul => \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n-            Xbl => \"http://www.mozilla.org/xbl\",\n-            Custom(s) => s,\n+            Namespace::Html => \"http://www.w3.org/1999/xhtml\",\n+            Namespace::Svg => \"http://www.w3.org/2000/svg\",\n+            Namespace::MathMl => \"http://www.w3.org/1998/mathml\",\n+            Namespace::Xul => \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\",\n+            Namespace::Xbl => \"http://www.mozilla.org/xbl\",\n+            Namespace::Custom(namespace) => namespace,\n         }\n     }\n }\n \n impl From<String> for Namespace {\n-    fn from(ns: String) -> Self {\n-        match ns.as_ref() {\n+    fn from(namespace: String) -> Self {\n+        match namespace.as_ref() {\n             \"http://www.w3.org/1999/xhtml\" => Namespace::Html,\n             \"http://www.w3.org/2000/svg\" => Namespace::Svg,\n             \"http://www.w3.org/1998/mathml\" => Namespace::MathMl,\n             \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\" => Namespace::Xul,\n             \"http://www.mozilla.org/xbl\" => Namespace::Xbl,\n-            _ => Namespace::Custom(ns),\n+            _ => Namespace::Custom(namespace),\n         }\n     }\n }\ndiff --git a/src/browser/dom/virtual_dom_bridge.rs b/src/browser/dom/virtual_dom_bridge.rs\nindex 1db091e..e5df9da 100644\n--- a/src/browser/dom/virtual_dom_bridge.rs\n+++ b/src/browser/dom/virtual_dom_bridge.rs\n@@ -1,507 +1,508 @@\n //! This file contains interactions with `web_sys`.\n \n use super::Namespace;\n use crate::virtual_dom::{At, AtValue, Attrs, El, Mailbox, Node, Style, Text};\n use wasm_bindgen::JsCast;\n use web_sys::Document;\n \n /// Convenience function to reduce repetition\n fn set_style(el_ws: &web_sys::Node, style: &Style) {\n     el_ws\n         .dyn_ref::<web_sys::Element>()\n         .expect(\"Problem casting Node as Element while setting style\")\n         .set_attribute(\"style\", &style.to_string())\n         .expect(\"Problem setting style\");\n }\n \n pub(crate) fn assign_ws_nodes_to_el<Ms>(document: &Document, el: &mut El<Ms>) {\n     let node_ws = make_websys_el(el, document);\n     for ref_ in &mut el.refs {\n         ref_.set(node_ws.clone());\n     }\n     el.node_ws = Some(node_ws);\n     for mut child in &mut el.children {\n         assign_ws_nodes(document, &mut child);\n     }\n }\n+pub(crate) fn assign_ws_nodes_to_text(document: &Document, text: &mut Text) {\n+    text.node_ws = Some(\n+        document\n+            .create_text_node(&text.text)\n+            .dyn_into::<web_sys::Node>()\n+            .expect(\"Problem casting Text as Node.\"),\n+    );\n+}\n /// Recursively create `web_sys::Node`s, and place them in the vdom Nodes' fields.\n pub(crate) fn assign_ws_nodes<Ms>(document: &Document, node: &mut Node<Ms>) {\n     match node {\n         Node::Element(el) => assign_ws_nodes_to_el(document, el),\n-        Node::Text(text) => {\n-            text.node_ws = Some(\n-                document\n-                    .create_text_node(&text.text)\n-                    .dyn_into::<web_sys::Node>()\n-                    .expect(\"Problem casting Text as Node.\"),\n-            );\n-        }\n+        Node::Text(text) => assign_ws_nodes_to_text(document, text),\n         Node::Empty => (),\n     }\n }\n \n fn node_to_element(el_ws: &web_sys::Node) -> Result<&web_sys::Element, &'static str> {\n     if let web_sys::Node::ELEMENT_NODE = el_ws.node_type() {\n         el_ws\n             .dyn_ref::<web_sys::Element>()\n             .ok_or(\"Problem casting Node as Element\")\n     } else {\n         Err(\"Node isn't Element!\")\n     }\n }\n \n fn set_attr_value(el_ws: &web_sys::Node, at: &At, at_value: &AtValue) {\n     match at_value {\n         AtValue::Some(value) => {\n             node_to_element(el_ws)\n                 .and_then(|element| {\n                     element\n                         .set_attribute(at.as_str(), value)\n                         .map_err(|_| \"Problem setting an atrribute.\")\n                 })\n                 .unwrap_or_else(|err| {\n                     crate::error(err);\n                 });\n         }\n         AtValue::None => {\n             node_to_element(el_ws)\n                 .and_then(|element| {\n                     element\n                         .set_attribute(at.as_str(), \"\")\n                         .map_err(|_| \"Problem setting an atrribute.\")\n                 })\n                 .unwrap_or_else(|err| {\n                     crate::error(err);\n                 });\n         }\n         AtValue::Ignored => {\n             node_to_element(el_ws)\n                 .and_then(|element| {\n                     element\n                         .remove_attribute(at.as_str())\n                         .map_err(|_| \"Problem removing an atrribute.\")\n                 })\n                 .unwrap_or_else(|err| {\n                     crate::error(err);\n                 });\n         }\n     }\n }\n \n /// Create and return a `web_sys` Element from our virtual-dom `El`. The `web_sys`\n /// Element is a close analog to JS/DOM elements.\n ///\n /// # References\n /// * [`web_sys` Element](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Element.html)\n /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element\\)\n /// * See also: [`web_sys` Node](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Node.html)\n pub(crate) fn make_websys_el<Ms>(el: &mut El<Ms>, document: &web_sys::Document) -> web_sys::Node {\n     let tag = el.tag.as_str();\n \n     let el_ws = match el.namespace {\n         Some(ref ns) => document\n             .create_element_ns(Some(ns.as_str()), tag)\n             .expect(\"Problem creating web-sys element with namespace\"),\n         None => document\n             .create_element(tag)\n             .expect(\"Problem creating web-sys element\"),\n     };\n \n     for (at, attr_value) in &el.attrs.vals {\n         set_attr_value(&el_ws, at, attr_value);\n     }\n     if let Some(ns) = &el.namespace {\n         el_ws\n             .dyn_ref::<web_sys::Element>()\n             .expect(\"Problem casting Node as Element while setting an attribute\")\n             .set_attribute(\"xmlns\", ns.as_str())\n             .expect(\"Problem setting xlmns attribute\");\n     }\n \n     // Style is just an attribute in the actual Dom, but is handled specially in our vdom;\n     // merge the different parts of style here.\n     if el.style.vals.keys().len() > 0 {\n         set_style(&el_ws, &el.style)\n     }\n \n     el_ws.into()\n }\n \n /// Similar to `attach_el_and_children`, but for text nodes\n pub fn attach_text_node(text: &mut Text, parent: &web_sys::Node) {\n     let node_ws = text.node_ws.take().expect(\"Missing websys node for Text\");\n     parent\n         .append_child(&node_ws)\n         .expect(\"Problem appending text node\");\n     text.node_ws.replace(node_ws);\n }\n \n /// Similar to `attach_el_and_children`, but without attaching the elemnt. Useful for\n /// patching, where we want to insert the element at a specific place.\n pub fn attach_children<Ms>(el: &mut El<Ms>, mailbox: &Mailbox<Ms>) {\n     let el_ws = el\n         .node_ws\n         .as_ref()\n         .expect(\"Missing websys el in attach_children\");\n     // appending the its children to the el_ws\n     for child in &mut el.children {\n         match child {\n             // Raise the active level once per recursion.\n             Node::Element(child_el) => attach_el_and_children(child_el, el_ws, mailbox),\n             Node::Text(child_text) => attach_text_node(child_text, el_ws),\n             Node::Empty => (),\n         }\n     }\n }\n \n /// Attaches the element, and all children, recursively. Only run this when creating a fresh vdom node, since\n /// it performs a rerender of the el and all children; eg a potentially-expensive op.\n /// This is where rendering occurs.\n pub fn attach_el_and_children<Ms>(el: &mut El<Ms>, parent: &web_sys::Node, mailbox: &Mailbox<Ms>) {\n     // No parent means we're operating on the top-level element; append it to the main div.\n     // This is how we call this function externally, ie not through recursion.\n     let el_ws = el\n         .node_ws\n         .as_ref()\n         .expect(\"Missing websys el in attach_el_and_children\");\n \n     // Append the element\n \n     // todo: This error can occur with raw html elements, but am unsure of the cause.\n     if parent.append_child(el_ws).is_err() {\n         crate::error(\"Minor problem with html element (append)\");\n     }\n \n     el.event_handler_manager\n         .attach_listeners(el_ws.clone(), None, mailbox);\n \n     // appending the its children to the el_ws\n     for child in &mut el.children {\n         match child {\n             // Raise the active level once per recursion.\n             Node::Element(child_el) => attach_el_and_children(child_el, el_ws, mailbox),\n             Node::Text(child_text) => attach_text_node(child_text, el_ws),\n             Node::Empty => (),\n         }\n     }\n \n     // Note: Call `set_default_element_state` after child appending,\n     // otherwise it breaks autofocus in Firefox\n     set_default_element_state(el_ws, el);\n }\n \n fn set_default_element_state<Ms>(el_ws: &web_sys::Node, el: &El<Ms>) {\n     // @TODO handle also other Auto* attributes?\n     // Set focus because of attribute \"autofocus\"\n     if let Some(at_value) = el.attrs.vals.get(&At::AutoFocus) {\n         match at_value {\n             AtValue::Some(_) | AtValue::None => el_ws\n                 .dyn_ref::<web_sys::HtmlElement>()\n                 .expect(\"Problem casting Node as HtmlElement while focusing\")\n                 .focus()\n                 .expect(\"Problem focusing to an element.\"),\n             AtValue::Ignored => (),\n         }\n     }\n \n     // We set Textarea's initial value through non-standard attribute \"value\", so we have to simulate\n     // the standard way (i.e. `<textarea>A Value</textarea>`)\n     if let Some(textarea) = el_ws.dyn_ref::<web_sys::HtmlTextAreaElement>() {\n         if let Some(AtValue::Some(value)) = el.attrs.vals.get(&At::Value) {\n             textarea.set_value(value);\n         }\n     }\n }\n \n /// Recursively remove all children.\n pub fn _remove_children(el: &web_sys::Node) {\n     while let Some(child) = el.last_child() {\n         el.remove_child(&child).expect(\"Problem removing child\");\n     }\n }\n \n /// Update the attributes, style, text, and events of an element. Does not\n /// process children, and assumes the tag is the same. Assume we've identfied\n /// the most-correct pairing between new and old.\n pub fn patch_el_details<Ms>(\n     old: &mut El<Ms>,\n     new: &mut El<Ms>,\n     old_el_ws: &web_sys::Node,\n     mailbox: &Mailbox<Ms>,\n ) {\n     for (key, new_val) in &new.attrs.vals {\n         match old.attrs.vals.get(key) {\n             Some(old_val) => {\n                 // The value's different\n                 if old_val != new_val {\n                     set_attr_value(old_el_ws, key, new_val);\n                 }\n             }\n             None => {\n                 set_attr_value(old_el_ws, key, new_val);\n             }\n         }\n \n         // We handle value in the vdom using attributes, but the DOM needs\n         // to use set_value or set_checked.\n         match key {\n             At::Value => match new_val {\n                 AtValue::Some(new_val) => crate::util::set_value(old_el_ws, new_val),\n                 AtValue::None | AtValue::Ignored => crate::util::set_value(old_el_ws, \"\"),\n             },\n             At::Checked => match new_val {\n                 AtValue::Some(_) | AtValue::None => crate::util::set_checked(old_el_ws, true),\n                 AtValue::Ignored => crate::util::set_checked(old_el_ws, false),\n             },\n             _ => Ok(()),\n         }\n         .unwrap_or_else(|err| {\n             crate::error(err);\n         })\n     }\n     // Remove attributes that aren't in the new vdom.\n     for (key, old_val) in &old.attrs.vals {\n         if new.attrs.vals.get(key).is_none() {\n             // todo get to the bottom of this\n             match old_el_ws.dyn_ref::<web_sys::Element>() {\n                 Some(el) => {\n                     el.remove_attribute(key.as_str())\n                         .expect(\"Removing an attribute\");\n \n                     // We handle value in the vdom using attributes, but the DOM needs\n                     // to use set_value or set_checked.\n                     match key {\n                         At::Value => match old_val {\n                             AtValue::Some(_) => crate::util::set_value(old_el_ws, \"\"),\n                             _ => Ok(()),\n                         },\n                         At::Checked => match old_val {\n                             AtValue::Some(_) | AtValue::None => {\n                                 crate::util::set_checked(old_el_ws, false)\n                             }\n                             _ => Ok(()),\n                         },\n                         _ => Ok(()),\n                     }\n                     .unwrap_or_else(|err| {\n                         crate::error(err);\n                     })\n                 }\n                 None => {\n                     crate::error(\"Minor error on html element (setting attrs)\");\n                 }\n             }\n         }\n     }\n \n     // Patch event handlers and listeners.\n     new.event_handler_manager.attach_listeners(\n         old_el_ws.clone(),\n         Some(&mut old.event_handler_manager),\n         mailbox,\n     );\n \n     // Patch style.\n     if old.style != new.style {\n         // We can't patch each part of style; rewrite the whole attribute.\n         set_style(old_el_ws, &new.style)\n     }\n }\n \n #[allow(clippy::too_many_lines)]\n impl<Ms> From<&web_sys::Element> for El<Ms> {\n     /// Create a vdom node from a `web_sys::Element`. Used in creating elements from html\n     /// and markdown strings. Includes children, recursively added.\n     #[allow(clippy::too_many_lines)]\n     fn from(ws_el: &web_sys::Element) -> Self {\n         // Result of tag_name is all caps, but tag From<String> expects lower.\n         // Probably is more pure to match by xlmns attribute instead.\n         let mut el = match ws_el.tag_name().to_lowercase().as_ref() {\n             \"svg\" => El::empty_svg(ws_el.tag_name().to_lowercase().into()),\n             _ => El::empty(ws_el.tag_name().to_lowercase().into()),\n         };\n \n         // Populate attributes\n         let mut attrs = Attrs::empty();\n         ws_el\n             .get_attribute_names()\n             .for_each(&mut |attr_name, _, _| {\n                 let attr_name = attr_name\n                     .as_string()\n                     .expect(\"problem converting attr to string\");\n                 if let Some(attr_val) = ws_el.get_attribute(&attr_name) {\n                     attrs.add(attr_name.into(), &attr_val);\n                 }\n             });\n         el.attrs = attrs;\n \n         // todo This is the same list in `shortcuts::element_svg!`.\n         // todo: Fix this repetition: Use `/scripts/populate_tags.rs`\n         // todo to consolodate these lists.\n         let svg_tags = [\n             \"line\",\n             \"rect\",\n             \"circle\",\n             \"ellipse\",\n             \"polygon\",\n             \"polyline\",\n             \"mesh\",\n             \"path\",\n             \"defs\",\n             \"g\",\n             \"marker\",\n             \"mask\",\n             \"pattern\",\n             \"svg\",\n             \"switch\",\n             \"symbol\",\n             \"unknown\",\n             \"linear_gradient\",\n             \"radial_gradient\",\n             \"mesh_gradient\",\n             \"stop\",\n             \"image\",\n             \"r#use\",\n             \"altGlyph\",\n             \"altGlyphDef\",\n             \"altGlyphItem\",\n             \"glyph\",\n             \"glyphRef\",\n             \"textPath\",\n             \"text\",\n             \"tref\",\n             \"tspan\",\n             \"clipPath\",\n             \"cursor\",\n             \"filter\",\n             \"foreignObject\",\n             \"hathpath\",\n             \"meshPatch\",\n             \"meshRow\",\n             \"view\",\n             \"colorProfile\",\n             \"animage\",\n             \"animateColor\",\n             \"animateMotion\",\n             \"animateTransform\",\n             \"discard\",\n             \"mpath\",\n             \"set\",\n             \"desc\",\n             \"metadata\",\n             \"title\",\n             \"feBlend\",\n             \"feColorMatrix\",\n             \"feComponentTransfer\",\n             \"feComposite\",\n             \"feConvolveMatrix\",\n             \"feDiffuseLighting\",\n             \"feDisplacementMap\",\n             \"feDropShadow\",\n             \"feFlood\",\n             \"feFuncA\",\n             \"feFuncB\",\n             \"feFuncG\",\n             \"feFuncR\",\n             \"feGaussianBlur\",\n             \"feImage\",\n             \"feMerge\",\n             \"feMergeNode\",\n             \"feMorphology\",\n             \"feOffset\",\n             \"feSpecularLighting\",\n             \"feTile\",\n             \"feTurbulence\",\n             \"font\",\n             \"hkern\",\n             \"vkern\",\n             \"hatch\",\n             \"solidcolor\",\n         ];\n \n         if svg_tags.contains(&ws_el.tag_name().to_lowercase().as_str()) {\n             el.namespace = Some(Namespace::Svg);\n         }\n \n         if let Some(ns) = ws_el.namespace_uri() {\n             // Prevent attaching a `xlmns` attribute to normal HTML elements.\n             if ns != \"http://www.w3.org/1999/xhtml\" {\n                 el.namespace = Some(ns.into());\n             }\n         }\n \n         let children = ws_el.child_nodes();\n         for i in 0..children.length() {\n             let child = children\n                 .get(i)\n                 .expect(\"Can't find child in raw html element.\");\n \n             if let Some(child_vdom) = node_from_ws(&child) {\n                 el.children.push(child_vdom);\n             }\n         }\n         el\n     }\n }\n impl<Ms> From<&web_sys::Element> for Node<Ms> {\n     fn from(ws_el: &web_sys::Element) -> Node<Ms> {\n         Node::Element(ws_el.into())\n     }\n }\n \n /// Create a vdom node from a `web_sys::Node`. Used in creating elements from html\n /// and markdown strings. Includes children, recursively added.\n pub fn node_from_ws<Ms>(node: &web_sys::Node) -> Option<Node<Ms>> {\n     match node.node_type() {\n         web_sys::Node::ELEMENT_NODE => {\n             // Element node\n             let ws_el = node\n                 .dyn_ref::<web_sys::Element>()\n                 .expect(\"Problem casting Node as Element\");\n \n             // Create the Element\n             Some(ws_el.into())\n         }\n         web_sys::Node::TEXT_NODE => Some(Node::new_text(\n             node.text_content().expect(\"Can't find text\"),\n         )),\n         web_sys::Node::COMMENT_NODE => None,\n         node_type => {\n             crate::error(format!(\n                 \"HTML node type {} is not supported by Seed\",\n                 node_type\n             ));\n             None\n         }\n     }\n }\n \n /// Insert a new node into the specified part of the DOM tree.\n pub(crate) fn insert_node(\n     node: &web_sys::Node,\n     parent: &web_sys::Node,\n     next: Option<web_sys::Node>,\n ) {\n     match next {\n         Some(n) => {\n             parent\n                 .insert_before(node, Some(&n))\n                 .expect(\"Problem inserting node\");\n         }\n         None => {\n             parent.append_child(node).expect(\"Problem inserting node\");\n         }\n     };\n }\n \n pub(crate) fn remove_node(node: &web_sys::Node, parent: &web_sys::Node) {\n     parent\n         .remove_child(node)\n         .expect(\"Problem removing old el_ws when updating to empty\");\n }\n \n pub(crate) fn replace_child(new: &web_sys::Node, old: &web_sys::Node, parent: &web_sys::Node) {\n     parent\n         .replace_child(new, old)\n         .expect(\"Problem replacing element\");\n }\ndiff --git a/src/browser/fetch.rs b/src/browser/fetch.rs\nindex 7a93731..f2dfcb0 100644\n--- a/src/browser/fetch.rs\n+++ b/src/browser/fetch.rs\n@@ -1,113 +1,111 @@\n //! Fetch API.\n //!\n //! Seed Fetch API is very similar to the browser [native one][fetch-mdn].\n //!\n //! There is one entry point: [`fetch`][fetch] function.\n //! It can accept both string urls as well as [`Request`][request].\n //!\n //! To get a [`Response`][response] you need to `.await` fetch:\n //! ```rust\n //! let response = fetch(\"/foo\").await?;\n //! ```\n //!\n //! Then you can check [`Status`][status] and extract body in various formats:\n //! ```rust\n //! let response = fetch(\"/foo\").await?.check_status()?;\n //! let body: FooStruct = response.json().await?;\n //! ```\n //!\n //! Use [`Request`][request] methods to set init options:\n //! ```rust\n //! fetch(Request::new(url).method(Method::Post)).await\n //! ```\n //!\n //!\n //! [fetch]: ./fn.fetch.html\n //! [request]: ./struct.Request.html\n //! [response]: ./struct.Response.html\n //! [status]: ./struct.Status.html\n //! [fetch-mdn]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n \n use crate::util::window;\n-use serde_json;\n use std::convert::TryInto;\n use wasm_bindgen_futures::JsFuture;\n-use web_sys;\n \n pub mod header;\n mod method;\n mod request;\n mod response;\n mod status;\n \n pub use header::{Header, Headers};\n pub use method::*;\n pub use request::*;\n pub use response::*;\n pub use status::*;\n \n /// Convenient type alias.\n pub type Result<T> = std::result::Result<T, FetchError>;\n \n /// The main Fetch API function.\n /// It fires a HTTP request.\n ///\n /// ## Examples\n ///\n /// Simple `GET` request:\n /// ```rust\n /// let response = fetch(\"https://seed-rs.org\").await?;\n /// let body = response.text().await?;\n /// ```\n ///\n /// `POST` request with `JSON` body:\n /// ```rust\n /// let form = Form{email: \"foo@example.com\"};\n /// let response = fetch(Request::new(\"/api\").method(Method::Post).json(form)).await?;\n /// let data: SubmitResponse = response.json().await?;\n /// ```\n ///\n /// ## Errors\n ///\n /// `fetch` will return `Err` only on network errors. This means that\n /// even if you get `Ok` from this function, you still need to check\n /// `Response` status for HTTP errors.\n pub async fn fetch<'a>(request: impl Into<Request<'a>>) -> Result<Response> {\n     let request = request.into();\n     let promise = window().fetch_with_request(&request.try_into()?);\n \n     let raw_response = JsFuture::from(promise)\n         .await\n         .map(Into::into)\n         .map_err(FetchError::NetworkError)?;\n \n     Ok(Response { raw_response })\n }\n \n #[allow(clippy::module_name_repetitions)]\n #[derive(Debug)]\n pub enum FetchError {\n     SerdeError(serde_json::Error),\n     DomException(web_sys::DomException),\n     PromiseError(wasm_bindgen::JsValue),\n     NetworkError(wasm_bindgen::JsValue),\n     /// Request construction failed.\n     RequestError(wasm_bindgen::JsValue),\n     StatusError(Status),\n }\n \n #[cfg(test)]\n mod tests {\n     use wasm_bindgen_test::*;\n     wasm_bindgen_test_configure!(run_in_browser);\n     use super::*;\n     use crate::browser::Url;\n \n     #[wasm_bindgen_test]\n     fn test_fetch_args() {\n         let _ = fetch(\"https://seed-rs.org\");\n         let _ = fetch(String::from(\"https://seed-rs.org\"));\n         let _ = fetch(Url::new().set_path(&[\"/\", \"foo\"]));\n         let _ = fetch(Request::new(\"https://seed-rs.org\"));\n     }\n }\ndiff --git a/src/browser/fetch/request.rs b/src/browser/fetch/request.rs\nindex a10783a..e0ceab9 100644\n--- a/src/browser/fetch/request.rs\n+++ b/src/browser/fetch/request.rs\n@@ -1,336 +1,342 @@\n //! The Request of the Fetch API.\n \n use super::{fetch, FetchError, Header, Headers, Method, Response, Result};\n use crate::browser::Url;\n use gloo_timers::callback::Timeout;\n use serde::Serialize;\n use std::{borrow::Cow, cell::RefCell, convert::TryFrom, rc::Rc};\n use wasm_bindgen::JsValue;\n \n /// Its methods configure the request, and handle the response. Many of them return the original\n /// struct, and are intended to be used chained together.\n #[derive(Debug, Clone, Default)]\n pub struct Request<'a> {\n     url: Cow<'a, str>,\n     headers: Headers<'a>,\n     method: Method,\n     body: Option<JsValue>,\n     cache: Option<web_sys::RequestCache>,\n     credentials: Option<web_sys::RequestCredentials>,\n     integrity: Option<String>,\n     mode: Option<web_sys::RequestMode>,\n     redirect: Option<web_sys::RequestRedirect>,\n     referrer: Option<String>,\n     referrer_policy: Option<web_sys::ReferrerPolicy>,\n     timeout: Option<u32>,\n     controller: RequestController,\n }\n \n impl<'a> Request<'a> {\n     /// Create new request based on the provided url.\n     ///\n     /// To get a [`Response`](./struct.Response.html) you need to pass\n     /// `Request` to the [`fetch`](./fn.fetch.html) function.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n     pub fn new(url: impl Into<Cow<'a, str>>) -> Self {\n         Self {\n             url: url.into(),\n             ..Self::default()\n         }\n     }\n \n     // TODO: remove when https://github.com/rust-lang/rust-clippy/issues/4979 will be fixed\n     #[allow(clippy::missing_const_for_fn)]\n     /// Set headers for this request.\n     /// It will replace any existing headers.\n     pub fn headers(mut self, headers: Headers<'a>) -> Self {\n         self.headers = headers;\n         self\n     }\n \n     /// Set specific header.\n     pub fn header(mut self, header: Header<'a>) -> Self {\n         self.headers.set(header);\n         self\n     }\n \n     /// Set HTTP method. Default method is `GET`.\n     pub const fn method(mut self, method: Method) -> Self {\n         self.method = method;\n         self\n     }\n \n     /// Set request body to provided `JsValue`. Consider using `json` or `text` methods instead.\n     ///\n     /// ## Panics\n     /// This method will panic when request method is GET or HEAD.\n     pub fn body(mut self, body: JsValue) -> Self {\n         self.body = Some(body);\n \n         #[cfg(debug_assertions)]\n         match self.method {\n             Method::Get | Method::Head => {\n                 error!(\"GET and HEAD requests shoudn't have a body\");\n             }\n             _ => {}\n         }\n \n         self\n     }\n \n     /// Set request body by JSON encoding provided data.\n     /// It will also set `Content-Type` header to `application/json; charset=utf-8`.\n     ///\n     /// # Errors\n     ///\n     /// This method can fail if JSON serialization fail. It will then\n     /// return `FetchError::SerdeError`.\n     pub fn json<T: Serialize + ?Sized>(mut self, data: &T) -> Result<Self> {\n         let body = serde_json::to_string(data).map_err(FetchError::SerdeError)?;\n         self.body = Some(body.into());\n         Ok(self.header(Header::content_type(\"application/json; charset=utf-8\")))\n     }\n \n     /// Set request body to a provided string.\n     /// It will also set `Content-Type` header to `text/plain; charset=utf-8`.\n     pub fn text(mut self, text: impl AsRef<str>) -> Self {\n         self.body = Some(JsValue::from(text.as_ref()));\n         self.header(Header::content_type(\"text/plain; charset=utf-8\"))\n     }\n \n     /// Set request mode.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/mode)\n     pub const fn mode(mut self, mode: web_sys::RequestMode) -> Self {\n         self.mode = Some(mode);\n         self\n     }\n \n     /// Set request credentials.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials)\n     pub const fn credentials(mut self, credentials: web_sys::RequestCredentials) -> Self {\n         self.credentials = Some(credentials);\n         self\n     }\n \n     /// Set request cache mode.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)\n     pub const fn cache(mut self, cache: web_sys::RequestCache) -> Self {\n         self.cache = Some(cache);\n         self\n     }\n \n     /// Set request redirect mode.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/redirect)\n     pub const fn redirect(mut self, redirect: web_sys::RequestRedirect) -> Self {\n         self.redirect = Some(redirect);\n         self\n     }\n \n     /// Set request referrer.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/referrer)\n     pub fn referrer(mut self, referrer: &impl ToString) -> Self {\n         self.referrer = Some(referrer.to_string());\n         self\n     }\n \n     /// Set request referrer policy.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy)\n     pub const fn referrer_policy(mut self, referrer_policy: web_sys::ReferrerPolicy) -> Self {\n         self.referrer_policy = Some(referrer_policy);\n         self\n     }\n \n     /// Set request subresource integrity.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/integrity)\n     pub fn integrity(mut self, integrity: &impl ToString) -> Self {\n         self.integrity = Some(integrity.to_string());\n         self\n     }\n \n     /// Set request timeout in milliseconds.\n     pub fn timeout(mut self, timeout: u32) -> Self {\n         self.timeout = Some(timeout);\n         self\n     }\n \n     /// Get the request controller that allows to abort request or disable request's timeout.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     /// let (request, controller) = Request::new(\"http://example.com\").controller();\n     /// ```\n     pub fn controller(self) -> (Self, RequestController) {\n         let controller = self.controller.clone();\n         (self, controller)\n     }\n \n     /// Fetch request. It's a chainable alternative to `fetch(request)`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     /// orders.perform_cmd({\n     ///     let message = model.new_message.clone();\n     ///     async { Msg::Fetched(send_message(message).await) }\n     /// });\n     /// ...\n     /// async fn send_message(new_message: String) -> fetch::Result<shared::SendMessageResponseBody> {\n     ///     Request::new(get_request_url())\n     ///         .method(Method::Post)\n     ///         .json(&shared::SendMessageRequestBody { text: new_message })?\n     ///         .fetch()\n     ///         .await?\n     ///         .check_status()?\n     ///         .json()\n     ///         .await\n     /// }\n     /// ```\n+    ///\n+    /// ## Errors\n+    ///\n+    /// `fetch` will return `Err` only on network errors. This means that\n+    /// even if you get `Ok` from this function, you still need to check\n+    /// `Response` status for HTTP errors.\n     pub async fn fetch(self) -> Result<Response> {\n         fetch(self).await\n     }\n }\n \n impl<'a, T: Into<Cow<'a, str>>> From<T> for Request<'a> {\n     fn from(s: T) -> Request<'a> {\n         Request::new(s)\n     }\n }\n \n impl<'a> From<Url> for Request<'a> {\n     fn from(url: Url) -> Request<'a> {\n         Request::new(url.to_string())\n     }\n }\n \n impl TryFrom<Request<'_>> for web_sys::Request {\n     type Error = FetchError;\n     fn try_from(request: Request) -> std::result::Result<Self, Self::Error> {\n         let mut init = web_sys::RequestInit::new();\n \n         // headers\n         let headers = web_sys::Headers::new().map_err(FetchError::RequestError)?;\n         for header in request.headers {\n             headers\n                 .append(&header.name, &header.value)\n                 .map_err(FetchError::RequestError)?;\n         }\n         init.headers(&headers);\n \n         // method\n         init.method(request.method.as_str());\n \n         // body\n         if let Some(body) = &request.body {\n             init.body(Some(body));\n         }\n \n         // cache\n         if let Some(cache) = request.cache {\n             init.cache(cache);\n         }\n \n         // credentials\n         if let Some(credentials) = request.credentials {\n             init.credentials(credentials);\n         }\n \n         // integrity\n         if let Some(integrity) = &request.integrity {\n             init.integrity(integrity.as_str());\n         }\n \n         // mode\n         if let Some(mode) = request.mode {\n             init.mode(mode);\n         }\n \n         // redirect\n         if let Some(redirect) = request.redirect {\n             init.redirect(redirect);\n         }\n \n         // referrer\n         if let Some(referrer) = &request.referrer {\n             init.referrer(referrer.as_str());\n         }\n \n         // referrer_policy\n         if let Some(referrer_policy) = request.referrer_policy {\n             init.referrer_policy(referrer_policy);\n         }\n \n         // timeout\n         if let Some(timeout) = &request.timeout {\n             let abort_controller = request.controller.clone();\n             request.controller.timeout_handle.replace(Some(\n                 // abort request on timeout\n                 Timeout::new(*timeout, move || abort_controller.abort()),\n             ));\n         }\n \n         // controller\n         // https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n         init.signal(Some(&request.controller.abort_controller.signal()));\n \n         // It seems that the only reason why Request constructor can\n         // fail is when Url contains credentials.  I assume that this\n         // use case should be extremely rare, so to make api a bit\n         // simplier let's just unwrap it here.\n         //\n         // See https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#Errors\n         web_sys::Request::new_with_str_and_init(&request.url, &init)\n             .map_err(FetchError::RequestError)\n     }\n }\n \n #[allow(clippy::module_name_repetitions)]\n #[derive(Debug, Clone)]\n /// It allows to abort request or disable request's timeout.\n /// You can get it by calling method `Request.controller`.\n pub struct RequestController {\n     abort_controller: Rc<web_sys::AbortController>,\n     timeout_handle: Rc<RefCell<Option<Timeout>>>,\n }\n \n impl RequestController {\n     /// Abort request and disable request's timeout.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort)\n     pub fn abort(&self) {\n         // Cancel timeout by dropping it.\n         self.timeout_handle.replace(None);\n         self.abort_controller.abort();\n     }\n     /// Disable request's timeout.\n     ///\n     /// # Errors\n     ///\n     /// Will return error if timeout is already disabled.\n     pub fn disable_timeout(&self) -> std::result::Result<(), &'static str> {\n         // Cancel timeout by dropping it.\n         match self.timeout_handle.replace(None) {\n             Some(_) => Ok(()),\n             None => Err(\"disable_timeout: already disabled\"),\n         }\n     }\n }\n \n impl Default for RequestController {\n     fn default() -> Self {\n         Self {\n             abort_controller: Rc::new(\n                 web_sys::AbortController::new().expect(\"fetch: create AbortController - failed\"),\n             ),\n             timeout_handle: Rc::new(RefCell::new(None)),\n         }\n     }\n }\ndiff --git a/src/browser/fetch/response.rs b/src/browser/fetch/response.rs\nindex 44cbd11..343e84d 100644\n--- a/src/browser/fetch/response.rs\n+++ b/src/browser/fetch/response.rs\n@@ -1,98 +1,143 @@\n //! The Response interface of the Fetch API represents the response to a request.\n \n use super::{FetchError, Result, Status};\n use serde::de::DeserializeOwned;\n use wasm_bindgen_futures::JsFuture;\n \n /// Response of the fetch request.\n /// To get one you need to use [`fetch`](./fn.fetch.html) function.\n ///\n /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n pub struct Response {\n     pub(crate) raw_response: web_sys::Response,\n }\n \n impl Response {\n     /// Get a `String` from response body.\n     ///\n     /// # Errors\n     /// Returns `FetchError::PromiseError`.\n     pub async fn text(&self) -> Result<String> {\n         Ok(self\n             .raw_response\n             .text()\n             .map_err(FetchError::PromiseError)\n             .map(JsFuture::from)?\n             .await\n             .map_err(FetchError::PromiseError)?\n             .as_string()\n             .expect(\"fetch: Response expected `String` after .text()\"))\n     }\n \n     /// JSON parse response body into provided type.\n     ///\n     /// # Errors\n     /// Returns `FetchError::SerdeError` or `FetchError::PromiseError`.\n     pub async fn json<T: DeserializeOwned + 'static>(&self) -> Result<T> {\n         let text = self.text().await?;\n         serde_json::from_str(&text).map_err(FetchError::SerdeError)\n     }\n \n     /// Return response body as `Vec<u8>`.\n     ///\n     /// # Errors\n     /// Returns `FetchError::PromiseError`.\n     pub async fn bytes(&self) -> Result<Vec<u8>> {\n         Ok(self\n             .raw_response\n             .array_buffer()\n             .map_err(FetchError::PromiseError)\n             .map(JsFuture::from)?\n             .await\n             .map_err(FetchError::PromiseError)\n-            .map(js_sys::Uint8Array::from)?\n+            .map(|array_buffer| js_sys::Uint8Array::new(&array_buffer))?\n             .to_vec())\n     }\n \n     /// Get request status.\n     pub fn status(&self) -> Status {\n         Status::from(&self.raw_response)\n     }\n \n     /// Check that response status is ok (2xx).\n     ///\n     /// ```rust\n     /// fetch(url).await?.check_status()?\n     ///\n     /// ```\n     ///\n     /// Or with combinators:\n     ///\n     /// ```rust\n     /// fetch(url)\n     ///     .map(|result| result.and_then(Response::check_status))\n     ///     .and_then(Response.json)\n     ///     .map(Msg::Fetched)\n     /// ```\n     ///\n     /// # Errors\n     /// Returns `FetchError::StatusError` if status isn't 2xx.\n     pub fn check_status(self) -> Result<Self> {\n         let status = self.status();\n         if status.is_ok() {\n             Ok(self)\n         } else {\n             Err(FetchError::StatusError(status))\n         }\n     }\n \n     /// Get underlying `web_sys::Response`.\n     ///\n     /// This is an escape path if current API can't handle your needs.\n     /// Should you find yourself using it, please consider [opening an issue][issue].\n     ///\n     /// [issue]: https://github.com/seed-rs/seed/issues\n     pub const fn raw_response(&self) -> &web_sys::Response {\n         &self.raw_response\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use wasm_bindgen_test::*;\n+    wasm_bindgen_test_configure!(run_in_browser);\n+    use super::*;\n+    use serde::Deserialize;\n+\n+    #[derive(Deserialize)]\n+    struct Obj {\n+        key: String,\n+    }\n+\n+    #[wasm_bindgen_test]\n+    async fn response_json() {\n+        let response = Response {\n+            raw_response: web_sys::Response::new_with_opt_str(Some(r#\"{ \"key\": \"value\" }\"#))\n+                .unwrap(),\n+        };\n+\n+        let obj: Obj = response.json().await.unwrap();\n+        assert_eq!(obj.key, \"value\");\n+    }\n+\n+    #[wasm_bindgen_test]\n+    async fn response_string() {\n+        let response = Response {\n+            raw_response: web_sys::Response::new_with_opt_str(Some(\"response\")).unwrap(),\n+        };\n+\n+        let string = response.text().await.unwrap();\n+        assert_eq!(string, \"response\");\n+    }\n+\n+    #[wasm_bindgen_test]\n+    async fn response_bytes() {\n+        let mut body = Vec::from(&b\"response\"[..]);\n+        let response = Response {\n+            raw_response: web_sys::Response::new_with_opt_u8_array(Some(&mut body)).unwrap(),\n+        };\n+\n+        let vec = response.bytes().await.unwrap();\n+        assert_eq!(&vec, b\"response\");\n+    }\n+}\ndiff --git a/src/browser/service/fetch.rs b/src/browser/service/fetch.rs\nindex 4f0fcb9..a6000cb 100644\n--- a/src/browser/service/fetch.rs\n+++ b/src/browser/service/fetch.rs\n@@ -1,692 +1,690 @@\n #![deprecated(\n     since = \"0.7.0\",\n     note = \"Please use [`seed::browser::fetch`](../../fetch/index.html) module instead\"\n )]\n \n //! High-level interface for `web_sys` HTTP requests.\n use std::future::Future;\n \n use gloo_timers::callback::Timeout;\n use serde::{de::DeserializeOwned, Serialize};\n-use serde_json;\n use std::{borrow::Cow, cell::RefCell, collections::HashMap, convert::identity, rc::Rc};\n use wasm_bindgen::JsValue;\n use wasm_bindgen_futures::JsFuture;\n-use web_sys;\n \n // ---------- Aliases for foreign types ----------\n \n pub type DomException = web_sys::DomException;\n \n // ---------- Aliases ----------\n \n /// Return type for `FetchObject.response()`.\n pub type ResponseResult<T> = Result<Response<T>, FailReason<T>>;\n \n /// Return type for `FetchObject.response_data()`.\n pub type ResponseDataResult<T> = Result<T, FailReason<T>>;\n \n /// Type for `FetchObject.result`.\n #[allow(clippy::module_name_repetitions)]\n pub type FetchResult<T> = Result<ResponseWithDataResult<T>, RequestError>;\n \n /// Type for `ResponseWithDataResult.data`.\n pub type DataResult<T> = Result<T, DataError>;\n \n type Json = String;\n \n // ---------- FetchObject ----------\n \n #[derive(Debug, Clone)]\n /// Return type for `Request.fetch*` methods.\n #[allow(clippy::module_name_repetitions)]\n pub struct FetchObject<T> {\n     pub request: Request,\n     pub result: FetchResult<T>,\n }\n \n impl<T> FetchObject<T> {\n     #[allow(clippy::missing_errors_doc)]\n     /// Get successful `Response` (status code 100-399) or `FailReason`.\n     pub fn response(self) -> ResponseResult<T> {\n         let response = match self.result {\n             // `request_error` means that request was aborted, timed out, there was network error etc.\n             Err(ref request_error) => {\n                 return Err(FailReason::RequestError(request_error.clone(), self))\n             }\n             Ok(ref response) => response,\n         };\n \n         if response.status.is_error() {\n             // Response status code is in range 400-599.\n             return Err(FailReason::Status(response.status.clone(), self));\n         }\n \n         if let Err(ref data_error) = response.data {\n             // Converting body data to required type (String, JSON...) failed.\n             return Err(FailReason::DataError(data_error.clone(), self));\n         }\n \n         let response = self.result.unwrap();\n         Ok(Response {\n             raw: response.raw,\n             status: response.status,\n             data: response.data.unwrap(),\n         })\n     }\n \n     #[allow(clippy::missing_errors_doc)]\n     /// Get successful `Response` data or `FailReason`.\n     pub fn response_data(self) -> ResponseDataResult<T> {\n         self.response().map(|response| response.data)\n     }\n }\n \n // ---------- Fails ----------\n \n #[derive(Debug, Clone)]\n // @TODO use https://github.com/rust-lang-nursery/failure?\n pub enum FailReason<T> {\n     RequestError(RequestError, FetchObject<T>),\n     Status(Status, FetchObject<T>),\n     DataError(DataError, FetchObject<T>),\n }\n \n #[derive(Debug, Clone)]\n pub enum RequestError {\n     DomException(web_sys::DomException),\n }\n \n #[derive(Debug, Clone)]\n pub enum DataError {\n     DomException(web_sys::DomException),\n     SerdeError(Rc<serde_json::Error>, Json),\n }\n \n // ---------- RequestController ----------\n \n #[derive(Debug, Clone)]\n /// It allows to abort request or disable request's timeout.\n /// You can get it by calling method `Request.controller`.\n pub struct RequestController {\n     abort_controller: Rc<web_sys::AbortController>,\n     timeout_handle: Rc<RefCell<Option<Timeout>>>,\n }\n \n impl RequestController {\n     /// Abort request and disable request's timeout.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort)\n     pub fn abort(&self) {\n         // Cancel timeout by dropping it.\n         self.timeout_handle.replace(None);\n         self.abort_controller.abort();\n     }\n     /// Disable request's timeout.\n     ///\n     /// # Errors\n     ///\n     /// Will return error if timeout is already disabled.\n     pub fn disable_timeout(&self) -> Result<(), &'static str> {\n         // Cancel timeout by dropping it.\n         match self.timeout_handle.replace(None) {\n             Some(_) => Ok(()),\n             None => Err(\"disable_timeout: already disabled\"),\n         }\n     }\n }\n \n impl Default for RequestController {\n     fn default() -> Self {\n         Self {\n             abort_controller: Rc::new(\n                 web_sys::AbortController::new().expect(\"fetch: create AbortController - failed\"),\n             ),\n             timeout_handle: Rc::new(RefCell::new(None)),\n         }\n     }\n }\n \n // ---------- Response Status ----------\n \n #[derive(Debug, Clone, PartialEq)]\n pub enum StatusCategory {\n     /// Code 1xx\n     Informational,\n     /// Code 2xx\n     Success,\n     /// Code 3xx\n     Redirection,\n     /// Code 4xx\n     ClientError,\n     /// Code 5xx\n     ServerError,\n     /// Code < 100 || Code >= 600\n     Unknown,\n }\n \n #[derive(Debug, Clone)]\n /// Response status.\n ///\n /// It's intended to create `Status` from `web_sys::Response` - eg: `Status::from(&raw_response)`.\n pub struct Status {\n     /// Code examples: 200, 404, ...\n     pub code: u16,\n     /// Text examples: \"OK\", \"Not Found\", ...\n     pub text: String,\n     pub category: StatusCategory,\n }\n \n #[allow(dead_code)]\n impl Status {\n     /// Is response status category `ClientError` or `ServerError`? (Code 400-599)\n     pub fn is_error(&self) -> bool {\n         match self.category {\n             StatusCategory::ClientError | StatusCategory::ServerError => true,\n             _ => false,\n         }\n     }\n     /// Is response status category `Success`? (Code 200-299)\n     pub fn is_ok(&self) -> bool {\n         self.category == StatusCategory::Success\n     }\n }\n \n impl From<&web_sys::Response> for Status {\n     fn from(response: &web_sys::Response) -> Self {\n         let text = response.status_text();\n         match response.status() {\n             code @ 100..=199 => Status {\n                 code,\n                 text,\n                 category: StatusCategory::Informational,\n             },\n             code @ 200..=299 => Status {\n                 code,\n                 text,\n                 category: StatusCategory::Success,\n             },\n             code @ 300..=399 => Status {\n                 code,\n                 text,\n                 category: StatusCategory::Redirection,\n             },\n             code @ 400..=499 => Status {\n                 code,\n                 text,\n                 category: StatusCategory::ClientError,\n             },\n             code @ 500..=599 => Status {\n                 code,\n                 text,\n                 category: StatusCategory::ServerError,\n             },\n             code => Status {\n                 code,\n                 text,\n                 category: StatusCategory::Unknown,\n             },\n         }\n     }\n }\n \n // ---------- Response ----------\n \n #[derive(Debug, Clone)]\n pub struct Response<T> {\n     pub raw: web_sys::Response,\n     pub status: Status,\n     pub data: T,\n }\n \n #[derive(Debug, Clone)]\n pub struct ResponseWithDataResult<T> {\n     pub raw: web_sys::Response,\n     pub status: Status,\n     pub data: DataResult<T>,\n }\n \n // ---------- Method ----------\n \n /// HTTP Method types.\n ///\n /// [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)\n #[derive(Debug, Clone, Copy)]\n pub enum Method {\n     Get,\n     Head,\n     Post,\n     Put,\n     Delete,\n     Connect,\n     Options,\n     Trace,\n     Patch,\n }\n \n impl Method {\n     fn as_str(&self) -> &str {\n         match *self {\n             Method::Get => \"GET\",\n             Method::Head => \"HEAD\",\n             Method::Post => \"POST\",\n             Method::Put => \"PUT\",\n             Method::Delete => \"DELETE\",\n             Method::Connect => \"CONNECT\",\n             Method::Options => \"OPTIONS\",\n             Method::Trace => \"TRACE\",\n             Method::Patch => \"PATCH\",\n         }\n     }\n }\n \n impl Default for Method {\n     fn default() -> Self {\n         Method::Get\n     }\n }\n \n // ---------- Request ----------\n \n /// Request is the entry point for all fetch requests.\n /// Its methods configure the request, and handle the response. Many of them return the original\n /// struct, and are intended to be used chained together.\n #[derive(Debug, Clone, Default)]\n pub struct Request {\n     url: Cow<'static, str>,\n     headers: HashMap<String, String>,\n     method: Method,\n     body: Option<JsValue>,\n     cache: Option<web_sys::RequestCache>,\n     credentials: Option<web_sys::RequestCredentials>,\n     integrity: Option<String>,\n     mode: Option<web_sys::RequestMode>,\n     redirect: Option<web_sys::RequestRedirect>,\n     referrer: Option<String>,\n     referrer_policy: Option<web_sys::ReferrerPolicy>,\n     timeout: Option<u32>,\n     controller: RequestController,\n }\n \n impl Request {\n     // ------ PUBLIC ------\n \n     pub fn new(url: impl Into<Cow<'static, str>>) -> Self {\n         Self {\n             url: url.into(),\n             ..Self::default()\n         }\n     }\n \n     /// Set the HTTP method.\n     /// Default is GET.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)\n     pub const fn method(mut self, method: Method) -> Self {\n         self.method = method;\n         self\n     }\n \n     /// Add a single header.\n     /// String multiple calls to this together to add multiple ones.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)\n     pub fn header(mut self, name: &str, value: &str) -> Self {\n         self.headers.insert(name.into(), value.into());\n         self\n     }\n \n     pub fn body(mut self, body: JsValue) -> Self {\n         self.body = Some(body);\n         self\n     }\n \n     /// Serialize a Rust data structure as JSON; eg the payload in a POST request.\n     /// _Note_: If you want to setup `Content-Type` header automatically, use method `send_json`.\n     pub fn body_json<T: Serialize>(self, body_json: &T) -> Self {\n         let json =\n             serde_json::to_string(body_json).expect(\"fetch: serialize body to JSON - failed\");\n         let json_as_js_value = JsValue::from_str(&json);\n         self.body(json_as_js_value)\n     }\n \n     /// Set body to serialized `data`\n     /// and set header `Content-Type` to `application/json; charset=utf-8`.\n     pub fn send_json<T: Serialize>(self, data: &T) -> Self {\n         self.header(\"Content-Type\", \"application/json; charset=utf-8\")\n             .body_json(data)\n     }\n \n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)\n     pub fn cache(mut self, cache: web_sys::RequestCache) -> Self {\n         self.cache = Some(cache);\n         self\n     }\n \n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials)\n     pub fn credentials(mut self, request_credentials: web_sys::RequestCredentials) -> Self {\n         self.credentials = Some(request_credentials);\n         self\n     }\n \n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/integrity)\n     pub fn integrity(mut self, integrity: &str) -> Self {\n         self.integrity = Some(integrity.into());\n         self\n     }\n \n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/mode)\n     pub fn mode(mut self, mode: web_sys::RequestMode) -> Self {\n         self.mode = Some(mode);\n         self\n     }\n \n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/redirect)\n     pub fn redirect(mut self, redirect: web_sys::RequestRedirect) -> Self {\n         self.redirect = Some(redirect);\n         self\n     }\n \n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/referrer)\n     pub fn referrer(mut self, referrer: String) -> Self {\n         self.referrer = Some(referrer);\n         self\n     }\n \n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy)\n     pub fn referrer_policy(mut self, referrer_policy: web_sys::ReferrerPolicy) -> Self {\n         self.referrer_policy = Some(referrer_policy);\n         self\n     }\n \n     /// Enable request timeout and set it to given milliseconds.\n     pub fn timeout(mut self, millis: u32) -> Self {\n         self.timeout = Some(millis);\n         self\n     }\n \n     /// Get request controller through callback function.\n     /// You can use controller to abort request or disable timeout.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///fn send_request(\n     ///    request_controller: &mut Option<fetch::RequestController>\n     ///) -> impl Future<Item=Msg, Error=Msg> {\n     ///    fetch::Request::new(get_request_url())\n     ///        .controller(|controller| *request_controller = Some(controller))\n     ///        .fetch_string(Msg::Fetched)\n     ///}\n     /// ```\n     pub fn controller(self, controller_transferrer: impl FnOnce(RequestController)) -> Self {\n         controller_transferrer(self.controller.clone());\n         self\n     }\n \n     /// Fetch.\n     ///\n     /// It never fails. Use callback `f` to map `FetchObject<()>`.\n     /// E.g.: You can use `std::convert::identity` as `f`\n     /// to return `Result<FetchObject<()>, FetchObject<()>`.\n     ///\n     /// It's lazy - fetching is started when `Future` is executed.\n     ///\n     /// It always set `FetchObject.result->ResponseWithDataResult` field `data` to `Ok(())` -\n     /// if you want to get body data, you have to use field `raw` to get raw `web_sys::Response`.\n     /// (Or use methods like `fetch_string` / `fetch_json`.)\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///async fn send_request() -> Result<Msg, Msg> {\n     ///    fetch::Request::new(get_request_url())\n     ///        .fetch(Msg::Fetched)\n     ///        .await\n     ///}\n     /// ```\n     pub async fn fetch<U>(self, f: impl FnOnce(FetchObject<()>) -> U) -> U\n     where\n         U: 'static,\n     {\n         let fetch_result = self\n             .send_request()\n             .await\n             .map(|raw_response: web_sys::Response| ResponseWithDataResult {\n                 status: Status::from(&raw_response),\n                 raw: raw_response,\n                 data: Ok(()),\n             })\n             .map_err(|js_value_error| RequestError::DomException(js_value_error.into()));\n         f(FetchObject {\n             request: self,\n             result: fetch_result,\n         })\n     }\n \n     /// Same as method `fetch`, but try to convert body to `String` and insert it into `Response` field `data`.\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Body/text]\n     pub async fn fetch_string<U>(self, f: impl FnOnce(FetchObject<String>) -> U) -> U\n     where\n         U: 'static,\n     {\n         let fetch_object = self.fetch(identity).await;\n         let fetch_result = fetch_object.result;\n         let request = fetch_object.request;\n \n         let fetch_object = match fetch_result {\n             // There was problem with fetching - just change generic parameter from () to String.\n             Err(request_error) => FetchObject::<String> {\n                 request,\n                 result: Err(request_error),\n             },\n             Ok(response) => {\n                 match response.raw.text() {\n                     // Converting body to String failed.\n                     Err(js_value_error) => FetchObject::<String> {\n                         request,\n                         result: Ok(ResponseWithDataResult {\n                             raw: response.raw,\n                             status: response.status,\n                             data: Err(DataError::DomException(js_value_error.into())),\n                         }),\n                     },\n                     Ok(promise) => {\n                         let js_future_result = JsFuture::from(promise).await;\n                         match js_future_result {\n                             // Converting `promise` to `JsFuture` failed.\n                             Err(js_value_error) => FetchObject::<String> {\n                                 request,\n                                 result: Ok(ResponseWithDataResult {\n                                     raw: response.raw,\n                                     status: response.status,\n                                     data: Err(DataError::DomException(js_value_error.into())),\n                                 }),\n                             },\n                             Ok(js_value) => {\n                                 // Converting from body.text() result to String should never fail,\n                                 // so `expect` should be enough.\n                                 let text = js_value\n                                     .as_string()\n                                     .expect(\"fetch: cannot convert js_value to string\");\n                                 FetchObject::<String> {\n                                     request,\n                                     result: Ok(ResponseWithDataResult {\n                                         raw: response.raw,\n                                         status: response.status,\n                                         data: Ok(text),\n                                     }),\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n         };\n         f(fetch_object)\n     }\n \n     /// Fetch and then convert body to `String`. It passes `ResponseDataResult<String>` into callback `f`.\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Body/text)\n     pub fn fetch_string_data<U>(\n         self,\n         f: impl FnOnce(ResponseDataResult<String>) -> U,\n     ) -> impl Future<Output = U>\n     where\n         U: 'static,\n     {\n         self.fetch_string(|fetch_object| f(fetch_object.response_data()))\n     }\n \n     /// Same as method `fetch`, but try to deserialize body and insert it into `Response` field `data`.\n     pub async fn fetch_json<T, U>(self, f: impl FnOnce(FetchObject<T>) -> U) -> U\n     where\n         T: DeserializeOwned + 'static,\n         U: 'static,\n     {\n         let fetch_object = self.fetch_string(identity).await;\n         let fetch_result = fetch_object.result;\n         let request = fetch_object.request;\n \n         let fetch_object = match fetch_result {\n             // There was problem with fetching - just change generic parameter from String to T.\n             Err(request_error) => FetchObject::<T> {\n                 request,\n                 result: Err(request_error),\n             },\n             Ok(response) => {\n                 match response.data {\n                     // There was problem with converting to String\n                     // - just change generic parameter from String to T.\n                     Err(data_error) => FetchObject::<T> {\n                         request,\n                         result: Ok(ResponseWithDataResult {\n                             raw: response.raw,\n                             status: response.status,\n                             data: Err(data_error),\n                         }),\n                     },\n                     Ok(text) => {\n                         match serde_json::from_str(&text) {\n                             // Deserialization failed.\n                             Err(serde_error) => FetchObject::<T> {\n                                 request,\n                                 result: Ok(ResponseWithDataResult {\n                                     raw: response.raw,\n                                     status: response.status,\n                                     data: Err(DataError::SerdeError(Rc::new(serde_error), text)),\n                                 }),\n                             },\n                             Ok(value) => FetchObject::<T> {\n                                 request,\n                                 result: Ok(ResponseWithDataResult {\n                                     raw: response.raw,\n                                     status: response.status,\n                                     data: Ok(value),\n                                 }),\n                             },\n                         }\n                     }\n                 }\n             }\n         };\n         f(fetch_object)\n     }\n \n     /// Fetch and then deserialize body to `T`. It passes `ResponseDataResult<T>` into callback `f`.\n     pub fn fetch_json_data<T, U>(\n         self,\n         f: impl FnOnce(ResponseDataResult<T>) -> U,\n     ) -> impl Future<Output = U>\n     where\n         T: DeserializeOwned + 'static,\n         U: 'static,\n     {\n         self.fetch_json(|fetch_object| f(fetch_object.response_data()))\n     }\n \n     // ------ PRIVATE ------\n \n     async fn send_request(&self) -> Result<web_sys::Response, JsValue> {\n         let request_init = self.init_request_and_start_timeout();\n \n         let fetch_promise = web_sys::window()\n             .expect(\"fetch: cannot find window\")\n             .fetch_with_str_and_init(&self.url, &request_init);\n \n         JsFuture::from(fetch_promise).await.map(Into::into)\n     }\n \n     fn init_request_and_start_timeout(&self) -> web_sys::RequestInit {\n         let mut init = web_sys::RequestInit::new();\n \n         // headers\n         let headers = web_sys::Headers::new().expect(\"fetch: cannot create headers\");\n         for (name, value) in &self.headers {\n             headers\n                 .append(name.as_str(), value.as_str())\n                 .expect(\"fetch: cannot create header\")\n         }\n         init.headers(&headers);\n \n         // method\n         init.method(self.method.as_str());\n \n         // body\n         if let Some(body) = &self.body {\n             init.body(Some(body));\n         }\n \n         // cache\n         if let Some(cache) = self.cache {\n             init.cache(cache);\n         }\n \n         // credentials\n         if let Some(credentials) = self.credentials {\n             init.credentials(credentials);\n         }\n \n         // integrity\n         if let Some(integrity) = &self.integrity {\n             init.integrity(integrity.as_str());\n         }\n \n         // mode\n         if let Some(mode) = self.mode {\n             init.mode(mode);\n         }\n \n         // redirect\n         if let Some(redirect) = self.redirect {\n             init.redirect(redirect);\n         }\n \n         // referrer\n         if let Some(referrer) = &self.referrer {\n             init.referrer(referrer.as_str());\n         }\n \n         // referrer_policy\n         if let Some(referrer_policy) = self.referrer_policy {\n             init.referrer_policy(referrer_policy);\n         }\n \n         // timeout\n         if let Some(timeout) = &self.timeout {\n             let abort_controller = self.controller.clone();\n             *self.controller.timeout_handle.borrow_mut() = Some(\n                 // abort request on timeout\n                 Timeout::new(*timeout, move || abort_controller.abort()),\n             );\n         }\n \n         // controller\n         // https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n         init.signal(Some(&self.controller.abort_controller.signal()));\n \n         init\n     }\n }\ndiff --git a/src/browser/url.rs b/src/browser/url.rs\nindex 5bad934..90b8e4b 100644\n--- a/src/browser/url.rs\n+++ b/src/browser/url.rs\n@@ -1,534 +1,782 @@\n use crate::browser::util;\n use serde::{Deserialize, Serialize};\n-use std::{borrow::Cow, fmt, str::FromStr};\n+use std::{borrow::Cow, collections::BTreeMap, fmt, str::FromStr};\n use wasm_bindgen::JsValue;\n \n pub const DUMMY_BASE_URL: &str = \"http://example.com\";\n \n+// ------ Url ------\n+\n /// URL used for routing.\n ///\n /// - It represents relative URL.\n /// - Two, almost identical, `Url`s that differ only with differently advanced\n /// internal path or hash path iterators (e.g. `next_path_part()` was called on one of them)\n /// are considered different also during comparison.\n ///\n /// (If the features above are problems for you, create an [issue](https://github.com/seed-rs/seed/issues/new))\n #[derive(Clone, Debug, Default, Serialize, Deserialize, PartialEq)]\n pub struct Url {\n     next_path_part_index: usize,\n     next_hash_path_part_index: usize,\n     path: Vec<String>,\n     hash_path: Vec<String>,\n     hash: Option<String>,\n-    search: Option<String>,\n+    search: UrlSearch,\n+    invalid_components: Vec<String>,\n }\n \n impl Url {\n     /// Creates a new `Url` with the empty path.\n     pub fn new() -> Self {\n         Self::default()\n     }\n \n     /// Change the browser URL, but do not trigger a page load.\n     ///\n     /// This will add a new entry to the browser history.\n     ///\n     /// # References\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History_API)\n     pub fn go_and_push(&self) {\n         // We use data to evaluate the path instead of the path displayed in the url.\n         let data = JsValue::from_str(\n             &serde_json::to_string(&self).expect(\"Problem serializing route data\"),\n         );\n \n         util::history()\n             .push_state_with_url(&data, \"\", Some(&self.to_string()))\n             .expect(\"Problem pushing state\");\n     }\n \n     /// Change the browser URL, but do not trigger a page load.\n     ///\n     /// This will NOT add a new entry to the browser history.\n     ///\n     /// # References\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/History_API)\n     pub fn go_and_replace(&self) {\n         // We use data to evaluate the path instead of the path displayed in the url.\n         let data = JsValue::from_str(\n             &serde_json::to_string(&self).expect(\"Problem serializing route data\"),\n         );\n \n         util::history()\n             .replace_state_with_url(&data, \"\", Some(&self.to_string()))\n             .expect(\"Problem pushing state\");\n     }\n \n     /// Creates a new `Url` from the one that is currently set in the browser.\n     pub fn current() -> Url {\n         let current_url = util::window().location().href().expect(\"get `href`\");\n         Url::from_str(&current_url).expect(\"create `web_sys::Url` from the current URL\")\n     }\n \n     /// Advances the internal path iterator and returns the next path part as `Option<&str>`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///match url.next_path_part() {\n     ///    None => Page::Home,\n     ///    Some(\"report\") => Page::Report(page::report::init(url)),\n     ///    _ => Page::Unknown(url),\n     ///}\n     /// ````\n     pub fn next_path_part(&mut self) -> Option<&str> {\n         let path_part = self.path.get(self.next_path_part_index);\n         if path_part.is_some() {\n             self.next_path_part_index += 1;\n         }\n         path_part.map(String::as_str)\n     }\n \n     /// Advances the internal hash path iterator and returns the next hash path part as `Option<&str>`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///match url.next_hash_path_part() {\n     ///    None => Page::Home,\n     ///    Some(\"report\") => Page::Report(page::report::init(url)),\n     ///    _ => Page::Unknown(url),\n     ///}\n     /// ````\n     pub fn next_hash_path_part(&mut self) -> Option<&str> {\n         let hash_path_part = self.hash_path.get(self.next_hash_path_part_index);\n         if hash_path_part.is_some() {\n             self.next_hash_path_part_index += 1;\n         }\n         hash_path_part.map(String::as_str)\n     }\n \n     /// Collects the internal path iterator and returns it as `Vec<&str>`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///match url.remaining_path_parts().as_slice() {\n     ///    [\"\"] | [] => Page::Home,\n     ///    [\"report\", rest @ ..] => {\n     ///        match rest {\n     ///            [\"day\"] => Page::ReportDay,\n     ///            _ => Page::ReportWeek,\n     ///        }\n     ///    },\n     ///    _ => Page::NotFound,\n     ///}\n     /// ````\n     pub fn remaining_path_parts(&mut self) -> Vec<&str> {\n         let path_part_index = self.next_path_part_index;\n         self.next_path_part_index = self.path.len();\n         self.path\n             .iter()\n             .skip(path_part_index)\n             .map(String::as_str)\n             .collect()\n     }\n \n     /// Collects the internal hash path iterator and returns it as `Vec<&str>`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///match url.remaining_hash_path_parts().as_slice() {\n     ///    [\"\"] | [] => Page::Home,\n     ///    [\"report\", rest @ ..] => {\n     ///        match rest {\n     ///            [\"day\"] => Page::ReportDay,\n     ///            _ => Page::ReportWeek,\n     ///        }\n     ///    },\n     ///    _ => Page::NotFound,\n     ///}\n     /// ````\n     pub fn remaining_hash_path_parts(&mut self) -> Vec<&str> {\n         let hash_path_part_index = self.next_hash_path_part_index;\n         self.next_hash_path_part_index = self.hash_path.len();\n         self.hash_path\n             .iter()\n             .skip(hash_path_part_index)\n             .map(String::as_str)\n             .collect()\n     }\n \n     /// Adds given path part and returns updated `Url`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///let link_to_blog = url.add_path_part(\"blog\");\n     /// ````\n     pub fn add_path_part(mut self, path_part: impl Into<String>) -> Self {\n         self.path.push(path_part.into());\n         self\n     }\n \n     /// Adds given hash path part and returns updated `Url`.\n     /// It also changes `hash`.\n     ///\n     /// # Example\n     ///\n     /// ```rust,no_run\n     ///let link_to_blog = url.add_hash_path_part(\"blog\");\n     /// ````\n     pub fn add_hash_path_part(mut self, hash_path_part: impl Into<String>) -> Self {\n         self.hash_path.push(hash_path_part.into());\n         self.hash = Some(self.hash_path.join(\"/\"));\n         self\n     }\n \n     /// Clone the `Url` and strip remaining path parts.\n     pub fn to_base_url(&self) -> Self {\n         let mut url = self.clone();\n         url.path.truncate(self.next_path_part_index);\n         url\n     }\n \n     /// Clone the `Url` and strip remaining hash path parts.\n     pub fn to_hash_base_url(&self) -> Self {\n         let mut url = self.clone();\n         url.hash_path.truncate(self.next_hash_path_part_index);\n         url\n     }\n \n     /// Sets path and returns updated `Url`. It also resets internal path iterator.\n     ///\n     /// # Example\n     ///\n     /// ```rust, no_run\n     /// Url::new().set_path(&[\"my\", \"path\"])\n     /// ```\n     ///\n     /// # Refenences\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/pathname)\n     pub fn set_path<T: ToString>(\n         mut self,\n         into_path_iterator: impl IntoIterator<Item = T>,\n     ) -> Self {\n         self.path = into_path_iterator\n             .into_iter()\n             .map(|p| p.to_string())\n             .collect();\n         self.next_path_part_index = 0;\n         self\n     }\n \n     /// Sets hash path and returns updated `Url`.\n     /// It also resets internal hash path iterator and sets `hash`.\n     ///\n     /// # Example\n     ///\n     /// ```rust, no_run\n     /// Url::new().set_hash_path(&[\"my\", \"path\"])\n     /// ```\n     ///\n     /// # Refenences\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/pathname)\n     pub fn set_hash_path<T: ToString>(\n         mut self,\n         into_hash_path_iterator: impl IntoIterator<Item = T>,\n     ) -> Self {\n         self.hash_path = into_hash_path_iterator\n             .into_iter()\n             .map(|p| p.to_string())\n             .collect();\n         self.next_hash_path_part_index = 0;\n         self.hash = Some(self.hash_path.join(\"/\"));\n         self\n     }\n \n     /// Sets hash and returns updated `Url`.\n     /// I also sets `hash_path`.\n     ///\n     /// # Example\n     ///\n     /// ```rust, no_run\n     /// Url::new().set_hash(\"my_hash\")\n     /// ```\n     ///\n     /// # References\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/hash)\n     pub fn set_hash(mut self, hash: impl Into<String>) -> Self {\n         let hash = hash.into();\n         self.hash_path = hash.split('/').map(ToOwned::to_owned).collect();\n         self.hash = Some(hash);\n         self\n     }\n \n     /// Sets search and returns updated `Url`.\n     ///\n     /// # Example\n     ///\n     /// ```rust, no_run\n-    /// Url::new().set_search(\"x=1&y=2\")\n+    /// Url::new().set_search(UrlSearch::new(vec![\n+    ///     (\"x\", vec![\"1\"]),\n+    ///     (\"sort_by\", vec![\"date\", \"name\"]),\n+    /// ])\n     /// ```\n     ///\n     /// # Refenences\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/search)\n-    pub fn set_search(mut self, search: impl Into<String>) -> Self {\n-        self.search = Some(search.into());\n+    pub fn set_search(mut self, search: impl Into<UrlSearch>) -> Self {\n+        self.search = search.into();\n         self\n     }\n \n     /// Get path.\n     ///\n     /// # Refenences\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/pathname)\n     pub fn path(&self) -> &[String] {\n         &self.path\n     }\n \n     /// Get hash path.\n     pub fn hash_path(&self) -> &[String] {\n         &self.path\n     }\n \n     /// Get hash.\n     ///\n     /// # References\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/hash)\n     pub fn hash(&self) -> Option<&String> {\n         self.hash.as_ref()\n     }\n \n     /// Get search.\n     ///\n     /// # Refenences\n     /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/search)\n-    pub fn search(&self) -> Option<&String> {\n-        self.search.as_ref()\n+    pub const fn search(&self) -> &UrlSearch {\n+        &self.search\n+    }\n+\n+    /// Get mutable search.\n+    ///\n+    /// # Refenences\n+    /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/URL/search)\n+    pub fn search_mut(&mut self) -> &mut UrlSearch {\n+        &mut self.search\n     }\n \n     /// Change the browser URL and trigger a page load.\n     pub fn go_and_load(&self) {\n         util::window()\n             .location()\n             .set_href(&self.to_string())\n             .expect(\"set location href\");\n     }\n \n     /// Change the browser URL and trigger a page load.\n     ///\n     /// Provided `url` isn't checked and it's passed into `location.href`.\n     pub fn go_and_load_with_str(url: impl AsRef<str>) {\n         util::window()\n             .location()\n             .set_href(url.as_ref())\n             .expect(\"set location href\");\n     }\n \n     /// Trigger a page reload.\n     pub fn reload() {\n         util::window().location().reload().expect(\"reload location\");\n     }\n \n     /// Trigger a page reload and force reloading from the server.\n     pub fn reload_and_skip_cache() {\n         util::window()\n             .location()\n             .reload_with_forceget(true)\n             .expect(\"reload location with forceget\");\n     }\n \n     /// Move back in `History`.\n     ///\n     /// - `steps: 0` only reloads the current page.\n     /// - Negative steps move you forward - use rather `Url::go_forward` instead.\n     /// - If there is no previous page, this call does nothing.\n     pub fn go_back(steps: i32) {\n         util::history().go_with_delta(-steps).expect(\"go back\");\n     }\n \n     /// Move back in `History`.\n     ///\n     /// - `steps: 0` only reloads the current page.\n     /// - Negative steps move you back - use rather `Url::go_back` instead.\n     /// - If there is no next page, this call does nothing.\n     pub fn go_forward(steps: i32) {\n         util::history().go_with_delta(steps).expect(\"go forward\");\n     }\n \n     /// If the current `Url`'s path prefix is equal to `path_base`,\n     /// then reset the internal path iterator and advance it to skip the prefix (aka `path_base`).\n     ///\n     /// It's used mostly by Seed internals, but it can be useful in combination\n     /// with `orders.clone_base_path()`.\n     pub fn skip_base_path(mut self, path_base: &[String]) -> Self {\n         if self.path.starts_with(path_base) {\n             self.next_path_part_index = path_base.len();\n         }\n         self\n     }\n+\n+    /// Decodes a Uniform Resource Identifier (URI) component.\n+    /// Aka percent-decoding.\n+    ///\n+    /// _Note:_ All components are automatically decoded when it's possible.\n+    /// You can find undecodable components in the vector\n+    /// returned from methods `invalid_components` or `invalid_components_mut`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,no_run\n+    /// Url::decode_uri_component(\"Hello%20G%C3%BCnter\"); // => \"Hello G\u00fcnter\"\n+    /// ```\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns error when decoding fails - e.g. _\"Error: malformed URI sequence\"_.\n+    pub fn decode_uri_component(component: impl AsRef<str>) -> Result<String, JsValue> {\n+        let decoded = js_sys::decode_uri_component(component.as_ref())?;\n+        Ok(String::from(decoded))\n+    }\n+\n+    /// Get invalid components.\n+    ///\n+    /// Undecodable / unparsable components are invalid.\n+    pub fn invalid_components(&self) -> &[String] {\n+        &self.invalid_components\n+    }\n+\n+    /// Get mutable invalid components.\n+    ///\n+    /// Undecodable / unparsable components are invalid.\n+    pub fn invalid_components_mut(&mut self) -> &mut Vec<String> {\n+        &mut self.invalid_components\n+    }\n }\n \n+/// `Url` components are automatically encoded.\n impl fmt::Display for Url {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let url = web_sys::Url::new_with_base(&self.path.join(\"/\"), DUMMY_BASE_URL)\n             .expect(\"create native url\");\n \n-        if let Some(search) = &self.search {\n-            url.set_search(search);\n-        }\n+        url.set_search(&self.search.to_string());\n \n         if let Some(hash) = &self.hash {\n             url.set_hash(hash);\n         }\n         // @TODO replace with `strip_prefix` once stable.\n         write!(fmt, \"{}\", &url.href().trim_start_matches(DUMMY_BASE_URL))\n     }\n }\n \n impl<'a> From<&'a Url> for Cow<'a, Url> {\n     fn from(url: &'a Url) -> Cow<'a, Url> {\n         Cow::Borrowed(url)\n     }\n }\n \n impl<'a> From<Url> for Cow<'a, Url> {\n     fn from(url: Url) -> Cow<'a, Url> {\n         Cow::Owned(url)\n     }\n }\n \n impl FromStr for Url {\n     type Err = String;\n \n     /// Creates a new `Url` from `&str`.\n     ///\n     /// # Errors\n     ///\n-    /// Returns error when `url` is invalid.\n+    /// Returns error when `url` cannot be parsed.\n+    ///\n+    /// _Note:_ When only some components are undecodable, no error is returned -\n+    /// that components are saved into the `Url`s `invalid_components` - see methods\n+    /// `Url::invalid_components` and `Url::invalid_components_mut`.\n     fn from_str(str_url: &str) -> Result<Self, Self::Err> {\n         web_sys::Url::new_with_base(str_url, DUMMY_BASE_URL)\n             .map(|url| Url::from(&url))\n             .map_err(|_| format!(\"`{}` is invalid relative URL\", str_url))\n     }\n }\n \n impl From<&web_sys::Url> for Url {\n     /// Creates a new `Url` from the browser native url.\n+    /// `Url`'s components are decoded if possible. When decoding fails, the component is cloned\n+    /// into `invalid_components` and the original value is used.\n     fn from(url: &web_sys::Url) -> Self {\n+        let mut invalid_components = Vec::<String>::new();\n+\n         let path = {\n             let path = url.pathname();\n             path.split('/')\n                 .filter_map(|path_part| {\n                     if path_part.is_empty() {\n                         None\n                     } else {\n-                        Some(path_part.to_owned())\n+                        let path_part = match Url::decode_uri_component(path_part) {\n+                            Ok(decoded_path_part) => decoded_path_part,\n+                            Err(_) => {\n+                                invalid_components.push(path_part.to_owned());\n+                                path_part.to_owned()\n+                            }\n+                        };\n+                        Some(path_part)\n                     }\n                 })\n                 .collect::<Vec<_>>()\n         };\n \n         let hash = {\n             let mut hash = url.hash();\n             if hash.is_empty() {\n                 None\n             } else {\n                 // Remove leading `#`.\n                 hash.remove(0);\n+                let hash = match Url::decode_uri_component(&hash) {\n+                    Ok(decoded_hash) => decoded_hash,\n+                    Err(_) => {\n+                        invalid_components.push(hash.clone());\n+                        hash\n+                    }\n+                };\n                 Some(hash)\n             }\n         };\n \n         let hash_path = {\n-            if let Some(hash) = &hash {\n+            let mut hash = url.hash();\n+            if hash.is_empty() {\n+                Vec::new()\n+            } else {\n+                // Remove leading `#`.\n+                hash.remove(0);\n                 hash.split('/')\n                     .filter_map(|path_part| {\n                         if path_part.is_empty() {\n                             None\n                         } else {\n-                            Some(path_part.to_owned())\n+                            let path_part = match Url::decode_uri_component(path_part) {\n+                                Ok(decoded_path_part) => decoded_path_part,\n+                                Err(_) => {\n+                                    invalid_components.push(path_part.to_owned());\n+                                    path_part.to_owned()\n+                                }\n+                            };\n+                            Some(path_part)\n                         }\n                     })\n                     .collect::<Vec<_>>()\n-            } else {\n-                Vec::new()\n             }\n         };\n \n-        let search = {\n-            let mut search = url.search();\n-            if search.is_empty() {\n-                None\n-            } else {\n-                // Remove leading `?`.\n-                search.remove(0);\n-                Some(search)\n-            }\n-        };\n+        let search = UrlSearch::from(url.search_params());\n+        invalid_components.append(&mut search.invalid_components.clone());\n \n         Self {\n             next_path_part_index: 0,\n             next_hash_path_part_index: 0,\n             path,\n             hash_path,\n             hash,\n             search,\n+            invalid_components,\n+        }\n+    }\n+}\n+\n+// ------ UrlSearch ------\n+\n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n+pub struct UrlSearch {\n+    search: BTreeMap<String, Vec<String>>,\n+    invalid_components: Vec<String>,\n+}\n+\n+impl UrlSearch {\n+    /// Makes a new `UrlSearch` with the provided parameters.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,no_run\n+    /// UrlSearch::new(vec![\n+    ///     (\"sort\", vec![\"date\", \"name\"]),\n+    ///     (\"category\", vec![\"top\"])\n+    /// ])\n+    /// ```\n+    pub fn new<K, V, VS>(params: impl IntoIterator<Item = (K, VS)>) -> Self\n+    where\n+        K: Into<String>,\n+        V: Into<String>,\n+        VS: IntoIterator<Item = V>,\n+    {\n+        let mut search = BTreeMap::new();\n+        for (key, values) in params {\n+            search.insert(key.into(), values.into_iter().map(Into::into).collect());\n+        }\n+        Self {\n+            search,\n+            invalid_components: Vec::new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `UrlSearch` contains a value for the specified key.\n+    pub fn contains_key(&self, key: impl AsRef<str>) -> bool {\n+        self.search.contains_key(key.as_ref())\n+    }\n+\n+    /// Returns a reference to values corresponding to the key.\n+    pub fn get(&self, key: impl AsRef<str>) -> Option<&Vec<String>> {\n+        self.search.get(key.as_ref())\n+    }\n+\n+    /// Returns a mutable reference to values corresponding to the key.\n+    pub fn get_mut(&mut self, key: impl AsRef<str>) -> Option<&mut Vec<String>> {\n+        self.search.get_mut(key.as_ref())\n+    }\n+\n+    /// Push the value into the vector of values corresponding to the key.\n+    /// - If the key and values are not present, they will be crated.\n+    pub fn push_value<'a>(&mut self, key: impl Into<Cow<'a, str>>, value: String) {\n+        let key = key.into();\n+        if self.search.contains_key(key.as_ref()) {\n+            self.search.get_mut(key.as_ref()).unwrap().push(value);\n+        } else {\n+            self.search.insert(key.into_owned(), vec![value]);\n+        }\n+    }\n+\n+    /// Inserts a key-values pair into the `UrlSearch`.\n+    /// - If the `UrlSearch` did not have this key present, `None` is returned.\n+    /// - If the `UrlSearch` did have this key present, old values are overwritten by new ones,\n+    /// and old values are returned. The key is not updated.\n+    pub fn insert(&mut self, key: String, values: Vec<String>) -> Option<Vec<String>> {\n+        self.search.insert(key, values)\n+    }\n+\n+    /// Removes a key from the `UrlSearch`, returning values at the key\n+    /// if the key was previously in the `UrlSearch`.\n+    pub fn remove(&mut self, key: impl AsRef<str>) -> Option<Vec<String>> {\n+        self.search.remove(key.as_ref())\n+    }\n+\n+    /// Gets an iterator over the entries of the `UrlSearch`, sorted by key.\n+    pub fn iter(&self) -> impl Iterator<Item = (&String, &Vec<String>)> {\n+        self.search.iter()\n+    }\n+\n+    /// Get invalid components.\n+    ///\n+    /// Undecodable / unparsable components are invalid.\n+    pub fn invalid_components(&self) -> &[String] {\n+        &self.invalid_components\n+    }\n+\n+    /// Get mutable invalid components.\n+    ///\n+    /// Undecodable / unparsable components are invalid.\n+    pub fn invalid_components_mut(&mut self) -> &mut Vec<String> {\n+        &mut self.invalid_components\n+    }\n+}\n+\n+/// `UrlSearch` components are automatically encoded.\n+impl fmt::Display for UrlSearch {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let params = web_sys::UrlSearchParams::new().expect(\"create a new UrlSearchParams\");\n+\n+        for (key, values) in &self.search {\n+            for value in values {\n+                params.append(key, value);\n+            }\n         }\n+        write!(fmt, \"{}\", String::from(params.to_string()))\n+    }\n+}\n+\n+impl From<web_sys::UrlSearchParams> for UrlSearch {\n+    /// Creates a new `UrlSearch` from the browser native `UrlSearchParams`.\n+    /// `UrlSearch`'s components are decoded if possible. When decoding fails, the component is cloned\n+    /// into `invalid_components` and the original value is used.\n+    fn from(params: web_sys::UrlSearchParams) -> Self {\n+        let mut url_search = Self::default();\n+        let mut invalid_components = Vec::<String>::new();\n+\n+        for param in js_sys::Array::from(&params).to_vec() {\n+            let key_value_pair = js_sys::Array::from(&param).to_vec();\n+\n+            let key = key_value_pair\n+                .get(0)\n+                .expect(\"get UrlSearchParams key from key-value pair\")\n+                .as_string()\n+                .expect(\"cast UrlSearchParams key to String\");\n+            let value = key_value_pair\n+                .get(1)\n+                .expect(\"get UrlSearchParams value from key-value pair\")\n+                .as_string()\n+                .expect(\"cast UrlSearchParams value to String\");\n+\n+            let key = match Url::decode_uri_component(&key) {\n+                Ok(decoded_key) => decoded_key,\n+                Err(_) => {\n+                    invalid_components.push(key.clone());\n+                    key\n+                }\n+            };\n+            let value = match Url::decode_uri_component(&value) {\n+                Ok(decoded_value) => decoded_value,\n+                Err(_) => {\n+                    invalid_components.push(value.clone());\n+                    value\n+                }\n+            };\n+\n+            url_search.push_value(key, value)\n+        }\n+\n+        url_search.invalid_components = invalid_components;\n+        url_search\n     }\n }\n \n // ------ ------ Tests ------ ------\n \n #[cfg(test)]\n mod tests {\n     use wasm_bindgen_test::*;\n \n     use super::*;\n \n     wasm_bindgen_test_configure!(run_in_browser);\n \n+    //(https://www.w3schools.com/tags/ref_urlencode.ASP)\n+    #[wasm_bindgen_test]\n+    fn parse_url_decoding() {\n+        // \"/Hello G\u00fcnter/path2?calc=5+6&x=1&x=2#he\u0161\"\n+        let expected = \"/Hello%20G%C3%BCnter/path2?calc=5%2B6&x=1&x=2#he%C5%A1\";\n+        let native_url = web_sys::Url::new_with_base(expected, DUMMY_BASE_URL).unwrap();\n+        let url = Url::from(&native_url);\n+\n+        assert_eq!(url.path()[0], \"Hello G\u00fcnter\");\n+        assert_eq!(url.path()[1], \"path2\");\n+        assert_eq!(\n+            url.search(),\n+            &UrlSearch::new(vec![(\"calc\", vec![\"5+6\"]), (\"x\", vec![\"1\", \"2\"]),])\n+        );\n+        assert_eq!(url.hash(), Some(&\"he\u0161\".to_owned()));\n+\n+        let actual = url.to_string();\n+        assert_eq!(expected, actual)\n+    }\n+\n     #[wasm_bindgen_test]\n-    fn parse_url_simple() {\n+    fn parse_url_path() {\n         let expected = Url::new().set_path(&[\"path1\", \"path2\"]);\n         let actual: Url = \"/path1/path2\".parse().unwrap();\n         assert_eq!(expected, actual)\n     }\n \n     #[wasm_bindgen_test]\n     fn parse_url_with_hash_search() {\n         let expected = Url::new()\n             .set_path(&[\"path\"])\n-            .set_search(\"search=query\")\n+            .set_search(UrlSearch::new(vec![(\"search\", vec![\"query\"])]))\n             .set_hash(\"hash\");\n         let actual: Url = \"/path?search=query#hash\".parse().unwrap();\n         assert_eq!(expected, actual)\n     }\n \n     #[wasm_bindgen_test]\n     fn parse_url_with_hash_only() {\n         let expected = Url::new().set_path(&[\"path\"]).set_hash(\"hash\");\n         let actual: Url = \"/path#hash\".parse().unwrap();\n         assert_eq!(expected, actual)\n     }\n \n     #[wasm_bindgen_test]\n     fn parse_url_with_hash_routing() {\n         let expected = Url::new().set_hash_path(&[\"discover\"]);\n         let actual: Url = \"/#discover\".parse().unwrap();\n         assert_eq!(expected, actual)\n     }\n \n     #[wasm_bindgen_test]\n     fn check_url_to_string() {\n         let expected = \"/foo/bar?q=42&z=13#discover\";\n \n         let actual = Url::new()\n             .set_path(&[\"foo\", \"bar\"])\n-            .set_search(\"q=42&z=13\")\n+            .set_search(UrlSearch::new(vec![(\"q\", vec![\"42\"]), (\"z\", vec![\"13\"])]))\n             .set_hash_path(&[\"discover\"])\n             .to_string();\n \n         assert_eq!(expected, actual)\n     }\n }\ndiff --git a/src/browser/util.rs b/src/browser/util.rs\nindex b573252..e97e45d 100644\n--- a/src/browser/util.rs\n+++ b/src/browser/util.rs\n@@ -1,323 +1,326 @@\n //! Provide a wrapper for commonly-used, but verbose `web_sys` features.\n //! This module is decoupled / independent.\n \n // @TODO refactor (ideally once `Unsized` and `Specialization` are stable)\n \n use wasm_bindgen::closure::Closure;\n use wasm_bindgen::JsCast;\n-use web_sys;\n \n pub type RequestAnimationFrameTime = f64;\n \n #[must_use]\n pub struct RequestAnimationFrameHandle {\n     request_id: i32,\n     _closure: Closure<dyn FnMut(RequestAnimationFrameTime)>,\n }\n \n impl Drop for RequestAnimationFrameHandle {\n     fn drop(&mut self) {\n         window()\n             .cancel_animation_frame(self.request_id)\n             .expect(\"Problem cancelling animation frame request\")\n     }\n }\n \n /// Convenience function to avoid repeating expect logic.\n pub fn window() -> web_sys::Window {\n     web_sys::window().expect(\"Can't find the global Window\")\n }\n \n /// Convenience function to access the `web_sys` DOM document.\n pub fn document() -> web_sys::Document {\n     window()\n         .document()\n         .expect(\"Can't find the window's document\")\n }\n \n /// Convenience function to access the `web_sys` DOM body.\n pub fn body() -> web_sys::HtmlElement {\n     document().body().expect(\"Can't find the document's body\")\n }\n \n /// Convenience function to access the `web_sys` history.\n pub fn history() -> web_sys::History {\n     window().history().expect(\"Can't find history\")\n }\n \n /// Convenience function to access the `web_sys::HtmlDocument`.\n pub fn html_document() -> web_sys::HtmlDocument {\n     wasm_bindgen::JsValue::from(document()).unchecked_into::<web_sys::HtmlDocument>()\n }\n /// Convenience function to access the `web_sys::HtmlCanvasElement`.\n /// /// _Note:_ Returns `None` if there is no element with the given `id` or the element isn't `HtmlCanvasElement`.\n pub fn canvas(id: &str) -> Option<web_sys::HtmlCanvasElement> {\n     document()\n         .get_element_by_id(id)\n         .and_then(|element| element.dyn_into::<web_sys::HtmlCanvasElement>().ok())\n }\n \n /// Convenience function to access the `web_sys::CanvasRenderingContext2d`.\n pub fn canvas_context_2d(canvas: &web_sys::HtmlCanvasElement) -> web_sys::CanvasRenderingContext2d {\n     canvas\n         .get_context(\"2d\")\n         .expect(\"Problem getting canvas context\")\n         .expect(\"The canvas context is empty\")\n         .dyn_into::<web_sys::CanvasRenderingContext2d>()\n         .expect(\"Problem casting as web_sys::CanvasRenderingContext2d\")\n }\n \n /// Convenience function to get all cookies from the current `HtmlDocument`\n /// _Note:_ Returns `None` if parsing cookies fails or there are no cookies.\n pub fn cookies() -> Option<cookie::CookieJar> {\n     let cookies_str = html_document().cookie().ok()?;\n     let mut jar = cookie::CookieJar::new();\n \n     for cookie_str in cookies_str.split(';') {\n         let cookie = cookie::Cookie::parse_encoded(cookie_str).ok()?;\n         jar.add(cookie.into_owned());\n     }\n \n     let jar_is_empty = jar.iter().next().is_none();\n     if jar_is_empty {\n         None\n     } else {\n         Some(jar)\n     }\n }\n \n /// Request the animation frame.\n pub fn request_animation_frame(\n     f: Closure<dyn FnMut(RequestAnimationFrameTime)>,\n ) -> RequestAnimationFrameHandle {\n     let request_id = window()\n         .request_animation_frame(f.as_ref().unchecked_ref())\n         .expect(\"Problem requesting animation frame\");\n \n     RequestAnimationFrameHandle {\n         request_id,\n         _closure: f,\n     }\n }\n \n /// Simplify getting the value of input elements; required due to the need to cast\n /// from general nodes/elements to `HTML_Elements`.\n ///\n /// # Errors\n ///\n /// Will return error if it's not possible to call `get_value` for given `target`.\n pub fn get_value(target: &web_sys::EventTarget) -> Result<String, &'static str> {\n+    #![allow(clippy::wildcard_imports)]\n     use web_sys::*;\n+\n     macro_rules! get {\n         ($element:ty) => {\n             get!($element, |_| Ok(()))\n         };\n         ($element:ty, $result_callback:expr) => {\n             if let Some(input) = target.dyn_ref::<$element>() {\n                 return $result_callback(input).map(|_| input.value().to_string());\n             }\n         };\n     }\n     // List of elements\n     // https://docs.rs/web-sys/0.3.25/web_sys/struct.HtmlMenuItemElement.html?search=value\n     // They should be ordered by expected frequency of use\n \n     get!(HtmlInputElement, |input: &HtmlInputElement| {\n         // https://www.w3schools.com/tags/att_input_value.asp\n         match input.type_().as_str() {\n             \"file\" => Err(r#\"The value attribute cannot be used with <input type=\"file\">.\"#),\n             _ => Ok(()),\n         }\n     });\n     get!(HtmlTextAreaElement);\n     get!(HtmlSelectElement);\n     get!(HtmlProgressElement);\n     get!(HtmlOptionElement);\n     get!(HtmlButtonElement);\n     get!(HtmlDataElement);\n     get!(HtmlMeterElement);\n     get!(HtmlLiElement);\n     get!(HtmlOutputElement);\n     get!(HtmlParamElement);\n \n     Err(\"Can't use function `get_value` for given element.\")\n }\n \n #[allow(clippy::missing_errors_doc)]\n /// Similar to `get_value`.\n pub fn set_value(target: &web_sys::EventTarget, value: &str) -> Result<(), &'static str> {\n+    #![allow(clippy::wildcard_imports)]\n     use web_sys::*;\n+\n     macro_rules! set {\n         ($element:ty) => {\n             set!($element, |_| Ok(value))\n         };\n         ($element:ty, $value_result_callback:expr) => {\n             if let Some(input) = target.dyn_ref::<$element>() {\n                 return $value_result_callback(input).map(|value| input.set_value(value));\n             }\n         };\n     }\n     // List of elements\n     // https://docs.rs/web-sys/0.3.25/web_sys/struct.HtmlMenuItemElement.html?search=set_value\n     // They should be ordered by expected frequency of use\n \n     if let Some(input) = target.dyn_ref::<HtmlInputElement>() {\n         return set_html_input_element_value(input, value);\n     }\n     set!(HtmlTextAreaElement);\n     set!(HtmlSelectElement);\n     set!(HtmlProgressElement, |_| value.parse().map_err(|_| {\n         \"Can't parse value to `f64` for `HtmlProgressElement`.\"\n     }));\n     set!(HtmlOptionElement);\n     set!(HtmlButtonElement);\n     set!(HtmlDataElement);\n     set!(HtmlMeterElement, |_| value.parse().map_err(|_| {\n         \"Can't parse value to `f64` for `HtmlMeterElement`.\"\n     }));\n     set!(HtmlLiElement, |_| value.parse().map_err(|_| {\n         \"Can't parse value to `i32` for `HtmlLiElement`.\"\n     }));\n     set!(HtmlOutputElement);\n     set!(HtmlParamElement);\n \n     Err(\"Can't use function `set_value` for given element.\")\n }\n \n fn set_html_input_element_value(\n     input: &web_sys::HtmlInputElement,\n     value: &str,\n ) -> Result<(), &'static str> {\n     // In some cases we need to set selection manually because\n     // otherwise the cursor would jump at the end on some platforms.\n \n     // `selectionStart` and `selectionEnd`\n     // - \"If this element is an input element, and selectionStart does not apply to this element, return null.\"\n     //   - https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-textarea/input-selectionstart\n     // - => return values if the element type is:\n     //   -  `text`, `search`, `url`, `tel`, `password` and probably also `week`, `month`\n     //   - https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement\n     //   - https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n     let selection_update_required = match input.type_().as_str() {\n         // https://www.w3schools.com/tags/att_input_value.asp\n         \"file\" => return Err(r#\"The value attribute cannot be used with <input type=\"file\">.\"#),\n         \"text\" | \"password\" | \"search\" | \"tel\" | \"url\" | \"week\" | \"month\" => true,\n         _ => false,\n     };\n \n     // We don't want to set selection in inactive input because\n     // that input would \"steal\" focus from the active element on some platforms.\n     if selection_update_required && is_active(input) {\n         let selection_start = input\n             .selection_start()\n             .expect(\"get `HtmlInputElement` selection start\");\n         let selection_end = input\n             .selection_end()\n             .expect(\"get `HtmlInputElement` selection end\");\n \n         input.set_value(value);\n \n         input\n             .set_selection_start(selection_start)\n             .expect(\"set `HtmlInputElement` selection start\");\n         input\n             .set_selection_end(selection_end)\n             .expect(\"set `HtmlInputElement` selection end\");\n     } else {\n         input.set_value(value);\n     }\n \n     Ok(())\n }\n \n /// Return true if passed element is active.\n fn is_active(element: &web_sys::Element) -> bool {\n     document().active_element().as_ref() == Some(element)\n }\n \n #[allow(clippy::missing_errors_doc)]\n /// Similar to `get_value`\n #[allow(dead_code)]\n pub fn get_checked(target: &web_sys::EventTarget) -> Result<bool, &'static str> {\n     if let Some(input) = target.dyn_ref::<web_sys::HtmlInputElement>() {\n         // https://www.w3schools.com/tags/att_input_checked.asp\n         return match input.type_().as_str() {\n             \"file\" => Err(\n                 r#\"The checked attribute can be used with <input type=\"checkbox\"> and <input type=\"radio\">.\"#,\n             ),\n             _ => Ok(input.checked()),\n         };\n     }\n     if let Some(input) = target.dyn_ref::<web_sys::HtmlMenuItemElement>() {\n         return Ok(input.checked());\n     }\n     Err(\"Only `HtmlInputElement` and `HtmlMenuItemElement` can be used in function `get_checked`.\")\n }\n \n #[allow(clippy::missing_errors_doc)]\n /// Similar to `set_value`.\n #[allow(clippy::unit_arg)]\n pub fn set_checked(target: &web_sys::EventTarget, value: bool) -> Result<(), &'static str> {\n     if let Some(input) = target.dyn_ref::<web_sys::HtmlInputElement>() {\n         // https://www.w3schools.com/tags/att_input_checked.asp\n         return match input.type_().as_str() {\n             \"file\" => Err(\n                 r#\"The checked attribute can be used with <input type=\"checkbox\"> and <input type=\"radio\">.\"#,\n             ),\n             _ => Ok(input.set_checked(value)),\n         };\n     }\n     if let Some(input) = target.dyn_ref::<web_sys::HtmlMenuItemElement>() {\n         return Ok(input.set_checked(value));\n     }\n     Err(\"Only `HtmlInputElement` and `HtmlMenuItemElement` can be used in function `set_checked`.\")\n }\n \n // @TODO: Delete once `Closure::new` is stable\n // https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html\n /// Prevent repetition when wrapping closures.\n pub trait ClosureNew<T> {\n     #[allow(clippy::new_ret_no_self)]\n     fn new(inner: impl FnMut(T) + 'static) -> Closure<dyn FnMut(T)>\n     where\n         T: wasm_bindgen::convert::FromWasmAbi + 'static;\n }\n impl<T> ClosureNew<T> for Closure<T> {\n     #[allow(clippy::new_ret_no_self)]\n     fn new(inner: impl FnMut(T) + 'static) -> Closure<dyn FnMut(T)>\n     where\n         T: wasm_bindgen::convert::FromWasmAbi + 'static,\n     {\n         Closure::wrap(Box::new(inner))\n     }\n }\n \n /// Convenience function for logging to the web browser's console.  See also\n /// the log! macro, which is more flexible.\n #[cfg(use_nightly)]\n pub fn log<T>(object: T) -> T {\n     web_sys::console::log_1(&format!(\"{:#?}\", dbg::WrapDebug(&object)).into());\n     object\n }\n \n /// Convenience function for logging to the web browser's console.  See also\n /// the log! macro, which is more flexible.\n #[cfg(not(use_nightly))]\n pub fn log<T: std::fmt::Debug>(object: T) -> T {\n     web_sys::console::log_1(&format!(\"{:#?}\", &object).into());\n     object\n }\n \n /// Similar to log, but for errors.\n #[cfg(use_nightly)]\n pub fn error<T>(object: T) -> T {\n     web_sys::console::error_1(&format!(\"{:#?}\", dbg::WrapDebug(&object)).into());\n     object\n }\n \n /// Similar to log, but for errors.\n #[cfg(not(use_nightly))]\n pub fn error<T: std::fmt::Debug>(object: T) -> T {\n     web_sys::console::error_1(&format!(\"{:#?}\", &object).into());\n     object\n }\ndiff --git a/src/browser/web_storage.rs b/src/browser/web_storage.rs\nindex 638397c..834bef3 100644\n--- a/src/browser/web_storage.rs\n+++ b/src/browser/web_storage.rs\n@@ -1,282 +1,281 @@\n use crate::browser::util::window;\n use serde::{de::DeserializeOwned, Serialize};\n-use serde_json;\n use wasm_bindgen::JsValue;\n use web_sys::Storage;\n \n /// Convenient type alias.\n pub type Result<T> = std::result::Result<T, WebStorageError>;\n \n // ------ WebStorageError ------\n \n #[allow(clippy::module_name_repetitions, clippy::pub_enum_variant_names)]\n #[derive(Debug)]\n pub enum WebStorageError {\n     GetStorageError(JsValue),\n     StorageNotFoundError,\n     ClearError(JsValue),\n     GetlengthError(JsValue),\n     GetKeyError(JsValue),\n     KeyNotFoundError,\n     RemoveError(JsValue),\n     GetError(JsValue),\n     InsertError(JsValue),\n     SerdeError(serde_json::Error),\n }\n \n // ------ LocalStorage ------\n \n /// Local Storage  maintains a separate storage area for each given origin\n /// that persists even when the browser is closed and reopened.\n ///\n /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)\n pub struct LocalStorage;\n \n impl WebStorage for LocalStorage {\n     fn storage() -> Result<Storage> {\n         window()\n             .local_storage()\n             .map_err(WebStorageError::GetStorageError)?\n             .ok_or(WebStorageError::StorageNotFoundError)\n     }\n }\n \n // ------ SessionStorage ------\n \n /// - Session Storage maintains a separate storage area for each given origin\n /// that's available for the duration of the page session\n /// (as long as the browser is open, including page reloads and restores).\n ///\n /// - Opening multiple tabs/windows with the same URL creates sessionStorage for each tab/window.\n ///\n /// - Data stored in sessionStorage is specific to the protocol of the page.\n /// In other words, _`http://example.com`_ will have separate storage than _`https://example.com`_.\n ///\n /// - Storage limit is larger than a cookie (at most 5MB).\n ///\n /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)\n pub struct SessionStorage;\n \n impl WebStorage for SessionStorage {\n     fn storage() -> Result<Storage> {\n         window()\n             .session_storage()\n             .map_err(WebStorageError::GetStorageError)?\n             .ok_or(WebStorageError::StorageNotFoundError)\n     }\n }\n \n // ------ WebStorage ------\n \n /// Web Storage API.\n ///\n /// `LocalStorage` and `SessionStorage` implement this trait.\n ///\n /// (If you think some important methods are missing,\n /// please create an [issue](https://github.com/seed-rs/seed/issues/new))\n ///\n /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)\n pub trait WebStorage {\n     /// Get a native `Storage` instance.\n     ///\n     /// This method is used internally by other methods.\n     ///\n     /// (If you need to call it often,\n     /// please create an [issue](https://github.com/seed-rs/seed/issues/new))\n     ///\n     /// # Errors\n     ///\n     /// Returns error if we cannot get access to the storage - security errors,\n     /// browser does not have given storage, user denied access for the current origin, etc.\n     ///\n     /// - [MDN ref for Local Storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)\n     /// - [MDN ref for Session Storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)\n     fn storage() -> Result<Storage>;\n \n     /// Clear all data in the storage.\n     ///\n     /// # Errors\n     ///\n     /// Returns error if we cannot get access to the storage or clear the storage.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Storage/clear)\n     fn clear() -> Result<()> {\n         Self::storage()?\n             .clear()\n             .map_err(WebStorageError::ClearError)\n     }\n \n     /// Get the number of stored data items.\n     ///\n     /// # Errors\n     ///\n     /// Returns error if we cannot get access to the storage or read the storage length.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Storage/length)\n     fn len() -> Result<u32> {\n         Self::storage()?\n             .length()\n             .map_err(WebStorageError::GetlengthError)\n     }\n \n     /// Returns the key in the given position.\n     ///\n     /// # Errors\n     ///\n     /// Returns error if we cannot get access to the storage or the key does not exist.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Storage/key)\n     fn key(index: u32) -> Result<String> {\n         Self::storage()?\n             .key(index)\n             .map_err(WebStorageError::GetKeyError)?\n             .ok_or(WebStorageError::KeyNotFoundError)\n     }\n \n     /// Removes a key.\n     ///\n     /// If there is no item associated with the given key, this method will do nothing.\n     ///\n     /// # Errors\n     ///\n     /// Returns error if we cannot get access to the storage or remove the existing key.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Storage/removeItem)\n     fn remove(key: impl AsRef<str>) -> Result<()> {\n         Self::storage()?\n             .remove_item(key.as_ref())\n             .map_err(WebStorageError::RemoveError)\n     }\n \n     /// Returns a deserialized value corresponding to the key.\n     ///\n     /// # Errors\n     ///\n     /// Returns error if we cannot get access to the storage\n     /// or find the key or deserialize the value.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem)\n     fn get<T: DeserializeOwned>(key: impl AsRef<str>) -> Result<T> {\n         Self::storage()?\n             .get_item(key.as_ref())\n             .map_err(WebStorageError::GetError)?\n             .ok_or(WebStorageError::KeyNotFoundError)\n             .map(|value| serde_json::from_str(&value))?\n             .map_err(WebStorageError::SerdeError)\n     }\n \n     /// Insert a key-value pair. The value will be serialized.\n     ///\n     /// If the key already exists, the value will be updated.\n     ///\n     /// # Errors\n     ///\n     /// Returns error if we cannot get access to the storage\n     /// or serialize the value or insert/update the pair.\n     ///\n     /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem)\n     fn insert<T: Serialize + ?Sized>(key: impl AsRef<str>, value: &T) -> Result<()> {\n         let value = serde_json::to_string(value).map_err(WebStorageError::SerdeError)?;\n \n         Self::storage()?\n             .set_item(key.as_ref(), &value)\n             .map_err(WebStorageError::InsertError)\n     }\n }\n \n // ------ ------ Tests ------ ------\n \n #[cfg(test)]\n mod tests {\n     use wasm_bindgen_test::*;\n \n     use super::*;\n \n     wasm_bindgen_test_configure!(run_in_browser);\n \n     // ------ LocalStorage tests ------\n \n     #[wasm_bindgen_test]\n     fn local_storage_insert_get() {\n         LocalStorage::clear().unwrap();\n \n         let value: String = {\n             LocalStorage::insert(\"a_key\", \"a_value\").unwrap();\n             LocalStorage::get(\"a_key\").unwrap()\n         };\n         assert_eq!(\"a_value\", value)\n     }\n \n     #[wasm_bindgen_test]\n     fn local_storage_length_clear() {\n         LocalStorage::clear().unwrap();\n         assert_eq!(0, LocalStorage::len().unwrap());\n \n         LocalStorage::insert(\"key_1\", \"a_value\").unwrap();\n         LocalStorage::insert(\"key_2\", \"a_value\").unwrap();\n         assert_eq!(2, LocalStorage::len().unwrap());\n \n         LocalStorage::clear().unwrap();\n         assert_eq!(0, LocalStorage::len().unwrap());\n     }\n \n     #[wasm_bindgen_test]\n     fn local_storage_key() {\n         SessionStorage::clear().unwrap();\n \n         SessionStorage::insert(\"a_key\", \"a_value\").unwrap();\n         assert_eq!(\"a_key\", SessionStorage::key(0).unwrap());\n     }\n \n     #[wasm_bindgen_test]\n     fn local_storage_remove() {\n         SessionStorage::clear().unwrap();\n \n         SessionStorage::insert(\"a_key\", \"a_value\").unwrap();\n         SessionStorage::remove(\"a_key\").unwrap();\n         assert_eq!(0, SessionStorage::len().unwrap());\n     }\n \n     // ------ SessionStorage tests ------\n \n     #[wasm_bindgen_test]\n     fn session_storage_insert_get() {\n         SessionStorage::clear().unwrap();\n \n         let value: String = {\n             SessionStorage::insert(\"a_key\", \"a_value\").unwrap();\n             SessionStorage::get(\"a_key\").unwrap()\n         };\n         assert_eq!(\"a_value\", value)\n     }\n \n     #[wasm_bindgen_test]\n     fn session_storage_length_clear() {\n         SessionStorage::clear().unwrap();\n         assert_eq!(0, SessionStorage::len().unwrap());\n \n         SessionStorage::insert(\"key_1\", \"a_value\").unwrap();\n         SessionStorage::insert(\"key_2\", \"a_value\").unwrap();\n         assert_eq!(2, SessionStorage::len().unwrap());\n \n         SessionStorage::clear().unwrap();\n         assert_eq!(0, SessionStorage::len().unwrap());\n     }\n \n     #[wasm_bindgen_test]\n     fn session_storage_key() {\n         SessionStorage::clear().unwrap();\n \n         SessionStorage::insert(\"a_key\", \"a_value\").unwrap();\n         assert_eq!(\"a_key\", SessionStorage::key(0).unwrap());\n     }\n \n     #[wasm_bindgen_test]\n     fn session_storage_remove() {\n         SessionStorage::clear().unwrap();\n \n         SessionStorage::insert(\"a_key\", \"a_value\").unwrap();\n         SessionStorage::remove(\"a_key\").unwrap();\n         assert_eq!(0, SessionStorage::len().unwrap());\n     }\n }\ndiff --git a/src/dom_entity_names/events/event_names.rs b/src/dom_entity_names/events/event_names.rs\nindex bd3a893..0c2c435 100644\n--- a/src/dom_entity_names/events/event_names.rs\n+++ b/src/dom_entity_names/events/event_names.rs\n@@ -1,49 +1,51 @@\n // Comprehensive list: https://developer.mozilla.org/en-US/docs/Web/Events\n make_events! {\n     Cached => \"cached\", Error => \"error\", Abort => \"abort\", Load => \"load\", BeforeUnload => \"beforeunload\",\n     Unload => \"unload\", Online => \"online\", Offline => \"offline\", Focus => \"focus\", Blur => \"blur\",\n     Open => \"open\", Message => \"message\", Close => \"close\", PageHide => \"pagehide\",\n     PageShow => \"pageshow\", PopState => \"popstate\", AnimationStart => \"animationstart\", AnimationEnd => \"animationend\",\n     AnimationIteration => \"animationiteration\", TransitionStart => \"transtionstart\", TransitionEnd => \"transitionend\",\n     TranstionRun => \"transitionrun\",\n \n     Rest => \"rest\", Submit => \"submit\", BeforePrint => \"beforeprint\", AfterPrint => \"afterprint\",\n     CompositionStart => \"compositionstart\", CompositionUpdate => \"compositionupdate\", CompositionEnd => \"compositionend\",\n \n     FullScreenChange => \"fullscreenchange\", FullScreenError => \"fullscreenerror\", Resize => \"resize\",\n     Scroll => \"scroll\", Cut => \"cut\", Copy => \"copy\", Paste => \"paste\",\n \n     KeyDown => \"keydown\", KeyUp => \"keyup\",\n     KeyPress => \"keypress\", AuxClick => \"auxclick\", Click => \"click\", ContextMenu => \"contextmenu\", DblClick => \"dblclick\",\n     MouseDown => \"mousedown\", MouseEnter => \"mouseenter\", MouseLeave => \"mouseleave\",\n     MouseMove => \"mousemove\", MouseOver => \"mouseover\", MouseOut => \"mouseout\", MouseUp => \"mouseup\",\n     PointerLockChange => \"pointerlockchange\", PointerLockError => \"pointerlockerror\", Select => \"select\",\n     Wheel => \"wheel\",\n \n     PointerOver => \"pointerover\", PointerEnter => \"pointerenter\",\n     PointerDown => \"pointerdown\", PointerMove => \"pointermove\", PointerUp => \"pointerup\",\n     PointerCancel => \"pointercancel\", PointerOut => \"pointerout\", PointerLeave => \"pointerleave\",\n     GotPointerCapture => \"gotpointercapture\", LostPointerCapture => \"lostpointercapture\",\n \n+    TouchStart => \"touchstart\", TouchEnd => \"touchend\", TouchCancel => \"touchcancel\", TouchMove => \"touchmove\",\n+\n     Drag => \"drag\", DragEnd => \"dragend\", DragEnter => \"dragenter\", DragStart => \"dragstart\", DragLeave => \"dragleave\",\n     DragOver => \"dragover\", Drop => \"drop\",\n \n     AudioProcess => \"audioprocess\", CanPlay => \"canplay\", CanPlayThrough => \"canplaythrough\", Complete => \"complete\",\n     DurationChange => \"durationchange\", Emptied => \"emptied\", Ended => \"ended\", LoadedData => \"loadeddata\",\n     LoadedMetaData => \"loadedmetadata\", Pause => \"pause\", Play => \"play\", Playing => \"playing\", RateChange => \"ratechange\",\n     Seeked => \"seeked\", Seeking => \"seeking\", Stalled => \"stalled\", Suspend => \"suspend\", TimeUpdate => \"timeupdate\",\n     VolumeChange => \"volumechange\",\n \n     // [MDN ref](https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event)\n     VisibilityChange => \"visibilitychange\",\n     SelectionChange => \"selectionchange\",\n \n     // todo finish this\n \n     Change => \"change\",\n \n     Input => \"input\",\n \n     // deprecated, @TODO: remove\n     TriggerUpdate => \"triggerupdate\"\n }\ndiff --git a/src/dom_entity_names/tags.rs b/src/dom_entity_names/tags.rs\nindex 3d0eb1e..d2540ab 100644\n--- a/src/dom_entity_names/tags.rs\n+++ b/src/dom_entity_names/tags.rs\n@@ -1,52 +1,52 @@\n // Populate tags using a macro, to reduce code repetition.\n // The tag enum primarily exists to ensure only valid elements are allowed.\n // We leave out non-body tags like html, meta, title, and body.\n macro_rules! make_tags {\n     // Create shortcut macros for any element; populate these functions in this module.\n     { $($tag_camel:ident => $tag:expr),+ } => {\n \n         /// The Tag enum restricts element-creation to only valid tags, as defined here:\n         /// [https://developer.mozilla.org/en-US/docs/Web/HTML/Element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element)\n-        #[derive(Clone, Debug, PartialEq)]\n+        #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n         pub enum Tag {\n             $(\n                 $tag_camel,\n             )+\n             Custom(std::borrow::Cow<'static, str>)\n         }\n \n         impl Tag {\n             pub fn as_str(&self) -> &str {\n                 match self {\n                     $(\n                         Tag::$tag_camel => $tag,\n                     ) +\n                     Tag::Custom(tag) => &tag\n                 }\n             }\n         }\n \n         impl std::fmt::Display for Tag {\n             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                 write!(f, \"{}\", self.as_str())\n             }\n         }\n \n         impl<T: Into<std::borrow::Cow<'static, str>>> From<T> for Tag {\n             fn from(tag: T) -> Self {\n                 let tag = tag.into();\n                 match tag.as_ref() {\n                     $(\n                         $tag => Tag::$tag_camel,\n                     ) +\n                     _ => {\n                         Tag::Custom(tag)\n                     }\n                 }\n             }\n         }\n     }\n }\n \n mod tag_names;\n pub use tag_names::Tag;\ndiff --git a/src/lib.rs b/src/lib.rs\nindex a145fdf..aa28fb4 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1,208 +1,212 @@\n //! See readme for details.\n \n //#![deny(missing_docs)]\n #![forbid(unsafe_code)]\n #![allow(\n     clippy::use_self,\n     clippy::single_match_else,\n     clippy::must_use_candidate\n )]\n #![allow(deprecated)] // @TODO delete once `seed::update` and related things are removed\n \n // @TODO Refactor once `optin_builtin_traits` or `negative_impls`\n // @TODO is stable (https://github.com/seed-rs/seed/issues/391).\n // --\n // @TODO Remove `'static` bound from all `MsU`s once `optin_builtin_traits`, `negative_impls`\n // @TODO or https://github.com/rust-lang/rust/issues/41875 is stable.\n macro_rules! map_callback_return_to_option_ms {\n     ($cb_type:ty, $callback:expr, $panic_text:literal, $output_type:tt) => {{\n         let t_type = TypeId::of::<MsU>();\n         if t_type == TypeId::of::<Ms>() {\n             $output_type::new(move |value| {\n                 (&mut Some($callback(value)) as &mut dyn Any)\n                     .downcast_mut::<Option<Ms>>()\n                     .and_then(Option::take)\n             })\n         } else if t_type == TypeId::of::<Option<Ms>>() {\n             $output_type::new(move |value| {\n                 (&mut $callback(value) as &mut dyn Any)\n                     .downcast_mut::<Option<Ms>>()\n                     .and_then(Option::take)\n             })\n         } else if t_type == TypeId::of::<()>() {\n             $output_type::new(move |value| {\n                 $callback(value);\n                 None\n             }) as $output_type<$cb_type>\n         } else {\n             panic!($panic_text);\n         }\n     }};\n }\n \n // @TODO move to prelude (?)\n pub use crate::{\n     app::{App, AppBuilder},\n     browser::dom::cast::{\n-        to_html_el, to_input, to_kbevent, to_mouse_event, to_select, to_textarea,\n+        to_drag_event, to_html_el, to_input, to_keyboard_event, to_mouse_event, to_select,\n+        to_textarea, to_touch_event,\n     },\n     browser::fetch,\n     browser::service::routing::push_route,\n     browser::service::storage,\n     browser::url::Url,\n     browser::util::{\n         self, body, canvas, canvas_context_2d, cookies, document, error, history, html_document,\n         log, window,\n     },\n     virtual_dom::{Attrs, EventHandler, Style},\n };\n pub use futures::future::{FutureExt, TryFutureExt};\n use wasm_bindgen::{closure::Closure, JsCast};\n \n+pub use wasm_bindgen;\n+pub use web_sys;\n+\n #[macro_use]\n pub mod shortcuts;\n pub mod app;\n pub mod browser;\n pub mod dom_entity_names;\n pub mod helpers;\n pub mod virtual_dom;\n \n /// Create an element flagged in a way that it will not be rendered. Useful\n /// in ternary operations.\n pub const fn empty<Ms>() -> virtual_dom::Node<Ms> {\n     virtual_dom::Node::Empty\n }\n \n // @TODO remove `set_interval` and `set_timeout`? Alternative from `gloo` should be used instead.\n \n /// A high-level wrapper for `web_sys::window.set_interval_with_callback_and_timeout_and_arguments_0`:\n ///\n /// # References\n /// * [WASM bindgen closures](https://rustwasm.github.io/wasm-bindgen/examples/closures.html)\n /// * [`web_sys` Window](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html)\n /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval)\n pub fn set_interval(handler: Box<dyn Fn()>, timeout: i32) {\n     let callback = Closure::wrap(handler as Box<dyn Fn()>);\n     util::window()\n         .set_interval_with_callback_and_timeout_and_arguments_0(\n             callback.as_ref().unchecked_ref(),\n             timeout,\n         )\n         .expect(\"Problem setting interval\");\n     callback.forget();\n }\n \n /// See [`set_interval`](fn.set_interval.html)\n ///\n ///\n /// # References\n /// * [MDN docs](https://developer.mozilla.org/en-US/docs/Wemb/API/WindowOrWorkerGlobalScope/setTimeout)\n pub fn set_timeout(handler: Box<dyn Fn()>, timeout: i32) {\n     let callback = Closure::wrap(handler as Box<dyn Fn()>);\n     util::window()\n         .set_timeout_with_callback_and_timeout_and_arguments_0(\n             callback.as_ref().unchecked_ref(),\n             timeout,\n         )\n         .expect(\"Problem setting timeout\");\n     callback.forget();\n }\n \n /// Introduce `El` and `Tag` into the global namespace for convenience (`El` will be repeated\n /// often in the output type of components), and `UpdateEl`, which is required\n /// for element-creation macros, input event constructors, and the `History` struct.\n /// Expose the `wasm_bindgen` prelude.\n pub mod prelude {\n     pub use crate::{\n         app::{\n             builder::init::Init, cmds, streams, subs, AfterMount, App, BeforeMount, CmdHandle,\n-            GetElement, MessageMapper, MountType, Orders, RenderTimestampDelta, StreamHandle,\n-            SubHandle, UrlHandling,\n+            GetElement, MessageMapper, MountType, Orders, RenderInfo, StreamHandle, SubHandle,\n+            UrlHandling,\n         },\n         browser::dom::css_units::*,\n         browser::dom::event_handler::{\n-            ev, input_ev, keyboard_ev, mouse_ev, pointer_ev, raw_ev, simple_ev,\n+            drag_ev, ev, input_ev, keyboard_ev, mouse_ev, pointer_ev, raw_ev, simple_ev, touch_ev,\n         },\n         browser::fetch::{self, fetch, Header, Method, Request, Response, Status},\n         browser::util::{\n             request_animation_frame, ClosureNew, RequestAnimationFrameHandle,\n             RequestAnimationFrameTime,\n         },\n         browser::web_storage::{LocalStorage, SessionStorage, WebStorage},\n-        browser::Url,\n+        browser::{Url, UrlSearch},\n         helpers::not,\n         // macros are exported in crate root\n         // https://github.com/rust-lang-nursery/reference/blob/master/src/macros-by-example.md\n         shortcuts::*,\n         virtual_dom::{\n-            el_ref::el_ref, AsAtValue, At, AtValue, CSSValue, El, ElRef, Ev, EventHandler,\n+            el_key, el_ref::el_ref, AsAtValue, At, AtValue, CSSValue, El, ElRef, Ev, EventHandler,\n             IntoNodes, Node, St, Tag, ToClasses, UpdateEl, UpdateElForIterator, View,\n         },\n     };\n     pub use indexmap::IndexMap; // for attrs and style to work.\n     pub use wasm_bindgen::prelude::*;\n     pub use web_sys::Event;\n }\n \n #[cfg(test)]\n pub mod tests {\n     use wasm_bindgen_test::wasm_bindgen_test_configure;\n     wasm_bindgen_test_configure!(run_in_browser);\n \n     use wasm_bindgen_test::*;\n \n     /// This is a minimal app, that should build. Will fail if there's a breaking\n     /// change.\n     #[wasm_bindgen_test]\n     #[allow(dead_code)]\n     pub fn app_builds() {\n         use crate as seed; // required for macros to work.\n         use crate::app::{builder::init::Init, Orders};\n         use crate::browser::dom::event_handler::mouse_ev;\n         use crate::prelude::*;\n         use crate::virtual_dom::{EventHandler, Node};\n \n         struct Model {\n             pub val: i32,\n         }\n \n         impl Default for Model {\n             fn default() -> Self {\n                 Self { val: 0 }\n             }\n         }\n \n         #[derive(Clone)]\n         enum Msg {\n             Increment,\n         }\n \n         fn update(msg: Msg, model: &mut Model, _: &mut impl Orders<Msg>) {\n             match msg {\n                 Msg::Increment => model.val += 1,\n             }\n         }\n \n         fn view(_model: &Model) -> Vec<Node<Msg>> {\n             vec![div![\"Hello world\"]]\n         }\n \n         fn window_events(_model: &Model) -> Vec<EventHandler<Msg>> {\n             vec![mouse_ev(\"mousemove\", |_| Msg::Increment)]\n         }\n \n         fn routes(_url: seed::Url) -> Option<Msg> {\n             Some(Msg::Increment)\n         }\n \n         #[wasm_bindgen]\n         pub fn render() {\n             seed::App::build(|_, _| Init::new(Model::default()), update, view)\n                 .mount(\"body\")\n                 .routes(routes)\n                 .window_events(window_events)\n                 .finish()\n                 .run();\n         }\n     }\n }\ndiff --git a/src/virtual_dom.rs b/src/virtual_dom.rs\nindex 5e0f814..fe7b2ae 100644\n--- a/src/virtual_dom.rs\n+++ b/src/virtual_dom.rs\n@@ -1,648 +1,844 @@\n pub mod attrs;\n pub mod el_ref;\n pub mod event_handler_manager;\n pub mod mailbox;\n pub mod node;\n pub mod patch;\n pub mod style;\n pub mod to_classes;\n pub mod update_el;\n pub mod values;\n pub mod view;\n \n pub use attrs::Attrs;\n pub use el_ref::{el_ref, ElRef, SharedNodeWs};\n pub use event_handler_manager::{EventHandler, EventHandlerManager, Listener};\n pub use mailbox::Mailbox;\n-pub use node::{El, IntoNodes, Node, Text};\n+pub use node::{el_key, El, ElKey, IntoNodes, Node, Text};\n pub use style::Style;\n pub use to_classes::ToClasses;\n pub use update_el::{UpdateEl, UpdateElForIterator};\n pub use values::{AsAtValue, AtValue, CSSValue};\n pub use view::View;\n \n pub use crate::dom_entity_names::{At, Ev, St, Tag};\n \n #[cfg(test)]\n pub mod tests {\n     use wasm_bindgen::JsCast;\n     use wasm_bindgen_test::*;\n     use web_sys::{self, Element};\n \n     use crate as seed;\n     use crate::{\n         browser::{dom::virtual_dom_bridge, util},\n         class,\n         prelude::*,\n         virtual_dom::{mailbox::Mailbox, patch},\n     };\n \n     wasm_bindgen_test_configure!(run_in_browser);\n \n     #[derive(Clone, Debug)]\n     enum Msg {}\n \n     struct Model {}\n \n     fn create_app() -> App<Msg, Model, Node<Msg>> {\n         App::build(|_,_| Init::new(Model {}), |_, _, _| (), |_| seed::empty())\n             // mount to the element that exists even in the default test html\n             .mount(util::body())\n             .finish()\n     }\n \n     fn call_patch(\n         doc: &web_sys::Document,\n         parent: &Element,\n         mailbox: &Mailbox<Msg>,\n         old_vdom: Node<Msg>,\n         mut new_vdom: Node<Msg>,\n         app: &App<Msg, Model, Node<Msg>>,\n     ) -> Node<Msg> {\n         patch::patch(&doc, old_vdom, &mut new_vdom, parent, None, mailbox, &app);\n         new_vdom\n     }\n \n     fn iter_nodelist(list: web_sys::NodeList) -> impl Iterator<Item = web_sys::Node> {\n         (0..list.length()).map(move |i| list.item(i).unwrap())\n     }\n \n     fn iter_child_nodes(node: &web_sys::Node) -> impl Iterator<Item = web_sys::Node> {\n         iter_nodelist(node.child_nodes())\n     }\n \n     #[wasm_bindgen_test]\n     fn el_added() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").expect(\"parent\");\n \n         let mut vdom = Node::Element(El::empty(Tag::Div));\n         virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n         // clone so we can keep using it after vdom is modified\n         if let Node::Element(vdom_el) = vdom.clone() {\n             let old_ws = vdom_el.node_ws.as_ref().expect(\"node_ws\").clone();\n             parent.append_child(&old_ws).expect(\"successful appending\");\n \n             assert_eq!(parent.children().length(), 1);\n             assert_eq!(old_ws.child_nodes().length(), 0);\n \n             vdom = call_patch(&doc, &parent, &mailbox, vdom, div![\"text\"], &app);\n             assert_eq!(parent.children().length(), 1);\n             assert!(old_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(old_ws.child_nodes().length(), 1);\n             assert_eq!(\n                 old_ws\n                     .first_child()\n                     .expect(\"first_child\")\n                     .text_content()\n                     .expect(\"first_child's text_content\"),\n                 \"text\"\n             );\n \n             call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![\"text\", \"more text\", vec![li![\"even more text\"]]],\n                 &app,\n             );\n \n             assert_eq!(parent.children().length(), 1);\n             assert!(old_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(old_ws.child_nodes().length(), 3);\n             assert_eq!(\n                 old_ws\n                     .child_nodes()\n                     .item(0)\n                     .expect(\"0. item\")\n                     .text_content()\n                     .expect(\"0. item's text_content\"),\n                 \"text\"\n             );\n             assert_eq!(\n                 old_ws\n                     .child_nodes()\n                     .item(1)\n                     .expect(\"1. item\")\n                     .text_content()\n                     .expect(\"1. item's text_content\"),\n                 \"more text\"\n             );\n             let child3 = old_ws.child_nodes().item(2).expect(\"child3\");\n             assert_eq!(child3.node_name(), \"LI\");\n             assert_eq!(\n                 child3.text_content().expect(\"child3's text_content\"),\n                 \"even more text\"\n             );\n         } else {\n             panic!(\"Node not Element\")\n         }\n     }\n \n     #[wasm_bindgen_test]\n     fn el_removed() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = Node::Element(El::empty(Tag::Div));\n         virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n         // clone so we can keep using it after vdom is modified\n         if let Node::Element(vdom_el) = vdom.clone() {\n             let old_ws = vdom_el.node_ws.as_ref().unwrap().clone();\n             parent.append_child(&old_ws).unwrap();\n \n             // First add some child nodes using the vdom\n             vdom = call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![\"text\", \"more text\", vec![li![\"even more text\"]]],\n                 &app,\n             );\n \n             assert_eq!(parent.children().length(), 1);\n             assert_eq!(old_ws.child_nodes().length(), 3);\n             let old_child1 = old_ws.child_nodes().item(0).unwrap();\n \n             // Now test that patch function removes the last 2 nodes\n             call_patch(&doc, &parent, &mailbox, vdom, div![\"text\"], &app);\n \n             assert_eq!(parent.children().length(), 1);\n             assert!(old_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(old_ws.child_nodes().length(), 1);\n             assert!(old_child1.is_same_node(old_ws.child_nodes().item(0).as_ref()));\n         }\n     }\n \n     #[wasm_bindgen_test]\n     fn el_changed() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = Node::Element(El::empty(Tag::Div));\n         virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n         // clone so we can keep using it after vdom is modified\n         if let Node::Element(el) = vdom.clone() {\n             let old_ws = el.node_ws.as_ref().unwrap().clone();\n             parent.append_child(&old_ws).unwrap();\n \n             // First add some child nodes using the vdom\n             vdom = call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![span![\"hello\"], \", \", span![\"world\"]],\n                 &app,\n             );\n \n             assert_eq!(parent.child_nodes().length(), 1);\n             assert_eq!(old_ws.child_nodes().length(), 3);\n \n             // Now add some attributes\n             call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![\n                     span![class![\"first\"], \"hello\"],\n                     \", \",\n                     span![class![\"second\"], \"world\"],\n                 ],\n                 &app,\n             );\n \n             let child1 = old_ws\n                 .child_nodes()\n                 .item(0)\n                 .unwrap()\n                 .dyn_into::<Element>()\n                 .unwrap();\n             assert_eq!(child1.get_attribute(\"class\"), Some(\"first\".to_string()));\n             let child3 = old_ws\n                 .child_nodes()\n                 .item(2)\n                 .unwrap()\n                 .dyn_into::<Element>()\n                 .unwrap();\n             assert_eq!(child3.get_attribute(\"class\"), Some(\"second\".to_string()));\n         } else {\n             panic!(\"Node not Element\")\n         }\n     }\n \n     #[wasm_bindgen_test]\n     fn els_changed_correct_order() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = div![];\n         virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n         // clone so we can keep using it after vdom is modified\n         if let Node::Element(el) = vdom.clone() {\n             let old_ws = el.node_ws.as_ref().unwrap().clone();\n             parent.append_child(&old_ws).unwrap();\n \n             vdom = call_patch(&doc, &parent, &mailbox, vdom, div![\"1\", a![\"2\"]], &app);\n             let html_result = old_ws.clone().dyn_into::<Element>().unwrap().inner_html();\n             assert_eq!(html_result, \"1<a>2</a>\");\n \n             call_patch(&doc, &parent, &mailbox, vdom, div![a![\"A\"], \"B\"], &app);\n             let html_result = old_ws.dyn_into::<Element>().unwrap().inner_html();\n             assert_eq!(html_result, \"<a>A</a>B\");\n         } else {\n             panic!(\"Node not Element\")\n         }\n     }\n \n     /// Test if attribute `disabled` is correctly added and then removed.\n     #[wasm_bindgen_test]\n     fn attr_disabled() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = Node::Element(El::empty(Tag::Div));\n         virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n         // clone so we can keep using it after vdom is modified\n         if let Node::Element(vdom_el) = vdom.clone() {\n             let old_ws = vdom_el.node_ws.as_ref().unwrap().clone();\n             parent.append_child(&old_ws).unwrap();\n \n             // First add button without attribute `disabled`\n             vdom = call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![button![attrs! { At::Disabled => false.as_at_value() }]],\n                 &app,\n             );\n \n             assert_eq!(parent.child_nodes().length(), 1);\n             assert_eq!(old_ws.child_nodes().length(), 1);\n             let button = old_ws\n                 .child_nodes()\n                 .item(0)\n                 .unwrap()\n                 .dyn_into::<Element>()\n                 .unwrap();\n             assert_eq!(button.has_attribute(\"disabled\"), false);\n \n             // Now add attribute `disabled`\n             vdom = call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![button![attrs! { At::Disabled => true.as_at_value() }]],\n                 &app,\n             );\n \n             let button = old_ws\n                 .child_nodes()\n                 .item(0)\n                 .unwrap()\n                 .dyn_into::<Element>()\n                 .unwrap();\n             assert_eq!(\n                 button\n                     .get_attribute(\"disabled\")\n                     .expect(\"button hasn't got attribute `disabled`!\"),\n                 \"\"\n             );\n \n             // And remove attribute `disabled`\n             call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![button![attrs! { At::Disabled => false.as_at_value() }]],\n                 &app,\n             );\n \n             let button = old_ws\n                 .child_nodes()\n                 .item(0)\n                 .unwrap()\n                 .dyn_into::<Element>()\n                 .unwrap();\n             assert_eq!(button.has_attribute(\"disabled\"), false);\n         } else {\n             panic!(\"Node not El\")\n         }\n     }\n \n     /// Test that if the first child was a seed::empty() and it is changed to a non-empty El,\n     /// then the new element is inserted at the correct position.\n     #[wasm_bindgen_test]\n     fn empty_changed_in_front() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = Node::Element(El::empty(Tag::Div));\n         virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n         // clone so we can keep using it after vdom is modified\n         if let Node::Element(vdom_el) = vdom.clone() {\n             let old_ws = vdom_el.node_ws.as_ref().unwrap().clone();\n             parent.append_child(&old_ws).unwrap();\n \n             assert_eq!(parent.children().length(), 1);\n             assert_eq!(old_ws.child_nodes().length(), 0);\n \n             vdom = call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![seed::empty(), \"b\", \"c\"],\n                 &app,\n             );\n             assert_eq!(parent.children().length(), 1);\n             assert!(old_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(\n                 iter_child_nodes(&old_ws)\n                     .map(|node| node.text_content().unwrap())\n                     .collect::<Vec<_>>(),\n                 &[\"b\", \"c\"],\n             );\n \n             call_patch(&doc, &parent, &mailbox, vdom, div![\"a\", \"b\", \"c\"], &app);\n \n             assert_eq!(parent.children().length(), 1);\n             assert!(old_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(\n                 iter_child_nodes(&old_ws)\n                     .map(|node| node.text_content().unwrap())\n                     .collect::<Vec<_>>(),\n                 &[\"a\", \"b\", \"c\"],\n             );\n         } else {\n             panic!(\"Not Element node\")\n         }\n     }\n \n     /// Test that if a middle child was a seed::empty() and it is changed to a non-empty El,\n     /// then the new element is inserted at the correct position.\n     #[wasm_bindgen_test]\n     fn empty_changed_in_the_middle() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = Node::Element(El::empty(Tag::Div));\n         virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n         if let Node::Element(vdom_el) = vdom.clone() {\n             // clone so we can keep using it after vdom is modified\n             let old_ws = vdom_el.node_ws.as_ref().unwrap().clone();\n             parent.append_child(&old_ws).unwrap();\n \n             assert_eq!(parent.children().length(), 1);\n             assert_eq!(old_ws.child_nodes().length(), 0);\n \n             vdom = call_patch(\n                 &doc,\n                 &parent,\n                 &mailbox,\n                 vdom,\n                 div![\"a\", seed::empty(), \"c\"],\n                 &app,\n             );\n             assert_eq!(parent.children().length(), 1);\n             assert!(old_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(\n                 iter_child_nodes(&old_ws)\n                     .map(|node| node.text_content().unwrap())\n                     .collect::<Vec<_>>(),\n                 &[\"a\", \"c\"],\n             );\n \n             call_patch(&doc, &parent, &mailbox, vdom, div![\"a\", \"b\", \"c\"], &app);\n \n             assert_eq!(parent.children().length(), 1);\n             assert!(old_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(\n                 iter_child_nodes(&old_ws)\n                     .map(|node| node.text_content().unwrap())\n                     .collect::<Vec<_>>(),\n                 &[\"a\", \"b\", \"c\"],\n             );\n         } else {\n             panic!(\"Not Element node\")\n         }\n     }\n \n     /// Test that if the old_el passed to patch was itself an empty, it is correctly patched to a non-empty.\n     #[wasm_bindgen_test]\n     fn root_empty_changed() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = seed::empty();\n \n         vdom = call_patch(\n             &doc,\n             &parent,\n             &mailbox,\n             vdom,\n             div![\"a\", seed::empty(), \"c\"],\n             &app,\n         );\n         assert_eq!(parent.children().length(), 1);\n         if let Node::Element(vdom_el) = vdom {\n             let el_ws = vdom_el.node_ws.as_ref().expect(\"el_ws missing\");\n             assert!(el_ws.is_same_node(parent.first_child().as_ref()));\n             assert_eq!(\n                 iter_child_nodes(&el_ws)\n                     .map(|node| node.text_content().unwrap())\n                     .collect::<Vec<_>>(),\n                 &[\"a\", \"c\"],\n             );\n         } else {\n             panic!(\"Node not Element type\")\n         }\n     }\n \n     /// Test that an empty->empty transition is handled correctly.\n     #[wasm_bindgen_test]\n     fn root_empty_to_empty() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let old = seed::empty();\n         call_patch(&doc, &parent, &mailbox, old, seed::empty(), &app);\n         assert_eq!(parent.children().length(), 0);\n     }\n \n     /// Test that a text Node is correctly patched to an Element and vice versa.\n     #[wasm_bindgen_test]\n     fn text_to_element_to_text() {\n         let app = create_app();\n         let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n \n         let doc = util::document();\n         let parent = doc.create_element(\"div\").unwrap();\n \n         let mut vdom = seed::empty();\n         vdom = call_patch(&doc, &parent, &mailbox, vdom, Node::new_text(\"abc\"), &app);\n         assert_eq!(parent.child_nodes().length(), 1);\n         let text = parent\n             .first_child()\n             .unwrap()\n             .dyn_ref::<web_sys::Text>()\n             .expect(\"not a Text node\")\n             .clone();\n         assert_eq!(text.text_content().unwrap(), \"abc\");\n \n         // change to a span (that contains a text node and styling).\n         // span was specifically chosen here because text Els are saved with the span tag.\n         // (or at least they were when the test was written.)\n         vdom = call_patch(\n             &doc,\n             &parent,\n             &mailbox,\n             vdom,\n             span![style![\"color\" => \"red\"], \"def\"],\n             &app,\n         );\n         assert_eq!(parent.child_nodes().length(), 1);\n         let element = parent\n             .first_child()\n             .unwrap()\n             .dyn_ref::<Element>()\n             .expect(\"not an Element node\")\n             .clone();\n         assert_eq!(&element.tag_name().to_lowercase(), \"span\");\n \n         // change back to a text node\n         call_patch(&doc, &parent, &mailbox, vdom, Node::new_text(\"abc\"), &app);\n         assert_eq!(parent.child_nodes().length(), 1);\n         let text = parent\n             .first_child()\n             .unwrap()\n             .dyn_ref::<web_sys::Text>()\n             .expect(\"not a Text node\")\n             .clone();\n         assert_eq!(text.text_content().unwrap(), \"abc\");\n     }\n \n+    /// Test that the element with the key inserted and removed in the middle correctly.\n+    #[wasm_bindgen_test]\n+    fn el_key_insert_remove() {\n+        let app = create_app();\n+        let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n+\n+        let doc = util::document();\n+        let parent = doc.create_element(\"div\").unwrap();\n+\n+        let mut vdom = Node::Element(El::empty(Tag::Div));\n+        virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n+        // clone so we can keep using it after vdom is modified\n+        if let Node::Element(vdom_el) = vdom.clone() {\n+            let old_ws = vdom_el.node_ws.as_ref().unwrap().clone();\n+            parent.append_child(&old_ws).unwrap();\n+\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 0);\n+\n+            // First add two children nodes using the vdom\n+            vdom = call_patch(\n+                &doc,\n+                &parent,\n+                &mailbox,\n+                vdom,\n+                div![vec![li![\"first\"], li![\"last\"]]],\n+                &app,\n+            );\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 2);\n+\n+            let first = old_ws.child_nodes().item(0).unwrap();\n+            let last = old_ws.child_nodes().item(1).unwrap();\n+\n+            // Then insert the child node in the middle\n+            vdom = call_patch(\n+                &doc,\n+                &parent,\n+                &mailbox,\n+                vdom,\n+                div![vec![\n+                    li![\"first\"],\n+                    li![el_key(&\"middle\"), \"middle\"],\n+                    li![\"last\"]\n+                ]],\n+                &app,\n+            );\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 3);\n+\n+            assert!(first.is_same_node(old_ws.child_nodes().item(0).as_ref()));\n+            assert!(last.is_same_node(old_ws.child_nodes().item(2).as_ref()));\n+\n+            // And then remove the child node in the middle\n+            call_patch(\n+                &doc,\n+                &parent,\n+                &mailbox,\n+                vdom,\n+                div![vec![li![\"first\"], li![\"last\"]]],\n+                &app,\n+            );\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 2);\n+\n+            assert!(first.is_same_node(old_ws.child_nodes().item(0).as_ref()));\n+            assert!(last.is_same_node(old_ws.child_nodes().item(1).as_ref()));\n+        } else {\n+            panic!(\"Node not Element\")\n+        }\n+    }\n+\n+    /// Test that the element with the key is replaced correctly.\n+    #[wasm_bindgen_test]\n+    fn el_key_replace() {\n+        let app = create_app();\n+        let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n+\n+        let doc = util::document();\n+        let parent = doc.create_element(\"div\").unwrap();\n+\n+        let mut vdom = Node::Element(El::empty(Tag::Div));\n+        virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n+        // clone so we can keep using it after vdom is modified\n+        if let Node::Element(vdom_el) = vdom.clone() {\n+            let old_ws = vdom_el.node_ws.as_ref().unwrap().clone();\n+            parent.append_child(&old_ws).unwrap();\n+\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 0);\n+\n+            // First add three children nodes using the vdom\n+            vdom = call_patch(\n+                &doc,\n+                &parent,\n+                &mailbox,\n+                vdom,\n+                div![vec![\n+                    li![el_key(&\"first\"), \"first\"],\n+                    li![el_key(&\"variant-A\"), \"middle\"],\n+                    li![el_key(&\"last\"), \"last\"]\n+                ]],\n+                &app,\n+            );\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 3);\n+\n+            let first = old_ws.child_nodes().item(0).unwrap();\n+            let middle = old_ws.child_nodes().item(1).unwrap();\n+            let last = old_ws.child_nodes().item(2).unwrap();\n+\n+            // Then replace the middle elements.\n+            call_patch(\n+                &doc,\n+                &parent,\n+                &mailbox,\n+                vdom,\n+                div![vec![\n+                    li![el_key(&\"first\"), \"first\"],\n+                    li![el_key(&\"variant-B\"), \"middle\"],\n+                    li![el_key(&\"last\"), \"last\"],\n+                ]],\n+                &app,\n+            );\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 3);\n+\n+            assert!(first.is_same_node(old_ws.child_nodes().item(0).as_ref()));\n+            assert!(!middle.is_same_node(old_ws.child_nodes().item(1).as_ref()));\n+            assert!(last.is_same_node(old_ws.child_nodes().item(2).as_ref()));\n+        } else {\n+            panic!(\"Node not Element\")\n+        }\n+    }\n+\n+    /// Test that the elements with the keys are swaped correctly.\n+    #[wasm_bindgen_test]\n+    fn el_key_swap() {\n+        let app = create_app();\n+        let mailbox = Mailbox::new(|_msg: Option<Msg>| {});\n+\n+        let doc = util::document();\n+        let parent = doc.create_element(\"div\").unwrap();\n+\n+        let mut vdom = Node::Element(El::empty(Tag::Div));\n+        virtual_dom_bridge::assign_ws_nodes(&doc, &mut vdom);\n+        // clone so we can keep using it after vdom is modified\n+        if let Node::Element(vdom_el) = vdom.clone() {\n+            let old_ws = vdom_el.node_ws.as_ref().unwrap().clone();\n+            parent.append_child(&old_ws).unwrap();\n+\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 0);\n+\n+            // First add two children nodes using the vdom\n+            vdom = call_patch(\n+                &doc,\n+                &parent,\n+                &mailbox,\n+                vdom,\n+                div![vec![\n+                    li![el_key(&\"first\"), \"first\"],\n+                    li![el_key(&\"last\"), \"last\"]\n+                ]],\n+                &app,\n+            );\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 2);\n+\n+            let first = old_ws.child_nodes().item(0).unwrap();\n+            let last = old_ws.child_nodes().item(1).unwrap();\n+\n+            // Then swap the first and last elements.\n+            call_patch(\n+                &doc,\n+                &parent,\n+                &mailbox,\n+                vdom,\n+                div![vec![\n+                    li![el_key(&\"last\"), \"last\"],\n+                    li![el_key(&\"first\"), \"first\"]\n+                ]],\n+                &app,\n+            );\n+            assert_eq!(parent.children().length(), 1);\n+            assert_eq!(old_ws.child_nodes().length(), 2);\n+\n+            assert!(\n+                first.is_same_node(old_ws.child_nodes().item(1).as_ref())\n+                    || last.is_same_node(old_ws.child_nodes().item(0).as_ref())\n+            );\n+        } else {\n+            panic!(\"Node not Element\")\n+        }\n+    }\n+\n     /// Tests an update() function that repeatedly sends messages or performs commands.\n     #[wasm_bindgen_test(async)]\n     async fn update_promises() {\n         // ARRANGE\n \n         // when we call `test_value_sender.send(..)`, future `test_value_receiver` will be marked as resolved\n         let (test_value_sender, test_value_receiver) =\n             futures::channel::oneshot::channel::<Counters>();\n \n         // big numbers because we want to test if it doesn't blow call-stack\n         // Note: Firefox has bigger call stack then Chrome - see http://2ality.com/2014/04/call-stack-size.html\n         const MESSAGES_TO_SEND: i32 = 5_000;\n         const COMMANDS_TO_PERFORM: i32 = 4_000;\n \n         #[derive(Default, Copy, Clone, Debug)]\n         struct Counters {\n             messages_sent: i32,\n             commands_scheduled: i32,\n             messages_received: i32,\n             commands_performed: i32,\n         }\n \n         #[derive(Default)]\n         struct Model {\n             counters: Counters,\n             test_value_sender: Option<futures::channel::oneshot::Sender<Counters>>,\n         }\n         #[derive(Clone)]\n         enum Msg {\n             MessageReceived,\n             CommandPerformed,\n             Start,\n         }\n \n         fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {\n             orders.skip();\n \n             match msg {\n                 Msg::MessageReceived => model.counters.messages_received += 1,\n                 Msg::CommandPerformed => model.counters.commands_performed += 1,\n                 Msg::Start => (),\n             }\n \n             if model.counters.messages_sent < MESSAGES_TO_SEND {\n                 orders.send_msg(Msg::MessageReceived);\n                 model.counters.messages_sent += 1;\n             }\n             if model.counters.commands_scheduled < MESSAGES_TO_SEND {\n                 orders.perform_cmd(async { Msg::CommandPerformed });\n                 model.counters.commands_scheduled += 1;\n             }\n \n             if model.counters.messages_received == MESSAGES_TO_SEND\n                 && model.counters.commands_performed == COMMANDS_TO_PERFORM\n             {\n                 model\n                     .test_value_sender\n                     .take()\n                     .unwrap()\n                     .send(model.counters)\n                     .unwrap()\n             }\n         }\n \n         let app = App::build(\n             |_, _| {\n                 Init::new(Model {\n                     test_value_sender: Some(test_value_sender),\n                     ..Default::default()\n                 })\n             },\n             update,\n             |_| seed::empty(),\n         )\n         .mount(seed::body())\n         .finish()\n         .run();\n \n         // ACT\n         app.update(Msg::Start);\n \n         // ASSERT\n         test_value_receiver\n             .await\n             .map(|counters| {\n                 assert_eq!(counters.messages_received, MESSAGES_TO_SEND);\n                 assert_eq!(counters.commands_performed, COMMANDS_TO_PERFORM);\n             })\n             .expect(\"test_value_sender.send probably wasn't called!\");\n     }\n }\ndiff --git a/src/virtual_dom/node.rs b/src/virtual_dom/node.rs\nindex c0745e9..042da99 100644\n--- a/src/virtual_dom/node.rs\n+++ b/src/virtual_dom/node.rs\n@@ -1,199 +1,215 @@\n use super::{AtValue, CSSValue, EventHandler, St};\n use crate::app::MessageMapper;\n use std::borrow::Cow;\n \n pub mod el;\n pub mod into_nodes;\n pub mod text;\n \n-pub use el::El;\n+pub use el::{el_key, El, ElKey};\n pub use into_nodes::IntoNodes;\n pub use text::Text;\n \n /// A component in our virtual DOM.\n /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Node)\n /// [`web_sys` reference](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Node.html)\n #[allow(clippy::large_enum_variant)]\n #[derive(Debug)]\n pub enum Node<Ms> {\n     Element(El<Ms>),\n-    //    Svg(El<Ms>),  // May be best to handle using namespace field on El\n     Text(Text),\n     Empty,\n }\n \n // @TODO remove custom impl once https://github.com/rust-lang/rust/issues/26925 is fixed\n impl<Ms> Clone for Node<Ms> {\n     fn clone(&self) -> Self {\n         match self {\n             Self::Element(element) => Self::Element(element.clone()),\n             Self::Text(text) => Self::Text(text.clone()),\n             Self::Empty => Self::Empty,\n         }\n     }\n }\n \n // Element methods\n impl<Ms> Node<Ms> {\n     /// See `El::from_markdown`\n     pub fn from_markdown(markdown: &str) -> Vec<Node<Ms>> {\n         El::from_markdown(markdown)\n     }\n \n     /// See `El::from_html`\n     pub fn from_html(html: &str) -> Vec<Node<Ms>> {\n         El::from_html(html)\n     }\n \n     /// See `El::add_child`\n     pub fn add_child(&mut self, node: Node<Ms>) -> &mut Self {\n         if let Node::Element(el) = self {\n             el.add_child(node);\n         }\n         self\n     }\n \n     /// See `El::add_attr`\n     pub fn add_attr(\n         &mut self,\n         key: impl Into<Cow<'static, str>>,\n         val: impl Into<AtValue>,\n     ) -> &mut Self {\n         if let Node::Element(el) = self {\n             el.add_attr(key, val);\n         }\n         self\n     }\n \n     /// See `El::add_class`\n     pub fn add_class(&mut self, name: impl Into<Cow<'static, str>>) -> &mut Self {\n         if let Node::Element(el) = self {\n             el.add_class(name);\n         }\n         self\n     }\n \n     /// See `El::add_style`\n     pub fn add_style(&mut self, key: impl Into<St>, val: impl Into<CSSValue>) -> &mut Self {\n         if let Node::Element(el) = self {\n             el.add_style(key, val);\n         }\n         self\n     }\n \n     /// See `El::add_event_handler`\n     pub fn add_event_handler(&mut self, event_handler: EventHandler<Ms>) -> &mut Self {\n         if let Node::Element(el) = self {\n             el.add_event_handler(event_handler);\n         }\n         self\n     }\n \n     /// See `El::add_text`\n     pub fn add_text(&mut self, text: impl Into<Cow<'static, str>>) -> &mut Self {\n         if let Node::Element(el) = self {\n             el.add_text(text);\n         }\n         self\n     }\n \n     /// See `El::replace_text`\n     pub fn replace_text(&mut self, text: impl Into<Cow<'static, str>>) -> &mut Self {\n         if let Node::Element(el) = self {\n             el.replace_text(text);\n         }\n         self\n     }\n \n     /// See `El::get_text`\n     pub fn get_text(&self) -> String {\n         match self {\n             Node::Element(el) => el.get_text(),\n             Node::Text(text) => text.text.to_string(),\n             _ => \"\".to_string(),\n         }\n     }\n+\n+    /// Retrive `key` attached to the `El`\n+    pub fn el_key(&self) -> Option<&ElKey> {\n+        match self {\n+            Node::Element(el) => el.key.as_ref(),\n+            _ => None,\n+        }\n+    }\n }\n \n // Convenience methods\n impl<Ms> Node<Ms> {\n     pub fn new_text(text: impl Into<Cow<'static, str>>) -> Self {\n         Node::Text(Text::new(text))\n     }\n \n     pub fn is_text(&self) -> bool {\n         if let Node::Text(_) = self {\n             true\n         } else {\n             false\n         }\n     }\n     pub fn is_el(&self) -> bool {\n         if let Node::Element(_) = self {\n             true\n         } else {\n             false\n         }\n     }\n     pub fn is_empty(&self) -> bool {\n         if let Node::Empty = self {\n             true\n         } else {\n             false\n         }\n     }\n \n     pub fn text(&self) -> Option<&Text> {\n         if let Node::Text(t) = self {\n             Some(t)\n         } else {\n             None\n         }\n     }\n     pub fn el(&self) -> Option<&El<Ms>> {\n         if let Node::Element(e) = self {\n             Some(e)\n         } else {\n             None\n         }\n     }\n }\n \n // Backing node manipulation\n impl<Ms> Node<Ms> {\n     pub fn strip_ws_nodes_from_self_and_children(&mut self) {\n         match self {\n             Node::Text(t) => t.strip_ws_node(),\n             Node::Element(e) => e.strip_ws_nodes_from_self_and_children(),\n             Node::Empty => (),\n         }\n     }\n \n     #[cfg(debug_assertions)]\n     pub fn warn_about_script_tags(&self) {\n         if let Node::Element(e) = self {\n             e.warn_about_script_tags();\n         }\n     }\n+\n+    pub fn node_ws(&self) -> Option<&web_sys::Node> {\n+        match self {\n+            Self::Element(El { node_ws: val, .. }) | Self::Text(Text { node_ws: val, .. }) => {\n+                val.as_ref()\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n impl<Ms: 'static, OtherMs: 'static> MessageMapper<Ms, OtherMs> for Node<Ms> {\n     type SelfWithOtherMs = Node<OtherMs>;\n     /// See note on impl for El\n     fn map_msg(self, f: impl FnOnce(Ms) -> OtherMs + 'static + Clone) -> Node<OtherMs> {\n         match self {\n             Node::Element(el) => Node::Element(el.map_msg(f)),\n             Node::Text(text) => Node::Text(text),\n             Node::Empty => Node::Empty,\n         }\n     }\n }\n \n impl<Ms: 'static, OtherMs: 'static> MessageMapper<Ms, OtherMs> for Vec<Node<Ms>> {\n     type SelfWithOtherMs = Vec<Node<OtherMs>>;\n     fn map_msg(self, f: impl FnOnce(Ms) -> OtherMs + 'static + Clone) -> Vec<Node<OtherMs>> {\n         self.into_iter()\n             .map(|node| node.map_msg(f.clone()))\n             .collect()\n     }\n }\ndiff --git a/src/virtual_dom/node/el.rs b/src/virtual_dom/node/el.rs\nindex d897422..40f9d4d 100644\n--- a/src/virtual_dom/node/el.rs\n+++ b/src/virtual_dom/node/el.rs\n@@ -1,247 +1,268 @@\n use super::super::{\n     At, AtValue, Attrs, CSSValue, EventHandler, EventHandlerManager, Node, SharedNodeWs, St, Style,\n     Tag, Text,\n };\n use crate::app::MessageMapper;\n use crate::browser::{\n     dom::{virtual_dom_bridge, Namespace},\n     util,\n };\n use std::borrow::Cow;\n \n+// ------ ElKey ------\n+\n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct ElKey(String);\n+\n+#[allow(clippy::module_name_repetitions)]\n+/// Attach given `key` to the `El`.\n+///\n+/// The keys are used by the diffing algorithm to determine the correspondence between old and\n+/// new elements and helps to optimize the insertion, removal and reordering of elements.\n+pub fn el_key(key: &impl ToString) -> ElKey {\n+    ElKey(key.to_string())\n+}\n+\n+// ------ El ------\n+\n /// A component in our virtual DOM.\n ///\n /// _Note:_ `Listener`s in `El`'s `event_handler_manager` are not cloned, but recreated during VDOM patching.\n ///\n /// [MDN reference](https://developer.mozilla.org/en-US/docs/Web/API/Element)\n /// [`web_sys` reference](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Element.html)\n #[derive(Debug)] // todo: Custom debug implementation where children are on new lines and indented.\n pub struct El<Ms> {\n     // Ms is a message type, as in part of TEA.\n     // We call this 'El' instead of 'Element' for brevity, and to prevent\n     // confusion with web_sys::Element.\n     pub tag: Tag,\n     pub attrs: Attrs,\n     pub style: Style,\n     pub event_handler_manager: EventHandlerManager<Ms>,\n     pub children: Vec<Node<Ms>>,\n     pub namespace: Option<Namespace>,\n     /// The actual DOM element/node.\n     pub node_ws: Option<web_sys::Node>,\n     pub refs: Vec<SharedNodeWs>,\n+    pub key: Option<ElKey>,\n }\n \n // @TODO remove custom impl once https://github.com/rust-lang/rust/issues/26925 is fixed\n impl<Ms> Clone for El<Ms> {\n     fn clone(&self) -> Self {\n         Self {\n             tag: self.tag.clone(),\n             attrs: self.attrs.clone(),\n             style: self.style.clone(),\n             event_handler_manager: self.event_handler_manager.clone(),\n             children: self.children.clone(),\n             namespace: self.namespace.clone(),\n             node_ws: self.node_ws.clone(),\n             refs: self.refs.clone(),\n+            key: self.key.clone(),\n         }\n     }\n }\n \n impl<Ms: 'static, OtherMs: 'static> MessageMapper<Ms, OtherMs> for El<Ms> {\n     type SelfWithOtherMs = El<OtherMs>;\n     /// Maps an element's message to have another message.\n     ///\n     /// This allows third party components to integrate with your application without\n     /// having to know about your Msg type beforehand.\n     ///\n     /// # Note\n     /// There is an overhead to calling this versus keeping all messages under one type.\n     /// The deeper the nested structure of children, the more time this will take to run.\n     fn map_msg(self, f: impl FnOnce(Ms) -> OtherMs + 'static + Clone) -> El<OtherMs> {\n         El {\n             tag: self.tag,\n             attrs: self.attrs,\n             style: self.style,\n             children: self\n                 .children\n                 .into_iter()\n                 .map(|c| c.map_msg(f.clone()))\n                 .collect(),\n             node_ws: self.node_ws,\n             namespace: self.namespace,\n             event_handler_manager: self.event_handler_manager.map_msg(f),\n             refs: self.refs,\n+            key: self.key,\n         }\n     }\n }\n \n impl<Ms: 'static, OtherMs: 'static> MessageMapper<Ms, OtherMs> for Vec<El<Ms>> {\n     type SelfWithOtherMs = Vec<El<OtherMs>>;\n     fn map_msg(self, f: impl FnOnce(Ms) -> OtherMs + 'static + Clone) -> Vec<El<OtherMs>> {\n         self.into_iter().map(|el| el.map_msg(f.clone())).collect()\n     }\n }\n \n impl<Ms> El<Ms> {\n     /// Create an empty element, specifying only the tag\n     pub fn empty(tag: Tag) -> Self {\n         Self {\n             tag,\n             attrs: Attrs::empty(),\n             style: Style::empty(),\n             event_handler_manager: EventHandlerManager::new(),\n             children: Vec::new(),\n             namespace: None,\n             node_ws: None,\n             refs: Vec::new(),\n+            key: None,\n         }\n     }\n \n     /// Create an empty SVG element, specifying only the tag\n     pub fn empty_svg(tag: Tag) -> Self {\n         let mut el = El::empty(tag);\n         el.namespace = Some(Namespace::Svg);\n         el\n     }\n \n     // todo: Return El instead of Node here? (Same with from_html)\n     /// Create elements from a markdown string.\n     /// _Note:_ All additional markdown [extensions](https://docs.rs/pulldown-cmark/latest/pulldown_cmark/struct.Options.html) enabled.\n     pub fn from_markdown(markdown: &str) -> Vec<Node<Ms>> {\n         let options = pulldown_cmark::Options::all();\n \n         let parser = pulldown_cmark::Parser::new_ext(markdown, options);\n         let mut html_text = String::new();\n         pulldown_cmark::html::push_html(&mut html_text, parser);\n \n         Self::from_html(&html_text)\n     }\n \n     /// Create elements from an HTML string.\n     pub fn from_html(html: &str) -> Vec<Node<Ms>> {\n         // Create a web_sys::Element, with our HTML wrapped in a (arbitrary) span tag.\n         // We allow web_sys to parse into a DOM tree, then analyze the tree to create our vdom\n         // element.\n         let wrapper = util::document()\n             .create_element(\"placeholder\")\n             .expect(\"Problem creating web-sys element\");\n         wrapper.set_inner_html(html);\n \n         let mut result = Vec::new();\n         let children = wrapper.child_nodes();\n         for i in 0..children.length() {\n             let child = children\n                 .get(i)\n                 .expect(\"Can't find child in raw html element.\");\n \n             if let Some(child_vdom) = virtual_dom_bridge::node_from_ws(&child) {\n                 result.push(child_vdom)\n             }\n         }\n         result\n     }\n \n     /// Add a new child to the element\n     pub fn add_child(&mut self, element: Node<Ms>) -> &mut Self {\n         self.children.push(element);\n         self\n     }\n \n     /// Add an attribute (eg class, or href)\n     pub fn add_attr(\n         &mut self,\n         key: impl Into<Cow<'static, str>>,\n         val: impl Into<AtValue>,\n     ) -> &mut Self {\n         self.attrs.vals.insert(At::from(key), val.into());\n         self\n     }\n \n     /// Add a class. May be cleaner than `add_attr`\n     pub fn add_class(&mut self, name: impl Into<Cow<'static, str>>) -> &mut Self {\n         let name = name.into();\n         self.attrs\n             .vals\n             .entry(At::Class)\n             .and_modify(|at_value| match at_value {\n                 AtValue::Some(v) => {\n                     if !v.is_empty() {\n                         *v += \" \";\n                     }\n                     *v += name.as_ref();\n                 }\n                 _ => *at_value = AtValue::Some(name.clone().into_owned()),\n             })\n             .or_insert(AtValue::Some(name.into_owned()));\n         self\n     }\n \n     /// Add a new style (eg display, or height),\n     pub fn add_style(&mut self, key: impl Into<St>, val: impl Into<CSSValue>) -> &mut Self {\n         self.style.vals.insert(key.into(), val.into());\n         self\n     }\n \n     /// Add a new event handler.\n     pub fn add_event_handler(&mut self, event_handler: EventHandler<Ms>) -> &mut Self {\n         self.event_handler_manager\n             .add_event_handlers(vec![event_handler]);\n         self\n     }\n \n     /// Add a text node to the element. (ie between the HTML tags).\n     pub fn add_text(&mut self, text: impl Into<Cow<'static, str>>) -> &mut Self {\n         self.children.push(Node::Text(Text::new(text)));\n         self\n     }\n \n     /// Replace the element's text.\n     /// Removes all text nodes from element, then adds the new one.\n     pub fn replace_text(&mut self, text: impl Into<Cow<'static, str>>) -> &mut Self {\n         self.children.retain(|node| !node.is_text());\n         self.children.push(Node::new_text(text));\n         self\n     }\n \n     // Pull text from child text nodes\n     pub fn get_text(&self) -> String {\n         self.children\n             .iter()\n             .filter_map(|child| match child {\n                 Node::Text(text_node) => Some(text_node.text.to_string()),\n                 _ => None,\n             })\n             .collect()\n     }\n \n     #[cfg(debug_assertions)]\n     /// Warn user about potential bugs when having scripts and `Takeover` mount type.\n     pub fn warn_about_script_tags(&self) {\n         let script_found = match &self.tag {\n             Tag::Script => true,\n             Tag::Custom(tag) if tag == \"script\" => true,\n             _ => false,\n         };\n         if script_found {\n             error!(\"Script tag found inside mount point! \\\n                     Please check https://docs.rs/seed/latest/seed/app/builder/struct.Builder.html#examples\");\n         }\n \n         for child in &self.children {\n             child.warn_about_script_tags();\n         }\n     }\n \n     /// Remove websys nodes.\n     pub fn strip_ws_nodes_from_self_and_children(&mut self) {\n         self.node_ws.take();\n         for child in &mut self.children {\n             child.strip_ws_nodes_from_self_and_children();\n         }\n     }\n \n     /// Is it a custom element?\n     pub fn is_custom(&self) -> bool {\n         matches!(self.tag, Tag::Custom(_))\n     }\n }\ndiff --git a/src/virtual_dom/patch.rs b/src/virtual_dom/patch.rs\nindex d4ba559..1603bbc 100644\n--- a/src/virtual_dom/patch.rs\n+++ b/src/virtual_dom/patch.rs\n@@ -1,283 +1,319 @@\n //! This module contains code related to patching the VDOM. It can be considered\n //! a subset of the `vdom` module.\n \n-use super::{El, IntoNodes, Mailbox, Node};\n+use super::{El, IntoNodes, Mailbox, Node, Text};\n use crate::app::App;\n use crate::browser::dom::virtual_dom_bridge;\n-use wasm_bindgen::JsCast;\n use web_sys::Document;\n \n+mod patch_gen;\n+use patch_gen::{PatchCommand, PatchGen};\n+\n+// We assume that when we run this, the new vdom doesn't have assigned `web_sys::Node`s -\n+// assign them here when we create them.\n+// @TODO: \"Split\" `Node` into 2 structs - one without native nodes and one with them (?).\n+\n+fn append_el<'a, Ms>(\n+    document: &Document,\n+    new: &'a mut El<Ms>,\n+    parent: &web_sys::Node,\n+    mailbox: &Mailbox<Ms>,\n+) {\n+    virtual_dom_bridge::assign_ws_nodes_to_el(document, new);\n+    virtual_dom_bridge::attach_el_and_children(new, parent, mailbox);\n+}\n+\n+fn append_text<'a>(document: &Document, new: &'a mut Text, parent: &web_sys::Node) {\n+    virtual_dom_bridge::assign_ws_nodes_to_text(document, new);\n+    virtual_dom_bridge::attach_text_node(new, parent);\n+}\n+\n+fn insert_el<'a, Ms>(\n+    document: &Document,\n+    new: &'a mut El<Ms>,\n+    parent: &web_sys::Node,\n+    next_node: web_sys::Node,\n+    mailbox: &Mailbox<Ms>,\n+) {\n+    virtual_dom_bridge::assign_ws_nodes_to_el(document, new);\n+    virtual_dom_bridge::attach_children(new, mailbox);\n+    let new_node = new\n+        .node_ws\n+        .take()\n+        .expect(\"Missing websys el when patching Text to Element\");\n+    virtual_dom_bridge::insert_node(&new_node, parent, Some(next_node));\n+\n+    for ref_ in &mut new.refs {\n+        ref_.set(new_node.clone());\n+    }\n+\n+    new.event_handler_manager\n+        .attach_listeners(new_node.clone(), None, mailbox);\n+\n+    new.node_ws.replace(new_node);\n+}\n+\n+fn insert_text<'a>(\n+    document: &Document,\n+    new: &'a mut Text,\n+    parent: &web_sys::Node,\n+    next_node: web_sys::Node,\n+) {\n+    virtual_dom_bridge::assign_ws_nodes_to_text(document, new);\n+    let new_node_ws = new\n+        .node_ws\n+        .as_ref()\n+        .expect(\"new_node_ws missing when patching Empty to Text\");\n+    virtual_dom_bridge::insert_node(new_node_ws, parent, Some(next_node));\n+}\n+\n fn patch_el<'a, Ms, Mdl, INodes: IntoNodes<Ms>, GMs>(\n     document: &Document,\n     mut old: El<Ms>,\n     new: &'a mut El<Ms>,\n-    parent: &web_sys::Node,\n     mailbox: &Mailbox<Ms>,\n     app: &App<Ms, Mdl, INodes, GMs>,\n-) -> Option<&'a web_sys::Node> {\n-    // At this step, we already assume we have the right element - either\n-    // by entering this func directly for the top-level, or recursively after\n-    // analyzing children\n-\n-    // If the tag's different, we must redraw the element and its children; there's\n-    // no way to patch one element type into another.\n+) {\n+    // At this step, we already assume we have the right element with matching namespace, tag and\n+    // el_key - either by entering this func directly for the top-level, or recursively after\n+    // analyzing children.\n \n     // Assume old el vdom's elements are still attached.\n+    // @TODO: \"Split\" `Node` into 2 structs - one without native nodes and one with them (?).\n \n-    // Namespaces can't be patched, since they involve create_element_ns instead of create_element.\n-    // Custom elements can't be patched, because we need to reinit them (Issue #325). (@TODO is there a better way?)\n-    // Something about this element itself is different: patch it.\n-    if old.tag != new.tag || old.namespace != new.namespace || old.is_custom() {\n-        let old_el_ws = old.node_ws.as_ref().expect(\"Missing websys el\");\n+    let old_el_ws = old\n+        .node_ws\n+        .as_ref()\n+        .expect(\"missing old el_ws when patching non-empty el\")\n+        .clone();\n+    virtual_dom_bridge::patch_el_details(&mut old, new, &old_el_ws, mailbox);\n \n-        // We don't use assign_nodes directly here, since we only have access to\n-        // the El, not wrapping node.\n-        let new_node_ws = virtual_dom_bridge::make_websys_el(new, document);\n-        for ref_ in &mut new.refs {\n-            ref_.set(new_node_ws.clone());\n-        }\n-        new.node_ws = Some(new_node_ws);\n-        for mut child in &mut new.children {\n-            virtual_dom_bridge::assign_ws_nodes(document, &mut child);\n-        }\n-        virtual_dom_bridge::attach_el_and_children(new, parent, mailbox);\n+    for ref_ in &mut new.refs {\n+        ref_.set(old_el_ws.clone());\n+    }\n \n-        let new_ws = new.node_ws.as_ref().expect(\"Missing websys el\");\n-        virtual_dom_bridge::replace_child(new_ws, old_el_ws, parent);\n-    } else {\n-        // Patch parts of the Element.\n-        let old_el_ws = old\n-            .node_ws\n-            .as_ref()\n-            .expect(\"missing old el_ws when patching non-empty el\")\n-            .clone();\n-        virtual_dom_bridge::patch_el_details(&mut old, new, &old_el_ws, mailbox);\n+    let old_children_iter = old.children.into_iter();\n+    let new_children_iter = new.children.iter_mut();\n \n-        for ref_ in &mut new.refs {\n-            ref_.set(old_el_ws.clone());\n-        }\n+    patch_els(\n+        document,\n+        mailbox,\n+        app,\n+        &old_el_ws,\n+        old_children_iter,\n+        new_children_iter,\n+    );\n+    new.node_ws = Some(old_el_ws);\n+}\n \n-        let old_children_iter = old.children.into_iter();\n-        let new_children_iter = new.children.iter_mut();\n+fn patch_text(mut old: Text, new: &mut Text) {\n+    let old_node_ws = old\n+        .node_ws\n+        .take()\n+        .expect(\"old_node_ws missing when changing text\");\n \n-        patch_els(\n-            document,\n-            mailbox,\n-            app,\n-            &old_el_ws,\n-            old_children_iter,\n-            new_children_iter,\n-        );\n-        new.node_ws = Some(old_el_ws);\n+    if new != &old {\n+        old_node_ws.set_text_content(Some(&new.text));\n     }\n-    new.node_ws.as_ref()\n+    new.node_ws.replace(old_node_ws);\n }\n \n-pub(crate) fn patch_els<'a, Ms, Mdl, INodes, GMs, OI, NI>(\n+fn replace_by_el<'a, Ms>(\n     document: &Document,\n+    old_node: &web_sys::Node,\n+    new: &'a mut El<Ms>,\n+    parent: &web_sys::Node,\n     mailbox: &Mailbox<Ms>,\n-    app: &App<Ms, Mdl, INodes, GMs>,\n-    old_el_ws: &web_sys::Node,\n-    old_children_iter: OI,\n-    new_children_iter: NI,\n-) where\n-    INodes: IntoNodes<Ms>,\n-    OI: ExactSizeIterator<Item = Node<Ms>>,\n-    NI: ExactSizeIterator<Item = &'a mut Node<Ms>>,\n-{\n-    let mut old_children_iter = old_children_iter.peekable();\n-    let mut new_children_iter = new_children_iter.peekable();\n-    let mut last_visited_node: Option<web_sys::Node> = None;\n+) {\n+    let new_node = virtual_dom_bridge::make_websys_el(new, document);\n+    for ref_ in &mut new.refs {\n+        ref_.set(new_node.clone());\n+    }\n+    new.node_ws = Some(new_node);\n+    for mut child in &mut new.children {\n+        virtual_dom_bridge::assign_ws_nodes(document, &mut child);\n+    }\n+    virtual_dom_bridge::attach_el_and_children(new, parent, mailbox);\n \n-    // Not using .zip() here to make sure we don't miss any of the children when one array is\n-    // longer than the other.\n-    while let (Some(_), Some(_)) = (old_children_iter.peek(), new_children_iter.peek()) {\n-        let child_old = old_children_iter.next().unwrap();\n-        let child_new = new_children_iter.next().unwrap();\n+    let new_ws = new.node_ws.as_ref().expect(\"Missing websys el\");\n+    virtual_dom_bridge::replace_child(new_ws, old_node, parent);\n+}\n \n-        // Don't compare equality here; we do that at the top of this function\n-        // in the recursion.\n-        if let Some(new_el_ws) = patch(\n-            document,\n-            child_old,\n-            child_new,\n-            old_el_ws,\n-            match last_visited_node.as_ref() {\n-                Some(node) => node.next_sibling(),\n-                None => old_el_ws.first_child(),\n-            },\n-            mailbox,\n-            app,\n-        ) {\n-            last_visited_node = Some(new_el_ws.clone());\n-        }\n-    }\n+fn replace_by_text<'a>(\n+    document: &Document,\n+    old_node: &web_sys::Node,\n+    new: &'a mut Text,\n+    parent: &web_sys::Node,\n+) {\n+    virtual_dom_bridge::assign_ws_nodes_to_text(document, new);\n+    let new_node_ws = new\n+        .node_ws\n+        .as_ref()\n+        .expect(\"old el_ws missing when replacing with text node\");\n \n-    // Now one of the iterators is entirely consumed, and any items left in one iterator\n-    // don't have any matching items in the other.\n-    // We ran out of old children to patch; create new ones.\n-    for child_new in new_children_iter {\n-        virtual_dom_bridge::assign_ws_nodes(document, child_new);\n+    virtual_dom_bridge::replace_child(new_node_ws, old_node, parent);\n+}\n \n-        match child_new {\n-            Node::Element(child_new_el) => {\n-                virtual_dom_bridge::attach_el_and_children(child_new_el, old_el_ws, mailbox);\n-            }\n-            Node::Text(child_new_text) => {\n-                virtual_dom_bridge::attach_text_node(child_new_text, old_el_ws);\n-            }\n-            Node::Empty => (),\n-        }\n-    }\n+fn replace_el_by_el<'a, Ms>(\n+    document: &Document,\n+    mut old: El<Ms>,\n+    new: &'a mut El<Ms>,\n+    parent: &web_sys::Node,\n+    mailbox: &Mailbox<Ms>,\n+) {\n+    let old_node = old\n+        .node_ws\n+        .take()\n+        .expect(\"old el_ws missing when replacing element with new element\");\n+    replace_by_el(document, &old_node, new, parent, mailbox);\n+}\n \n-    // Now purge any existing no-longer-needed children; they're not part of the new vdom.\n-    // while let Some(mut child) = old_children_iter.next() {\n-    for child in old_children_iter {\n-        match child {\n-            Node::Element(mut child_el) => {\n-                let child_ws = child_el.node_ws.take().expect(\"Missing child el_ws\");\n-                virtual_dom_bridge::remove_node(&child_ws, old_el_ws);\n-                child_el.node_ws.replace(child_ws);\n-            }\n-            Node::Text(mut child_text) => {\n-                let child_ws = child_text.node_ws.take().expect(\"Missing child node_ws\");\n-                virtual_dom_bridge::remove_node(&child_ws, old_el_ws);\n-                child_text.node_ws.replace(child_ws);\n-            }\n-            Node::Empty => (),\n-        }\n-    }\n+fn replace_el_by_text<'a, Ms>(\n+    document: &Document,\n+    mut old: El<Ms>,\n+    new: &'a mut Text,\n+    parent: &web_sys::Node,\n+) {\n+    let old_node = old\n+        .node_ws\n+        .take()\n+        .expect(\"old el_ws missing when replacing element with text node\");\n+    replace_by_text(document, &old_node, new, parent);\n }\n \n-// Reduces code repetition\n-fn add_el_helper<Ms>(\n-    new: &mut El<Ms>,\n+fn replace_text_by_el<'a, Ms>(\n+    document: &Document,\n+    mut old: Text,\n+    new: &'a mut El<Ms>,\n     parent: &web_sys::Node,\n-    next_node: Option<web_sys::Node>,\n     mailbox: &Mailbox<Ms>,\n ) {\n-    virtual_dom_bridge::attach_children(new, mailbox);\n-    let new_ws = new\n+    let old_node = old\n         .node_ws\n         .take()\n-        .expect(\"Missing websys el when patching Text to Element\");\n-    virtual_dom_bridge::insert_node(&new_ws, parent, next_node);\n+        .expect(\"old el_ws missing when replacing text node with element\");\n+    replace_by_el(document, &old_node, new, parent, mailbox);\n+}\n \n-    for ref_ in &mut new.refs {\n-        ref_.set(new_ws.clone());\n-    }\n+fn remove_el<Ms>(mut old: El<Ms>, parent: &web_sys::Node) {\n+    let old_node = old.node_ws.take().expect(\"Missing child node_ws\");\n+    virtual_dom_bridge::remove_node(&old_node, parent);\n+    old.node_ws.replace(old_node);\n+}\n \n-    new.event_handler_manager\n-        .attach_listeners(new_ws.clone(), None, mailbox);\n+fn remove_text(mut old: Text, parent: &web_sys::Node) {\n+    let old_node = old.node_ws.take().expect(\"Missing child node_ws\");\n+    virtual_dom_bridge::remove_node(&old_node, parent);\n+    old.node_ws.replace(old_node);\n+}\n \n-    new.node_ws.replace(new_ws);\n+pub(crate) fn patch_els<'a, Ms, Mdl, INodes, GMs, OI, NI>(\n+    document: &Document,\n+    mailbox: &Mailbox<Ms>,\n+    app: &App<Ms, Mdl, INodes, GMs>,\n+    old_el_ws: &web_sys::Node,\n+    old_children_iter: OI,\n+    new_children_iter: NI,\n+) where\n+    INodes: IntoNodes<Ms>,\n+    OI: Iterator<Item = Node<Ms>>,\n+    NI: Iterator<Item = &'a mut Node<Ms>>,\n+{\n+    for command in PatchGen::new(old_children_iter, new_children_iter) {\n+        match command {\n+            PatchCommand::AppendEl { el_new } => append_el(document, el_new, old_el_ws, mailbox),\n+            PatchCommand::AppendText { text_new } => append_text(document, text_new, old_el_ws),\n+            PatchCommand::InsertEl { el_new, next_node } => {\n+                insert_el(document, el_new, old_el_ws, next_node, mailbox)\n+            }\n+            PatchCommand::InsertText {\n+                text_new,\n+                next_node,\n+            } => insert_text(document, text_new, old_el_ws, next_node),\n+            PatchCommand::PatchEl { el_old, el_new } => {\n+                patch_el(document, el_old, el_new, mailbox, app)\n+            }\n+            PatchCommand::PatchText { text_old, text_new } => patch_text(text_old, text_new),\n+            PatchCommand::ReplaceElByEl { el_old, el_new } => {\n+                replace_el_by_el(document, el_old, el_new, old_el_ws, mailbox)\n+            }\n+            PatchCommand::ReplaceTextByEl { text_old, el_new } => {\n+                replace_text_by_el(document, text_old, el_new, old_el_ws, mailbox)\n+            }\n+            PatchCommand::ReplaceElByText { el_old, text_new } => {\n+                replace_el_by_text(document, el_old, text_new, old_el_ws)\n+            }\n+            PatchCommand::RemoveEl { el_old } => remove_el(el_old, old_el_ws),\n+            PatchCommand::RemoveText { text_old } => remove_text(text_old, old_el_ws),\n+        };\n+    }\n }\n \n-/// Routes patching through different channels, depending on the Node variant\n-/// of old and new.\n+/// Routes patching through different channels, depending on the Node variant of old and new.\n+/// Tries to updates the `old` node to become the `new` one.\n+#[cfg(test)]\n pub(crate) fn patch<'a, Ms, Mdl, INodes: IntoNodes<Ms>, GMs>(\n     document: &Document,\n     old: Node<Ms>,\n     new: &'a mut Node<Ms>,\n     parent: &web_sys::Node,\n     next_node: Option<web_sys::Node>,\n     mailbox: &Mailbox<Ms>,\n     app: &App<Ms, Mdl, INodes, GMs>,\n ) -> Option<&'a web_sys::Node> {\n     // Old_el_ws is what we're patching, with items from the new vDOM el; or replacing.\n     // We go through each combination of new and old variants to determine how to patch.\n     // We return the resulting web_sys node for assistance in inserting subsequent\n     // ones in the right place.\n \n     // We assume that when we run this, the new vdom doesn't have assigned `web_sys::Node`s -\n     // assign them here when we create them.\n-    match old {\n-        Node::Element(mut old_el) => {\n-            match new {\n-                Node::Element(new_el) => patch_el(document, old_el, new_el, parent, mailbox, app),\n-                Node::Text(new_text) => {\n-                    // Can't just use assign_ws_nodes; borrow-checker issues.\n-                    new_text.node_ws = Some(\n-                        document\n-                            .create_text_node(&new_text.text)\n-                            .dyn_into::<web_sys::Node>()\n-                            .expect(\"Problem casting Text as Node.\"),\n-                    );\n+    // @TODO: \"Split\" `Node` into 2 structs - one without native nodes and one with them (?).\n \n-                    let old_node_ws = old_el\n-                        .node_ws\n-                        .take()\n-                        .expect(\"old el_ws missing when replacing with text node\");\n-                    let new_node_ws = new_text\n-                        .node_ws\n-                        .as_ref()\n-                        .expect(\"old el_ws missing when replacing with text node\");\n-\n-                    virtual_dom_bridge::replace_child(new_node_ws, &old_node_ws, parent);\n-                    new_text.node_ws.as_ref()\n-                }\n-                Node::Empty => {\n-                    let old_el_ws = old_el\n-                        .node_ws\n-                        .take()\n-                        .expect(\"old el_ws missing when patching Element to Empty\");\n-                    virtual_dom_bridge::remove_node(&old_el_ws, parent);\n-                    None\n+    // @TODO Do we realy need this function? This function could be replaced by calling\n+    // `patch_els` with `std::iter::once` for old and new nodes.\n+    match old {\n+        Node::Element(old_el) => match new {\n+            Node::Element(new_el) => {\n+                if patch_gen::el_can_be_patched(&old_el, new_el) {\n+                    patch_el(document, old_el, new_el, mailbox, app)\n+                } else {\n+                    replace_el_by_el(document, old_el, new_el, parent, mailbox)\n                 }\n             }\n-        }\n+            Node::Text(new_text) => replace_el_by_text(document, old_el, new_text, parent),\n+            Node::Empty => remove_el(old_el, parent),\n+        },\n         Node::Empty => {\n-            // If the old node's empty, assign and attach web_sys nodes.\n-            virtual_dom_bridge::assign_ws_nodes(document, new);\n             match new {\n                 Node::Element(new_el) => {\n-                    add_el_helper(new_el, parent, next_node, mailbox);\n-                    new_el.node_ws.as_ref()\n+                    if let Some(next) = next_node {\n+                        insert_el(document, new_el, parent, next, mailbox)\n+                    } else {\n+                        append_el(document, new_el, parent, mailbox)\n+                    }\n                 }\n                 Node::Text(new_text) => {\n-                    let new_node_ws = new_text\n-                        .node_ws\n-                        .as_ref()\n-                        .expect(\"new_node_ws missing when patching Empty to Text\");\n-                    virtual_dom_bridge::insert_node(new_node_ws, parent, next_node);\n-                    new_text.node_ws.as_ref()\n+                    if let Some(next) = next_node {\n+                        insert_text(document, new_text, parent, next)\n+                    } else {\n+                        append_text(document, new_text, parent)\n+                    }\n                 }\n                 // If new and old are empty, we don't need to do anything.\n-                Node::Empty => None,\n+                Node::Empty => (),\n             }\n         }\n-        Node::Text(mut old_text) => {\n+        Node::Text(old_text) => {\n             virtual_dom_bridge::assign_ws_nodes(document, new);\n             match new {\n                 Node::Element(new_el) => {\n-                    add_el_helper(new_el, parent, next_node, mailbox);\n-\n-                    virtual_dom_bridge::remove_node(\n-                        &old_text.node_ws.expect(\"Can't find node from Text\"),\n-                        parent,\n-                    );\n-                    new_el.node_ws.as_ref()\n-                }\n-                Node::Empty => {\n-                    virtual_dom_bridge::remove_node(\n-                        &old_text.node_ws.expect(\"Can't find old text\"),\n-                        parent,\n-                    );\n-                    None\n-                }\n-                Node::Text(new_text) => {\n-                    let old_node_ws = old_text\n-                        .node_ws\n-                        .take()\n-                        .expect(\"old_node_ws missing when changing text\");\n-\n-                    if new_text != &old_text {\n-                        old_node_ws.set_text_content(Some(&new_text.text));\n-                    }\n-                    new_text.node_ws.replace(old_node_ws);\n-                    new_text.node_ws.as_ref()\n+                    replace_text_by_el(document, old_text, new_el, parent, mailbox)\n                 }\n+                Node::Empty => remove_text(old_text, parent),\n+                Node::Text(new_text) => patch_text(old_text, new_text),\n             }\n         }\n-    }\n+    };\n+    new.node_ws()\n }\ndiff --git a/src/virtual_dom/patch/patch_gen.rs b/src/virtual_dom/patch/patch_gen.rs\nnew file mode 100644\nindex 0000000..931ca8a\n--- /dev/null\n+++ b/src/virtual_dom/patch/patch_gen.rs\n@@ -0,0 +1,556 @@\n+//!\n+//! This module decides how to update nodes.\n+//!\n+//! ### Keyless mode\n+//!\n+//! The patch algorithm starts with keyless mode.\n+//! In this mode, a pair of nodes is taken: old and new.\n+//! - if the node type, tag, and namespace are equal, the old node is updated with the new one.\n+//! - if the nodes are different, then the new node replaces the old one.\n+//! - If the old node is empty, the new node is inserted before the next non-empty old node.\n+//! - If the new node is empty, the old node is deleted.\n+//! - All remaining new nodes are added to the end.\n+//! - All remaining old nodes are deleted.\n+//!\n+//! As soon as the old or new node has a key, the algorithm switches to the key mode.\n+//!\n+//! ### Keyed mode\n+//!\n+//! Suppose we have old and new child nodes with `el_key`s:\n+//! ```text\n+//! old: [a] [b] [c] [d] [e] [f] [g] [h]\n+//! new: [a] [d] [e] [b] [c] [x] [f] [y]\n+//! ```\n+//!\n+//! The algorithm starts by taking nodes from the source iterators one by one in turn (new and old)\n+//! and putting them in the corresponding queues:\n+//! ```text\n+//! old: [a]\n+//! new: [a]\n+//! ```\n+//!\n+//! Now we have the matching key in queues. The algorithm takes nodes from the queues and yields\n+//! `patch [a] by [a]` command.\n+//!\n+//! But then nodes become diverse:\n+//! ```text\n+//! old: [b] [c]\n+//! new: [d] [e] [b]\n+//! ```\n+//!\n+//! As soon as the algorithm finds the matching key `[b]` it yields three commands:\n+//! `insert [d] before old [b]`, `insert [e] before old [b]` and then `patch [b] by [b]`.\n+//! Old node `[c]` remains in queue.\n+//!\n+//! The algorithm continues to fill queues and stops with matching nodes `[c]`. Then it issues `patch`\n+//! command:\n+//! ```text\n+//! old: [c]\n+//! new: [c]\n+//! ```\n+//!\n+//! Then nodes again become diverse:\n+//! ```text\n+//! old: [d] [e] [f]\n+//! new: [x] [f] [y]\n+//! ```\n+//!\n+//! The algorithm stops when finds the matching key `[f]` and yields three commands:\n+//! `replace [d] by [x]`, `remove [e]`, `patch [f] by [f]`.\n+//!\n+//! At this point the source iterator for the new nodes has been exhausted and the algorithm\n+//! continues to take only old nodes.\n+//! ```text\n+//! old: [g] [h]\n+//! new: [y]\n+//! ```\n+//!\n+//! At this point both source iterators are exhausted and the algorithm yields:\n+//! `replace [g] by [y]` and `remove [h]`.\n+//! The append command means append as a last children.\n+//!\n+\n+use crate::browser::dom::Namespace;\n+use crate::virtual_dom::{El, ElKey, Node, Tag, Text};\n+use std::borrow::Borrow;\n+use std::collections::{BTreeSet, VecDeque};\n+use std::iter::Peekable;\n+\n+#[allow(clippy::large_enum_variant)]\n+pub(crate) enum PatchCommand<'a, Ms: 'static> {\n+    AppendEl {\n+        el_new: &'a mut El<Ms>,\n+    },\n+    AppendText {\n+        text_new: &'a mut Text,\n+    },\n+    InsertEl {\n+        el_new: &'a mut El<Ms>,\n+        next_node: web_sys::Node,\n+    },\n+    InsertText {\n+        text_new: &'a mut Text,\n+        next_node: web_sys::Node,\n+    },\n+    PatchEl {\n+        el_old: El<Ms>,\n+        el_new: &'a mut El<Ms>,\n+    },\n+    PatchText {\n+        text_old: Text,\n+        text_new: &'a mut Text,\n+    },\n+    ReplaceElByEl {\n+        el_old: El<Ms>,\n+        el_new: &'a mut El<Ms>,\n+    },\n+    ReplaceElByText {\n+        el_old: El<Ms>,\n+        text_new: &'a mut Text,\n+    },\n+    ReplaceTextByEl {\n+        text_old: Text,\n+        el_new: &'a mut El<Ms>,\n+    },\n+    RemoveEl {\n+        el_old: El<Ms>,\n+    },\n+    RemoveText {\n+        text_old: Text,\n+    },\n+}\n+\n+/// `PatchKey` used to compare nodes during patching.\n+///\n+/// A function `find_matching` stores these keys to check if the key has already been seen.\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+enum PatchKey {\n+    Element {\n+        namespace: Option<Namespace>,\n+        tag: Tag,\n+        el_key: Option<ElKey>,\n+    },\n+    Text,\n+}\n+\n+impl PatchKey {\n+    fn new<Ms: 'static>(node: &Node<Ms>) -> Option<Self> {\n+        match node {\n+            Node::Element(el) => Some(PatchKey::Element {\n+                namespace: el.namespace.clone(),\n+                tag: el.tag.clone(),\n+                el_key: el.key.clone(),\n+            }),\n+            Node::Text(_) => Some(PatchKey::Text),\n+            Node::Empty => None,\n+        }\n+    }\n+}\n+\n+/// This is a command generator.\n+/// See the module documenation for brief description of how this works.\n+pub(crate) struct PatchGen<'a, Ms, OI, NI>\n+where\n+    Ms: 'static,\n+    OI: Iterator<Item = Node<Ms>>,\n+    NI: Iterator<Item = &'a mut Node<Ms>>,\n+{\n+    old_children_iter: Peekable<OI>,\n+    new_children_iter: Peekable<NI>,\n+    old_children: VecDeque<Node<Ms>>,\n+    new_children: VecDeque<&'a mut Node<Ms>>,\n+    matching_child_old: Option<OI::Item>,\n+    matching_child_new: Option<NI::Item>,\n+    matching_key: Option<PatchKey>,\n+    keyed_mode: bool,\n+}\n+\n+impl<'a, Ms, OI, NI> PatchGen<'a, Ms, OI, NI>\n+where\n+    Ms: 'static,\n+    OI: Iterator<Item = Node<Ms>>,\n+    NI: Iterator<Item = &'a mut Node<Ms>>,\n+{\n+    /// Creates the new `PatchGen` instance from the source iterators.\n+    pub fn new(old_children_iter: OI, new_children_iter: NI) -> Self {\n+        Self {\n+            old_children_iter: old_children_iter.peekable(),\n+            new_children_iter: new_children_iter.peekable(),\n+            old_children: VecDeque::new(),\n+            new_children: VecDeque::new(),\n+            matching_child_old: None,\n+            matching_child_new: None,\n+            matching_key: None,\n+            keyed_mode: false,\n+        }\n+    }\n+\n+    /// Decides what command to produce according to the internal state.\n+    fn next_command(&mut self) -> Option<PatchCommand<'a, Ms>> {\n+        if !self.keyed_mode {\n+            return self.yield_keyless();\n+        }\n+        // Matching `PatchKey` has been already found.\n+        if self.matching_key.is_some() {\n+            return self.yield_keyed();\n+        }\n+        // Try to find matching key if at least one iterator has some nodes.\n+        if self.old_children_iter.peek().is_some() || self.new_children_iter.peek().is_some() {\n+            self.matching_key = find_matching(\n+                &mut self.old_children_iter,\n+                &mut self.old_children,\n+                &mut self.new_children_iter,\n+                &mut self.new_children,\n+            );\n+            // Matching key has been found.\n+            if self.matching_key.is_some() {\n+                return self.yield_keyed();\n+            }\n+        }\n+        self.yield_remaining()\n+    }\n+\n+    /// Takes a pair of old and new children from source iterators and decides how to update the\n+    /// old child by the new one.\n+    /// Sets `keyed_mode` to true and calls `yield_keyed` as soon as any child has an element key.\n+    fn yield_keyless(&mut self) -> Option<PatchCommand<'a, Ms>> {\n+        // Take a pair of old/new children but skip if both are `Some(Node::Empty)`.\n+        let (child_old, child_new) = loop {\n+            // First consume the children stored in the queue.\n+            // When old child is `Empty` we call `find_next_node_ws` which\n+            // moves some children from the source iterator to the queue.\n+            let old = self\n+                .old_children\n+                .pop_back()\n+                .or_else(|| self.old_children_iter.next());\n+            let new = self.new_children_iter.next();\n+            // We should not issue any command if both the old and the new nodes are `Empty`.\n+            if let (Some(Node::Empty), Some(Node::Empty)) = (&old, &new) {\n+                continue;\n+            }\n+            break (old, new);\n+        };\n+\n+        match (child_old, child_new) {\n+            (Some(child_old), Some(child_new)) => {\n+                if child_old.el_key().is_none() && child_new.el_key().is_none() {\n+                    return self.patch_or_replace(child_old, child_new);\n+                }\n+\n+                // Permanent switch to keyed mode.\n+                self.keyed_mode = true;\n+\n+                let key_old = PatchKey::new(&child_old);\n+                let key_new = PatchKey::new(child_new);\n+                if key_old == key_new {\n+                    self.matching_key = key_new;\n+                }\n+                if !child_old.is_empty() {\n+                    self.old_children.push_back(child_old);\n+                }\n+                if !child_new.is_empty() {\n+                    self.new_children.push_back(child_new);\n+                }\n+                self.next_command()\n+            }\n+            (None, Some(child_new)) => self.append(child_new),\n+            (Some(child_old), None) => self.remove(child_old),\n+            (None, None) => None,\n+        }\n+    }\n+\n+    /// Produces commands from children stored in the `old_children` and the `new_children` queues\n+    /// until the child key is equal to `matching_key`, then returns the `PatchEl` or `ReplaceElByEl`\n+    /// command.\n+    ///\n+    /// `self.matching_key` has to be set before calling this method.\n+    fn yield_keyed(&mut self) -> Option<PatchCommand<'a, Ms>> {\n+        // `self.matching_child_old` and `self.matching_child_new` are set only in this method.\n+        // Therefore the first matching arm is always `(None, None)`.\n+        match (\n+            self.matching_child_old.as_ref(),\n+            self.matching_child_new.as_ref(),\n+        ) {\n+            // No nodes with the matching key have been found.\n+            (None, None) => {\n+                // If the matching key is set then both the old and the new children queues\n+                // have a node with this key.\n+                let child_old = self\n+                    .old_children\n+                    .pop_back()\n+                    .expect(\"old child from the queue\");\n+                let child_new = self\n+                    .new_children\n+                    .pop_back()\n+                    .expect(\"new child from the queue\");\n+\n+                let key_old = PatchKey::new(&child_old);\n+                let key_new = PatchKey::new(child_new);\n+\n+                if key_old == self.matching_key && key_new == self.matching_key {\n+                    self.matching_child_old = Some(child_old);\n+                    self.matching_child_new = Some(child_new);\n+                    return self.yield_keyed();\n+                }\n+                if key_old == self.matching_key {\n+                    let next_node = child_old.node_ws().unwrap().clone();\n+                    self.matching_child_old = Some(child_old);\n+                    return self.insert(child_new, next_node);\n+                }\n+                if key_new == self.matching_key {\n+                    self.matching_child_new = Some(child_new);\n+                    return self.remove(child_old);\n+                }\n+                self.patch_or_replace(child_old, child_new)\n+            }\n+            // An old node with the matching key has been found in the queue.\n+            (Some(child_old), None) => {\n+                let child_new = self\n+                    .new_children\n+                    .pop_back()\n+                    .expect(\"node with a matching key\");\n+\n+                if PatchKey::new(child_new) == self.matching_key {\n+                    self.matching_child_new = Some(child_new);\n+                    return self.yield_keyed();\n+                }\n+                let next_node = child_old\n+                    .node_ws()\n+                    .expect(\"old node connected to web_sys node\")\n+                    .clone();\n+                self.insert(child_new, next_node)\n+            }\n+            // A new node with the matching key has been found in the queue.\n+            (None, Some(_)) => {\n+                let child_old = self\n+                    .old_children\n+                    .pop_back()\n+                    .expect(\"node with a matching key\");\n+\n+                if PatchKey::new(&child_old) == self.matching_key {\n+                    self.matching_child_old = Some(child_old);\n+                    return self.yield_keyed();\n+                }\n+                self.remove(child_old)\n+            }\n+            // An old and a new node with the matching key have been found in queues.\n+            (Some(_), Some(_)) => {\n+                // We have found the matching node pair, we no longer need the key.\n+                self.matching_key = None;\n+                let child_old = self.matching_child_old.take().unwrap();\n+                let child_new = self.matching_child_new.take().unwrap();\n+                self.patch_or_replace(child_old, child_new)\n+            }\n+        }\n+    }\n+\n+    /// Takes a pair of the remaining children stored in the queues and returns the command.\n+    fn yield_remaining(&mut self) -> Option<PatchCommand<'a, Ms>> {\n+        match (self.old_children.pop_back(), self.new_children.pop_back()) {\n+            (Some(child_old), Some(child_new)) => self.patch_or_replace(child_old, child_new),\n+            (Some(child_old), None) => self.remove(child_old),\n+            (None, Some(child_new)) => self.append(child_new),\n+            (None, None) => None,\n+        }\n+    }\n+\n+    fn append(&mut self, child_new: &'a mut Node<Ms>) -> Option<PatchCommand<'a, Ms>> {\n+        Some(match child_new {\n+            Node::Element(el_new) => PatchCommand::AppendEl { el_new },\n+            Node::Text(text_new) => PatchCommand::AppendText { text_new },\n+            Node::Empty => return self.next_command(),\n+        })\n+    }\n+\n+    fn insert(\n+        &mut self,\n+        child_new: &'a mut Node<Ms>,\n+        next_node: web_sys::Node,\n+    ) -> Option<PatchCommand<'a, Ms>> {\n+        Some(match child_new {\n+            Node::Element(el_new) => PatchCommand::InsertEl { el_new, next_node },\n+            Node::Text(text_new) => PatchCommand::InsertText {\n+                text_new,\n+                next_node,\n+            },\n+            Node::Empty => return self.next_command(),\n+        })\n+    }\n+\n+    fn patch_or_replace(\n+        &mut self,\n+        child_old: Node<Ms>,\n+        child_new: &'a mut Node<Ms>,\n+    ) -> Option<PatchCommand<'a, Ms>> {\n+        Some(match child_old {\n+            Node::Element(el_old) => match child_new {\n+                Node::Element(el_new) => {\n+                    if el_can_be_patched(&el_old, el_new) {\n+                        PatchCommand::PatchEl { el_old, el_new }\n+                    } else {\n+                        PatchCommand::ReplaceElByEl { el_old, el_new }\n+                    }\n+                }\n+                Node::Text(text_new) => PatchCommand::ReplaceElByText { el_old, text_new },\n+                Node::Empty => PatchCommand::RemoveEl { el_old },\n+            },\n+            Node::Text(text_old) => match child_new {\n+                Node::Element(el_new) => PatchCommand::ReplaceTextByEl { text_old, el_new },\n+                Node::Text(text_new) => PatchCommand::PatchText { text_old, text_new },\n+                Node::Empty => PatchCommand::RemoveText { text_old },\n+            },\n+            Node::Empty => match child_new {\n+                Node::Element(el_new) => {\n+                    if let Some(next_node) =\n+                        find_next_node_ws(&mut self.old_children_iter, &mut self.old_children)\n+                    {\n+                        PatchCommand::InsertEl { el_new, next_node }\n+                    } else {\n+                        PatchCommand::AppendEl { el_new }\n+                    }\n+                }\n+                Node::Text(text_new) => {\n+                    if let Some(next_node) =\n+                        find_next_node_ws(&mut self.old_children_iter, &mut self.old_children)\n+                    {\n+                        PatchCommand::InsertText {\n+                            text_new,\n+                            next_node,\n+                        }\n+                    } else {\n+                        PatchCommand::AppendText { text_new }\n+                    }\n+                }\n+                Node::Empty => return self.next_command(),\n+            },\n+        })\n+    }\n+\n+    fn remove(&mut self, child_old: Node<Ms>) -> Option<PatchCommand<'a, Ms>> {\n+        Some(match child_old {\n+            Node::Element(el_old) => PatchCommand::RemoveEl { el_old },\n+            Node::Text(text_old) => PatchCommand::RemoveText { text_old },\n+            Node::Empty => return self.next_command(),\n+        })\n+    }\n+}\n+\n+impl<'a, Ms, OI, NI> Iterator for PatchGen<'a, Ms, OI, NI>\n+where\n+    Ms: 'static,\n+    OI: Iterator<Item = Node<Ms>>,\n+    NI: Iterator<Item = &'a mut Node<Ms>>,\n+{\n+    type Item = PatchCommand<'a, Ms>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.next_command()\n+    }\n+}\n+\n+/// Checks whether the old element can be updated with a new one.\n+pub(crate) fn el_can_be_patched<Ms>(el_old: &El<Ms>, el_new: &El<Ms>) -> bool {\n+    // Custom elements can't be patched, because we need to reinit them (Issue #325).\n+    // @TODO remove this check when #364 will be done.\n+    el_old.namespace == el_new.namespace\n+        && el_old.tag == el_new.tag\n+        && el_old.key == el_new.key\n+        && !el_new.is_custom()\n+}\n+\n+/// Takes children from source iterators (new and old) and puts them in the\n+/// corresponding queues.\n+///\n+/// Stops when:\n+/// - The key of the new child matches to any key of the previously seen old children.\n+/// - The key of the old child matches to any key of the previously seen new children.\n+fn find_matching<OI, NI, ON, NN, Ms>(\n+    old_children_iter: &mut Peekable<OI>,\n+    old_children: &mut VecDeque<ON>,\n+    new_children_iter: &mut Peekable<NI>,\n+    new_children: &mut VecDeque<NN>,\n+) -> Option<PatchKey>\n+where\n+    OI: Iterator<Item = ON>,\n+    NI: Iterator<Item = NN>,\n+    ON: Borrow<Node<Ms>>,\n+    NN: Borrow<Node<Ms>>,\n+    Ms: 'static,\n+{\n+    // First store all seen keys to the sets.\n+    // One for the old children.\n+    let mut seen_old_keys: BTreeSet<_> = old_children\n+        .iter()\n+        .filter_map(|node| PatchKey::new(node.borrow()))\n+        .collect();\n+    // And one for the new children.\n+    let mut seen_new_keys: BTreeSet<_> = new_children\n+        .iter()\n+        .filter_map(|node| PatchKey::new(node.borrow()))\n+        .collect();\n+\n+    while old_children_iter.peek().is_some() || new_children_iter.peek().is_some() {\n+        // Fill the old/new children queues and keep the same queue lengths.\n+        let should_pick_old_child = old_children_iter.peek().is_some()\n+            && (new_children_iter.peek().is_none() || new_children.len() > old_children.len());\n+\n+        if should_pick_old_child {\n+            if let Some(key) = fetch_next_item(old_children_iter, old_children)\n+                .and_then(|child| PatchKey::new(child.borrow()))\n+            {\n+                if seen_new_keys.contains(&key) {\n+                    return Some(key);\n+                }\n+                seen_old_keys.insert(key);\n+            }\n+        } else if new_children_iter.peek().is_some() {\n+            if let Some(key) = fetch_next_item(new_children_iter, new_children)\n+                .and_then(|child| PatchKey::new(child.borrow()))\n+            {\n+                if seen_old_keys.contains(&key) {\n+                    return Some(key);\n+                }\n+                seen_new_keys.insert(key);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+/// Searches for the next node with set `web_sys::Node` and returns a clone of that\n+/// `web_sys::Node` or `None` if there is no such node.\n+fn find_next_node_ws<I, N, Ms>(\n+    children_iter: &mut Peekable<I>,\n+    children: &mut VecDeque<N>,\n+) -> Option<web_sys::Node>\n+where\n+    I: Iterator<Item = N>,\n+    N: Borrow<Node<Ms>>,\n+    Ms: 'static,\n+{\n+    // Search in the stored children first.\n+    if let node_ws @ Some(_) = children.iter().find_map(|child| child.borrow().node_ws()) {\n+        return node_ws.cloned();\n+    }\n+    // Consume the source iterator if there is no stored child with the searched node.\n+    while let Some(child) = fetch_next_item(children_iter, children) {\n+        if let node_ws @ Some(_) = child.borrow().node_ws() {\n+            return node_ws.cloned();\n+        }\n+    }\n+    None\n+}\n+\n+/// Fetches the next item from the `source_iter` iterator, pushes this item to the\n+/// `queue` and returns a reference to this item.\n+fn fetch_next_item<'a, I, T>(source_iter: &'a mut I, queue: &'a mut VecDeque<T>) -> Option<&'a T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    if let Some(item) = source_iter.next() {\n+        queue.push_front(item);\n+        queue.front()\n+    } else {\n+        None\n+    }\n+}\ndiff --git a/src/virtual_dom/update_el.rs b/src/virtual_dom/update_el.rs\nindex 80c83ad..cdad8df 100644\n--- a/src/virtual_dom/update_el.rs\n+++ b/src/virtual_dom/update_el.rs\n@@ -1,431 +1,437 @@\n-use super::{Attrs, El, ElRef, EventHandler, Node, Style, Tag, Text};\n+use super::{Attrs, El, ElKey, ElRef, EventHandler, Node, Style, Tag, Text};\n \n // ------ Traits ------\n \n /// `UpdateEl` is used to distinguish arguments in element-creation macros, and handle\n /// each type appropriately.\n pub trait UpdateEl<Ms> {\n     fn update_el(self, el: &mut El<Ms>);\n }\n \n /// Similar to `UpdateEl`, specialized for `Iterator`.\n #[allow(clippy::module_name_repetitions)]\n pub trait UpdateElForIterator<Ms> {\n     fn update_el(self, el: &mut El<Ms>);\n }\n \n // ------ Implementations ------\n \n impl<Ms, T: UpdateEl<Ms> + Clone> UpdateEl<Ms> for &T {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.clone().update_el(el);\n     }\n }\n \n // --- V-DOM entities ---\n \n impl<Ms> UpdateEl<Ms> for Attrs {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.attrs.merge(self);\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for Style {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.style.merge(self);\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for EventHandler<Ms> {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.event_handler_manager.add_event_handlers(vec![self])\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for El<Ms> {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.children.push(Node::Element(self))\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for Node<Ms> {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.children.push(self)\n     }\n }\n \n /// This is intended only to be used for the `custom!` element macro.\n impl<Ms> UpdateEl<Ms> for Tag {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.tag = self;\n     }\n }\n \n impl<Ms, E: Clone> UpdateEl<Ms> for ElRef<E> {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.refs.push(self.shared_node_ws);\n     }\n }\n \n+impl<Ms> UpdateEl<Ms> for ElKey {\n+    fn update_el(self, el: &mut El<Ms>) {\n+        el.key = Some(self);\n+    }\n+}\n+\n // --- Texts ---\n \n impl<Ms> UpdateEl<Ms> for String {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.children.push(Node::Text(Text::new(self)))\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for &str {\n     fn update_el(self, el: &mut El<Ms>) {\n         el.children.push(Node::Text(Text::new(self.to_string())))\n     }\n }\n \n // --- Numbers ---\n \n impl<Ms> UpdateEl<Ms> for u32 {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.to_string().update_el(el);\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for u64 {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.to_string().update_el(el);\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for i32 {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.to_string().update_el(el);\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for i64 {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.to_string().update_el(el);\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for usize {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.to_string().update_el(el);\n     }\n }\n \n impl<Ms> UpdateEl<Ms> for f64 {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.to_string().update_el(el);\n     }\n }\n \n // --- Containers ---\n \n impl<Ms, T: UpdateEl<Ms>, I: Iterator<Item = T>> UpdateElForIterator<Ms> for I {\n     fn update_el(self, el: &mut El<Ms>) {\n         for item in self {\n             item.update_el(el);\n         }\n     }\n }\n \n impl<Ms, T: UpdateEl<Ms>> UpdateEl<Ms> for Option<T> {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.into_iter().update_el(el)\n     }\n }\n \n impl<Ms, T: UpdateEl<Ms>> UpdateEl<Ms> for Vec<T> {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.into_iter().update_el(el)\n     }\n }\n \n impl<Ms, T: UpdateEl<Ms> + Clone> UpdateEl<Ms> for &[T] {\n     fn update_el(self, el: &mut El<Ms>) {\n         self.iter().update_el(el)\n     }\n }\n \n // ------ ------ Tests ------ ------\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use crate::prelude::*;\n     use wasm_bindgen_test::*;\n \n     type Ms = ();\n \n     // @TODO:\n     // These tests only check types.\n     // Verify also HTML once https://github.com/seed-rs/seed/issues/294 is resolved.\n     // DRY\n \n     // --- V-DOM entities ---\n \n     #[wasm_bindgen_test]\n     fn update_el_attrs() {\n         let attrs: Attrs = attrs!(At::Href => \"https://example.com\");\n         let _el: Node<Ms> = div![attrs];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_attrs() {\n         let attrs: &Attrs = &attrs!(At::Href => \"https://example.com\");\n         let _el: Node<Ms> = div![attrs];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_style() {\n         let style: Style = style! {St::Left => px(5)};\n         let _el: Node<Ms> = div![style];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_style() {\n         let style: &Style = &style! {St::Left => px(5)};\n         let _el: Node<Ms> = div![style];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_event_handler() {\n         let event_handler: EventHandler<Ms> = ev(Ev::Click, |_| ());\n         let _el: Node<Ms> = div![event_handler];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_event_handler() {\n         let event_handler: &EventHandler<Ms> = &ev(Ev::Click, |_| ());\n         let _el: Node<Ms> = div![event_handler];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_el() {\n         let el: El<Ms> = El::empty(Tag::H2);\n         let _el: Node<Ms> = div![el];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_el() {\n         let el: &El<Ms> = &El::empty(Tag::H2);\n         let _el: Node<Ms> = div![el];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_node() {\n         let node: Node<Ms> = span![];\n         let _el: Node<Ms> = div![node];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_node() {\n         let node: &Node<Ms> = &span![];\n         let _el: Node<Ms> = div![node];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_tag() {\n         let tag: Tag = Tag::H1;\n         let _el: Node<Ms> = div![tag];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_tag() {\n         let tag: &Tag = &Tag::H1;\n         let _el: Node<Ms> = div![tag];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_el_ref() {\n         let el_ref: ElRef<web_sys::HtmlElement> = ElRef::default();\n         let _el: Node<Ms> = div![el_ref];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_el_ref() {\n         let el_ref: &ElRef<web_sys::HtmlElement> = &ElRef::default();\n         let _el: Node<Ms> = div![el_ref];\n         assert!(true);\n     }\n \n     // --- Texts ---\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_str() {\n         let text: &str = \"foo\";\n         let _el: Node<Ms> = div![text];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_string() {\n         let text: String = String::from(\"bar\");\n         let _el: Node<Ms> = div![text];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_string() {\n         let text: &String = &String::from(\"ref_bar\");\n         let _el: Node<Ms> = div![text];\n         assert!(true);\n     }\n \n     // --- Numbers ---\n \n     #[wasm_bindgen_test]\n     fn update_el_u32() {\n         let number: u32 = 100;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_u32() {\n         let number: &u32 = &1009;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_i32() {\n         let number: i32 = -25;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_i32() {\n         let number: &i32 = &-259;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_u64() {\n         let number: u64 = 100;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_u64() {\n         let number: &u64 = &1009;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_i64() {\n         let number: i64 = -25;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_i64() {\n         let number: &i64 = &-259;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_usize() {\n         let number: usize = 1_012;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_usize() {\n         let number: &usize = &10_129;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_f64() {\n         let number: f64 = 3.14;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_f64() {\n         let number: &f64 = &3.149;\n         let _el: Node<Ms> = div![number];\n         assert!(true);\n     }\n \n     // --- Containers ---\n \n     #[wasm_bindgen_test]\n     fn update_el_iterator_map() {\n         let map_iterator = vec![3, 4].into_iter().map(|n| n * 2);\n         let _el: Node<Ms> = div![map_iterator];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_iterator_filter() {\n         let filter_iterator = vec![3, 4].into_iter().filter(|n| n % 2 == 1);\n         let _el: Node<Ms> = div![filter_iterator];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_vec() {\n         let vec: Vec<&str> = vec![\"foo_1\", \"foo_2\"];\n         let _el: Node<Ms> = div![vec];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_vec() {\n         let vec: &Vec<&str> = &vec![\"foo_1\", \"foo_2\"];\n         let _el: Node<Ms> = div![vec];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_slice() {\n         let slice: &[&str] = &[\"foo_1\", \"foo_2\"];\n         let _el: Node<Ms> = div![slice];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_option_some() {\n         let option: Option<&str> = Some(\"foo_opt\");\n         let _el: Node<Ms> = div![option];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_ref_option_some() {\n         let option: &Option<&str> = &Some(\"foo_opt\");\n         let _el: Node<Ms> = div![option];\n         assert!(true);\n     }\n \n     #[wasm_bindgen_test]\n     fn update_el_option_none() {\n         let option: Option<&str> = None;\n         let _el: Node<Ms> = div![option];\n         assert!(true);\n     }\n }\n"}